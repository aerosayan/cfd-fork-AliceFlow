/* 19 08 2016 начало разработки АЛИС (пятница Monte Negro).
файл adaptive_local_refinement_mesh.cpp
АЛИС - Адаптивная Локально Измельченная Сетка.
Adaptive Local Refinement Grid.
30.08.2016 - версия 0.01 полностью неработоспособная 17 454 строк кода.
для сравнения :
constr_struct.cpp 5775 строк кода.
my_agregat_amg.c 57054 строк кода.
31.08.2016 - версия 0.01 полностью неработоспособная 19 876 строк кода.
сделан первоначальный учёт возможности четырёх соседей по face грани.
С 31.08 по 2.09 2016 не мог понять в чём ошибка, оказалось нужно сделать двухуровневость(двувариантность ) в count sosed.
2.09.2016 - версия 0.02 сделан учёт многоуровневости (двухуровности ) в update_max_count_sosed.
22 054 строки кода.
6.09.2016 работоспособная версия. Пред релиз. Приступаем к упаковке и тестированию. Версия 0.03. 34117 строк кода.
7.09.2016 Версия 0.03. Работоспособная версия. Пройдена проверка построения сетки для tgf2023_01 и Alqska1. Исправлена ошибка.
Пройдена проверка построения сетки для tgf2023_05 и tgf2023_20. Сеточный генератор содержит 34445 строк кода.
Поддерживаются призматические блоки и плоские прямоугольные источники и стенки в качестве геометрических объектов меширования.
*/

#ifndef _ADAPTIVE_LOCAL_REFINEMENT_MESH_CPP_
#define _ADAPTIVE_LOCAL_REFINEMENT_MESH_CPP_ 1

#define DEBUG_ALICE_MESH false
#define B_QUICK_MESHING true

#include "uniformsimplemeshgen.cpp" // сеточный генератор
#include <stdlib.h> // для функции exit(0)
#include <math.h> // для функции sqrt
//#include <Windows.h>

// Если просто кубикпо размеру кабинета и вообще никаких перегородок внутри.
bool bVerySimpleGeometryforALICE = true;

// стороны света.
#define ESIDE 0 // (east) восток
#define NSIDE 1 // север
#define TSIDE 2 // верх
#define WSIDE 3 // запад
#define SSIDE 4 // юг
#define BSIDE 5 // низ
#define EE 6
#define NN 7
#define TTSIDE 8
#define WW 9
#define SS 10
#define BB 11

// только для enumerate_volume_improved
// См. также заголовочный файл constr_struct.cpp
typedef struct TBlock_indexes {
	integer iL, iR, jL, jR, kL, kR;
} Block_indexes;

// для хеш таблицы.
typedef struct THASH_POLE {
	bool flag;
	integer inum;
} HASH_POLE;

// Узел octTree дерева.
typedef struct ToctTree {
	// 0-7 как вершины в nvtx
	ToctTree* link0;
	ToctTree* link1;
	ToctTree* link2;
	ToctTree* link3;
	ToctTree* link4;
	ToctTree* link5;
	ToctTree* link6;
	ToctTree* link7;
	TOCHKA p0;
	TOCHKA p1;
	TOCHKA p2;
	TOCHKA p3;
	TOCHKA p4;
	TOCHKA p5;
	TOCHKA p6;
	TOCHKA p7;
	bool dlist;// true если дробление закончилось.
	// если maxGsosed больше 4 то дробление.
	integer maxWsosed;
	integer maxEsosed;
	integer maxSsosed;
	integer maxNsosed;
	integer maxTsosed;
	integer maxBsosed;
	// Линки на 6 соседей.
	// Истина если face ячейки имеет четырёх соседей и 
	// false если face ячейки имеет только одного соседа.
	bool b4W, b4E, b4S, b4N, b4B, b4T;
	// Если сосед лишь один.
	ToctTree* linkW;
	ToctTree* linkE;
	ToctTree* linkS;
	ToctTree* linkN;
	ToctTree* linkB;
	ToctTree* linkT;
    // Если соседа 4 штуки.
	// 3 2 B
	// 0 1
	//******
	// 7 3 W
	// 4 0
	//******
	// 2 6 E
	// 1 5
	//******
	// 4 5 S
	// 0 1
	//******
	// 7 6 N
	// 3 2
	//******
	// 4 5 T
	// 6 7
	ToctTree* linkW0;
	ToctTree* linkW3;
	ToctTree* linkW4;
	ToctTree* linkW7;
	ToctTree* linkE1;
	ToctTree* linkE2;
	ToctTree* linkE5;
	ToctTree* linkE6;
	ToctTree* linkS0;
	ToctTree* linkS1;
	ToctTree* linkS4;
	ToctTree* linkS5;
	ToctTree* linkN2;
	ToctTree* linkN3;
	ToctTree* linkN6;
	ToctTree* linkN7;
	ToctTree* linkB0;
	ToctTree* linkB1;
	ToctTree* linkB2;
	ToctTree* linkB3;
	ToctTree* linkT4;
	ToctTree* linkT5;
	ToctTree* linkT6;
	ToctTree* linkT7;
	// Целочисленные координаты октанта.
	integer minx;
	integer maxx;
	integer miny;
	integer maxy;
	integer minz;
	integer maxz;
	// root info
	// for update neighbor procedure.
	integer root; // (0,link0) (1,link1) ...(7,link7)
	bool brootSituationX, brootSituationY, brootSituationZ;
	bool brootSituationX_virtual, brootSituationY_virtual, brootSituationZ_virtual;
	integer ilevel; // номер уровня в octTree дереве.
	ToctTree* parent; // ссылка на родителя.
	// updaтить ли линки now
	bool b_the_geometric_fragmentation;
	bool bcrushing_when_balancing;
	bool disbalance_now;
	// Следующие структуры используются только в модуле constr_struct_alice и далее ниже по коду и НЕ
	// используются и заполняются в модуле adaptive_local_refinement_mesh.cpp.
	// Уникальный номер внутреннего КО температурной области и 0 если не принадлежит области.
	integer inum_TD; // inumber Temperature Domain.
	integer inum_FD; // inumber Fluid Domain.
} octTree;

typedef struct TSTACK_ALICE {
	integer minx;
	integer maxx;
	integer miny;
	integer maxy;
	integer minz;
	integer maxz;
	octTree* link;
} STACK_ALICE;

STACK_ALICE* my_ALICE_STACK;
integer top_ALICE_STACK = 0;

octTree* oc_global = NULL;

// Для алгоритма сканирующих отрезков требуется дробить ячейку если отрезок внутри
// ячейки прошел чрез границу раздела двух блоков, т.е. номера блоков в соседних ячейках стали различны.
// Для детектирования данной особенности нужна хеш таблица сопоставляющая номер ячейки сетки из (inx+1)*(iny+1)*(inz+1) с номерами блоков.
// Данный метод абсолютно универсалн и подходит для любой формы блоков.
integer*** hash_for_droblenie_xyz = NULL;

// Возвращает минимум из двух целых чисел.
/*
integer min(integer ia, integer ib) {
	if (ia < ib) return ia;
	if (ia >= ib) return ib;
	return 0;
} // min
*/

// целочисленный ключ который используется в хеш таблице для ускорения поиска при экспорте в программу tecplot.
integer hash_key_alice33(integer inx, integer iny, integer inz, doublereal* &xpos, doublereal* &ypos, doublereal* &zpos, TOCHKA p, doublereal epsTolx, doublereal epsToly, doublereal epsTolz) {
	
	// Если скорость работы данной функции будет неприемлема, то можно воспользоваться 
	// двоичным поиском т.к. массивы упорядочены по возрастанию.

	const bool blinear_search = false;
	doublereal mult = 1.0e-100;
	mult = 1.0;

	// Поиск.
	integer i_vacant = -1;
	integer j_vacant = -1;
	integer k_vacant = -1;
	
	if (blinear_search) {
		for (integer i = 0; i <= inx; i++) {
			if (fabs(p.x - xpos[i]) < mult*epsTolx) {
				i_vacant = i;
				break;
			}
		}
	}
	else {
		// Binary Search // Двоичный поиск.
		integer istart = 1;
		integer iend = inx + 1;
		while (istart <= iend) {
			integer middle = (integer)(0.5*(istart + iend));
			if (fabs(xpos[middle - 1] - p.x) < epsTolx) {
				i_vacant = middle - 1;
				break;
			}
			else if (xpos[middle - 1] < p.x) {
				istart = middle + 1;
			}
			else {
				iend = middle - 1;
			}
		}
	}
	if (blinear_search) {
		for (integer j = 0; j <= iny; j++) {
			if (fabs(p.y - ypos[j]) < mult*epsToly) {
				j_vacant = j;
				break;
			}
		}
	}
	else {
		integer istart = 1;
		integer iend = iny + 1;
		while (istart <= iend) {
			integer middle = (integer)(0.5*(istart + iend));
			if (fabs(ypos[middle - 1] - p.y) < epsToly) {
				j_vacant = middle - 1;
				break;
			}
			else if (ypos[middle - 1] < p.y) {
				istart = middle + 1;
			}
			else {
				iend = middle - 1;
			}
		}
	}
	if (blinear_search) {
		for (integer k = 0; k <= inz; k++) {
			if (fabs(p.z - zpos[k]) < mult*epsTolz) {
				k_vacant = k;
				break;
			}
		}
	}
	else {
		integer istart = 1;
		integer iend = inz + 1;
		while (istart <= iend) {
			integer middle = (integer)(0.5*(istart + iend));
			if (fabs(zpos[middle - 1] - p.z) < epsTolz) {
				k_vacant = middle - 1;
				break;
			}
			else if (zpos[middle - 1] < p.z) {
				istart = middle + 1;
			}
			else {
				iend = middle - 1;
			}
		}
	}

	if ((i_vacant == -1) || (j_vacant == -1) || (k_vacant == -1)) {
		printf("error in hash_key_alice33\n");
		//getchar();
		system("PAUSE");
		exit(1);
	}
	else {
		return i_vacant + (inx + 1)*j_vacant + (inx + 1)*(iny + 1)*k_vacant;
	}

} // hash_key_alice33

bool is_null(ToctTree* &oc) {
	bool b1 = false;
	if (oc != NULL) {
		if ((oc->link0 == NULL) && (oc->link1 == NULL) && (oc->link2 == NULL) && (oc->link3 == NULL) && (oc->link4 == NULL) && (oc->link5 == NULL) && (oc->link6 == NULL) && (oc->link7 == NULL)) {
			b1 = true;
		}
	}
	return b1;
} // is_null

// print_link
integer print_link(octTree* &oc2) {
	if (oc2 == NULL) {
		//printf("N");
		return 9; // NULL
	}
	else {
#if doubleintprecision == 1
		//printf("%lld", oc2->root);
#else
		//printf("%d", oc2->root);
#endif
		
		return oc2->root;
	}
} // print_link

// Правильная версия is_null1 6 сентября 2016.
// Ячейка делённая но наследников у потомков нет.
bool is_null1_new(ToctTree* &oc) {
	bool b1 = false;
	if (oc != NULL) {
		b1 = true;
		if (oc->link0 != NULL) {
			if (oc->link0->link0 != NULL) b1 = false;
			if (oc->link0->link1 != NULL) b1 = false;
			if (oc->link0->link2 != NULL) b1 = false;
			if (oc->link0->link3 != NULL) b1 = false;
			if (oc->link0->link4 != NULL) b1 = false;
			if (oc->link0->link5 != NULL) b1 = false;
			if (oc->link0->link6 != NULL) b1 = false;
			if (oc->link0->link7 != NULL) b1 = false;
		}
		if (oc->link1 != NULL) {
			if (oc->link1->link0 != NULL) b1 = false;
			if (oc->link1->link1 != NULL) b1 = false;
			if (oc->link1->link2 != NULL) b1 = false;
			if (oc->link1->link3 != NULL) b1 = false;
			if (oc->link1->link4 != NULL) b1 = false;
			if (oc->link1->link5 != NULL) b1 = false;
			if (oc->link1->link6 != NULL) b1 = false;
			if (oc->link1->link7 != NULL) b1 = false;
		}
		if (oc->link2 != NULL) {
			if (oc->link2->link0 != NULL) b1 = false;
			if (oc->link2->link1 != NULL) b1 = false;
			if (oc->link2->link2 != NULL) b1 = false;
			if (oc->link2->link3 != NULL) b1 = false;
			if (oc->link2->link4 != NULL) b1 = false;
			if (oc->link2->link5 != NULL) b1 = false;
			if (oc->link2->link6 != NULL) b1 = false;
			if (oc->link2->link7 != NULL) b1 = false;
		}
		if (oc->link3 != NULL) {
			if (oc->link3->link0 != NULL) b1 = false;
			if (oc->link3->link1 != NULL) b1 = false;
			if (oc->link3->link2 != NULL) b1 = false;
			if (oc->link3->link3 != NULL) b1 = false;
			if (oc->link3->link4 != NULL) b1 = false;
			if (oc->link3->link5 != NULL) b1 = false;
			if (oc->link3->link6 != NULL) b1 = false;
			if (oc->link3->link7 != NULL) b1 = false;
		}
		if (oc->link4 != NULL) {
			if (oc->link4->link0 != NULL) b1 = false;
			if (oc->link4->link1 != NULL) b1 = false;
			if (oc->link4->link2 != NULL) b1 = false;
			if (oc->link4->link3 != NULL) b1 = false;
			if (oc->link4->link4 != NULL) b1 = false;
			if (oc->link4->link5 != NULL) b1 = false;
			if (oc->link4->link6 != NULL) b1 = false;
			if (oc->link4->link7 != NULL) b1 = false;
		}
		if (oc->link5 != NULL) {
			if (oc->link5->link0 != NULL) b1 = false;
			if (oc->link5->link1 != NULL) b1 = false;
			if (oc->link5->link2 != NULL) b1 = false;
			if (oc->link5->link3 != NULL) b1 = false;
			if (oc->link5->link4 != NULL) b1 = false;
			if (oc->link5->link5 != NULL) b1 = false;
			if (oc->link5->link6 != NULL) b1 = false;
			if (oc->link5->link7 != NULL) b1 = false;
		}
		if (oc->link6 != NULL) {
			if (oc->link6->link0 != NULL) b1 = false;
			if (oc->link6->link1 != NULL) b1 = false;
			if (oc->link6->link2 != NULL) b1 = false;
			if (oc->link6->link3 != NULL) b1 = false;
			if (oc->link6->link4 != NULL) b1 = false;
			if (oc->link6->link5 != NULL) b1 = false;
			if (oc->link6->link6 != NULL) b1 = false;
			if (oc->link6->link7 != NULL) b1 = false;
		}
		if (oc->link7 != NULL) {
			if (oc->link7->link0 != NULL) b1 = false;
			if (oc->link7->link1 != NULL) b1 = false;
			if (oc->link7->link2 != NULL) b1 = false;
			if (oc->link7->link3 != NULL) b1 = false;
			if (oc->link7->link4 != NULL) b1 = false;
			if (oc->link7->link5 != NULL) b1 = false;
			if (oc->link7->link6 != NULL) b1 = false;
			if (oc->link7->link7 != NULL) b1 = false;
		}

	}
	return b1;
}

// истина только в случае деления ячейки на 8 подъячеек причем каждая подъячейка это лист.
bool is_null1(ToctTree* &oc)
{
	// direct WSIDE, SSIDE, B:
	//integer dir = direct;
	//if (dir == ESIDE) dir = WSIDE;
	//if (dir == N) dir = S;
	//if (dir == T) dir = B;

	bool b1 = false;

	if (oc != NULL) {
		/*
		switch (dir) {
		case WSIDE: // 0,3,4,7
		if ((oc->link0 != NULL) && (oc->link3 != NULL) && (oc->link4 != NULL) && (oc->link7 != NULL)) {
		if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
		if ((oc->link3->link0 == NULL) && (oc->link3->link1 == NULL) && (oc->link3->link2 == NULL) && (oc->link3->link3 == NULL) && (oc->link3->link4 == NULL) && (oc->link3->link5 == NULL) && (oc->link3->link6 == NULL) && (oc->link3->link7 == NULL)) {
		if ((oc->link4->link0 == NULL) && (oc->link4->link1 == NULL) && (oc->link4->link2 == NULL) && (oc->link4->link3 == NULL) && (oc->link4->link4 == NULL) && (oc->link4->link5 == NULL) && (oc->link4->link6 == NULL) && (oc->link4->link7 == NULL)) {
		if ((oc->link7->link0 == NULL) && (oc->link7->link1 == NULL) && (oc->link7->link2 == NULL) && (oc->link7->link3 == NULL) && (oc->link7->link4 == NULL) && (oc->link7->link5 == NULL) && (oc->link7->link6 == NULL) && (oc->link7->link7 == NULL)) {
		b1 = true;

		}

		}


		}
		}
		}
		break;
		case S: // 0,1,4,5
		if ((oc->link0 != NULL) && (oc->link1 != NULL) && (oc->link4 != NULL) && (oc->link5 != NULL)) {
		if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
		if ((oc->link1->link0 == NULL) && (oc->link1->link1 == NULL) && (oc->link1->link2 == NULL) && (oc->link1->link3 == NULL) && (oc->link1->link4 == NULL) && (oc->link1->link5 == NULL) && (oc->link1->link6 == NULL) && (oc->link1->link7 == NULL)) {
		if ((oc->link4->link0 == NULL) && (oc->link4->link1 == NULL) && (oc->link4->link2 == NULL) && (oc->link4->link3 == NULL) && (oc->link4->link4 == NULL) && (oc->link4->link5 == NULL) && (oc->link4->link6 == NULL) && (oc->link4->link7 == NULL)) {
		if ((oc->link5->link0 == NULL) && (oc->link5->link1 == NULL) && (oc->link5->link2 == NULL) && (oc->link5->link3 == NULL) && (oc->link5->link4 == NULL) && (oc->link5->link5 == NULL) && (oc->link5->link6 == NULL) && (oc->link5->link7 == NULL)) {
		b1 = true;


		}
		}


		}
		}
		}
		break;
		case BSIDE: // 0,1,2,3
		// Т.к. может быть вырождение по Z.
		if ((oc->link0 != NULL) && (oc->link1 != NULL) && (oc->link2 != NULL) && (oc->link3 != NULL)) {
		if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
		if ((oc->link1->link0 == NULL) && (oc->link1->link1 == NULL) && (oc->link1->link2 == NULL) && (oc->link1->link3 == NULL) && (oc->link1->link4 == NULL) && (oc->link1->link5 == NULL) && (oc->link1->link6 == NULL) && (oc->link1->link7 == NULL)) {
		if ((oc->link2->link0 == NULL) && (oc->link2->link1 == NULL) && (oc->link2->link2 == NULL) && (oc->link2->link3 == NULL) && (oc->link2->link4 == NULL) && (oc->link2->link5 == NULL) && (oc->link2->link6 == NULL) && (oc->link2->link7 == NULL)) {
		if ((oc->link3->link0 == NULL) && (oc->link3->link1 == NULL) && (oc->link3->link2 == NULL) && (oc->link3->link3 == NULL) && (oc->link3->link4 == NULL) && (oc->link3->link5 == NULL) && (oc->link3->link6 == NULL) && (oc->link3->link7 == NULL)) {
		b1 = true;
		}
		}
		}
		}
		}
		break;
		default:
		printf("ERROR!!! is_null1 error in direct\n");
		getchar();
		exit(1);
		break;
		}
		*/

		if ((oc->link0 != NULL) && (oc->link1 != NULL) && (oc->link2 != NULL) && (oc->link3 != NULL) && (oc->link4 != NULL) && (oc->link5 != NULL) && (oc->link6 != NULL) && (oc->link7 != NULL)) {
			if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
				if ((oc->link1->link0 == NULL) && (oc->link1->link1 == NULL) && (oc->link1->link2 == NULL) && (oc->link1->link3 == NULL) && (oc->link1->link4 == NULL) && (oc->link1->link5 == NULL) && (oc->link1->link6 == NULL) && (oc->link1->link7 == NULL)) {
					if ((oc->link2->link0 == NULL) && (oc->link2->link1 == NULL) && (oc->link2->link2 == NULL) && (oc->link2->link3 == NULL) && (oc->link2->link4 == NULL) && (oc->link2->link5 == NULL) && (oc->link2->link6 == NULL) && (oc->link2->link7 == NULL)) {
						if ((oc->link3->link0 == NULL) && (oc->link3->link1 == NULL) && (oc->link3->link2 == NULL) && (oc->link3->link3 == NULL) && (oc->link3->link4 == NULL) && (oc->link3->link5 == NULL) && (oc->link3->link6 == NULL) && (oc->link3->link7 == NULL)) {
							if ((oc->link4->link0 == NULL) && (oc->link4->link1 == NULL) && (oc->link4->link2 == NULL) && (oc->link4->link3 == NULL) && (oc->link4->link4 == NULL) && (oc->link4->link5 == NULL) && (oc->link4->link6 == NULL) && (oc->link4->link7 == NULL)) {
								if ((oc->link5->link0 == NULL) && (oc->link5->link1 == NULL) && (oc->link5->link2 == NULL) && (oc->link5->link3 == NULL) && (oc->link5->link4 == NULL) && (oc->link5->link5 == NULL) && (oc->link5->link6 == NULL) && (oc->link5->link7 == NULL)) {
									if ((oc->link6->link0 == NULL) && (oc->link6->link1 == NULL) && (oc->link6->link2 == NULL) && (oc->link6->link3 == NULL) && (oc->link6->link4 == NULL) && (oc->link6->link5 == NULL) && (oc->link6->link6 == NULL) && (oc->link6->link7 == NULL)) {
										if ((oc->link7->link0 == NULL) && (oc->link7->link1 == NULL) && (oc->link7->link2 == NULL) && (oc->link7->link3 == NULL) && (oc->link7->link4 == NULL) && (oc->link7->link5 == NULL) && (oc->link7->link6 == NULL) && (oc->link7->link7 == NULL)) {
											b1 = true;
										}
									}
								}
							}
						}
					}
				}
			}
		}

	}
	return b1;
} // is_null1

bool is_null1_(ToctTree* &oc, integer direct)
{
	// direct WSIDE, SSIDE, B:
	integer dir = direct;
	if (dir == ESIDE) dir = WSIDE;
	if (dir == NSIDE) dir = SSIDE;
	if (dir == TSIDE) dir = BSIDE;

	bool b1 = false;

	if (oc != NULL) {
		switch (dir) {
		case WSIDE: // 0,3,4,7
			if ((oc->link0 != NULL) && (oc->link3 != NULL) && (oc->link4 != NULL) && (oc->link7 != NULL)) {
				if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
					if ((oc->link3->link0 == NULL) && (oc->link3->link1 == NULL) && (oc->link3->link2 == NULL) && (oc->link3->link3 == NULL) && (oc->link3->link4 == NULL) && (oc->link3->link5 == NULL) && (oc->link3->link6 == NULL) && (oc->link3->link7 == NULL)) {
						if ((oc->link4->link0 == NULL) && (oc->link4->link1 == NULL) && (oc->link4->link2 == NULL) && (oc->link4->link3 == NULL) && (oc->link4->link4 == NULL) && (oc->link4->link5 == NULL) && (oc->link4->link6 == NULL) && (oc->link4->link7 == NULL)) {
							if ((oc->link7->link0 == NULL) && (oc->link7->link1 == NULL) && (oc->link7->link2 == NULL) && (oc->link7->link3 == NULL) && (oc->link7->link4 == NULL) && (oc->link7->link5 == NULL) && (oc->link7->link6 == NULL) && (oc->link7->link7 == NULL)) {
								b1 = true;

							}

						}


					}
				}
			}
			break;
		case SSIDE: // 0,1,4,5 
			if ((oc->link0 != NULL) && (oc->link1 != NULL) && (oc->link4 != NULL) && (oc->link5 != NULL)) {
				if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
					if ((oc->link1->link0 == NULL) && (oc->link1->link1 == NULL) && (oc->link1->link2 == NULL) && (oc->link1->link3 == NULL) && (oc->link1->link4 == NULL) && (oc->link1->link5 == NULL) && (oc->link1->link6 == NULL) && (oc->link1->link7 == NULL)) {
						if ((oc->link4->link0 == NULL) && (oc->link4->link1 == NULL) && (oc->link4->link2 == NULL) && (oc->link4->link3 == NULL) && (oc->link4->link4 == NULL) && (oc->link4->link5 == NULL) && (oc->link4->link6 == NULL) && (oc->link4->link7 == NULL)) {
							if ((oc->link5->link0 == NULL) && (oc->link5->link1 == NULL) && (oc->link5->link2 == NULL) && (oc->link5->link3 == NULL) && (oc->link5->link4 == NULL) && (oc->link5->link5 == NULL) && (oc->link5->link6 == NULL) && (oc->link5->link7 == NULL)) {
								b1 = true;


							}
						}


					}
				}
			}
			break;
		case BSIDE: // 0,1,2,3
			// Т.к. может быть вырождение по Z.
			if ((oc->link0 != NULL) && (oc->link1 != NULL) && (oc->link2 != NULL) && (oc->link3 != NULL)) {
				if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
					if ((oc->link1->link0 == NULL) && (oc->link1->link1 == NULL) && (oc->link1->link2 == NULL) && (oc->link1->link3 == NULL) && (oc->link1->link4 == NULL) && (oc->link1->link5 == NULL) && (oc->link1->link6 == NULL) && (oc->link1->link7 == NULL)) {
						if ((oc->link2->link0 == NULL) && (oc->link2->link1 == NULL) && (oc->link2->link2 == NULL) && (oc->link2->link3 == NULL) && (oc->link2->link4 == NULL) && (oc->link2->link5 == NULL) && (oc->link2->link6 == NULL) && (oc->link2->link7 == NULL)) {
							if ((oc->link3->link0 == NULL) && (oc->link3->link1 == NULL) && (oc->link3->link2 == NULL) && (oc->link3->link3 == NULL) && (oc->link3->link4 == NULL) && (oc->link3->link5 == NULL) && (oc->link3->link6 == NULL) && (oc->link3->link7 == NULL)) {
								b1 = true;
							}
						}
					}
				}
			}
			break;
		default:
			printf("ERROR!!! is_null1 error in direct\n");
			//getchar();
			system("PAUSE");
			exit(1);
			break;
		}

		/*
		if ((oc->link0 != NULL) && (oc->link1 != NULL) && (oc->link2 != NULL) && (oc->link3 != NULL) && (oc->link4 != NULL) && (oc->link5 != NULL) && (oc->link6 != NULL) && (oc->link7 != NULL)) {
		if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
		if ((oc->link1->link0 == NULL) && (oc->link1->link1 == NULL) && (oc->link1->link2 == NULL) && (oc->link1->link3 == NULL) && (oc->link1->link4 == NULL) && (oc->link1->link5 == NULL) && (oc->link1->link6 == NULL) && (oc->link1->link7 == NULL)) {
		if ((oc->link2->link0 == NULL) && (oc->link2->link1 == NULL) && (oc->link2->link2 == NULL) && (oc->link2->link3 == NULL) && (oc->link2->link4 == NULL) && (oc->link2->link5 == NULL) && (oc->link2->link6 == NULL) && (oc->link2->link7 == NULL)) {
		if ((oc->link3->link0 == NULL) && (oc->link3->link1 == NULL) && (oc->link3->link2 == NULL) && (oc->link3->link3 == NULL) && (oc->link3->link4 == NULL) && (oc->link3->link5 == NULL) && (oc->link3->link6 == NULL) && (oc->link3->link7 == NULL)) {
		if ((oc->link4->link0 == NULL) && (oc->link4->link1 == NULL) && (oc->link4->link2 == NULL) && (oc->link4->link3 == NULL) && (oc->link4->link4 == NULL) && (oc->link4->link5 == NULL) && (oc->link4->link6 == NULL) && (oc->link4->link7 == NULL)) {
		if ((oc->link5->link0 == NULL) && (oc->link5->link1 == NULL) && (oc->link5->link2 == NULL) && (oc->link5->link3 == NULL) && (oc->link5->link4 == NULL) && (oc->link5->link5 == NULL) && (oc->link5->link6 == NULL) && (oc->link5->link7 == NULL)) {
		if ((oc->link6->link0 == NULL) && (oc->link6->link1 == NULL) && (oc->link6->link2 == NULL) && (oc->link6->link3 == NULL) && (oc->link6->link4 == NULL) && (oc->link6->link5 == NULL) && (oc->link6->link6 == NULL) && (oc->link6->link7 == NULL)) {
		if ((oc->link7->link0 == NULL) && (oc->link7->link1 == NULL) && (oc->link7->link2 == NULL) && (oc->link7->link3 == NULL) && (oc->link7->link4 == NULL) && (oc->link7->link5 == NULL) && (oc->link7->link6 == NULL) && (oc->link7->link7 == NULL)) {
		b1 = true;
		}
		}
		}
		}
		}
		}
		}
		}
		}
		*/
	}
	return b1;
} // is_null1_

bool is_null2(ToctTree* &oc, integer direct, integer &c0, integer &c1, integer &c2, integer &c3, integer &c4, integer &c5, integer &c6, integer &c7)
{
	// cface - это количество соседей по face грани.

	c0 = 0;
	c1 = 0;
	c2 = 0;
	c3 = 0;
	c4 = 0;
	c5 = 0;
	c6 = 0;
	c7 = 0;

	// direct WSIDE, SSIDE, B:
	integer dir = direct;
	if (dir == ESIDE) dir = WSIDE;
	if (dir == NSIDE) dir = SSIDE;
	if (dir == TSIDE) dir = BSIDE;

	bool b1 = false;

	if (oc != NULL) {

		switch (dir) {
		case WSIDE: // 0,3,4,7
			if ((oc->link0 != NULL) && (oc->link3 != NULL) && (oc->link4 != NULL) && (oc->link7 != NULL)) {
				if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
					if ((oc->link3->link0 == NULL) && (oc->link3->link1 == NULL) && (oc->link3->link2 == NULL) && (oc->link3->link3 == NULL) && (oc->link3->link4 == NULL) && (oc->link3->link5 == NULL) && (oc->link3->link6 == NULL) && (oc->link3->link7 == NULL)) {
						if ((oc->link4->link0 == NULL) && (oc->link4->link1 == NULL) && (oc->link4->link2 == NULL) && (oc->link4->link3 == NULL) && (oc->link4->link4 == NULL) && (oc->link4->link5 == NULL) && (oc->link4->link6 == NULL) && (oc->link4->link7 == NULL)) {
							if ((oc->link7->link0 == NULL) && (oc->link7->link1 == NULL) && (oc->link7->link2 == NULL) && (oc->link7->link3 == NULL) && (oc->link7->link4 == NULL) && (oc->link7->link5 == NULL) && (oc->link7->link6 == NULL) && (oc->link7->link7 == NULL)) {
								b1 = true;
							}
						}
					}
				}
			}
			if (oc->link0 != NULL) {
				c0 = 1;
				integer ic0 = 0;
				if (oc->link0->link0 != NULL) {
					ic0++;
				}
				if (oc->link0->link3 != NULL) {
					ic0++;
				}
				if (oc->link0->link4 != NULL) {
					ic0++;
				}
				if (oc->link0->link7 != NULL) {
					ic0++;
				}
				if (ic0 == 0) {
					c0 = 1;
				}
				else {
					c0 = ic0; // 4 или 2.
				}
			}
			if (oc->link3 != NULL) {
				c3 = 1;
				integer ic0 = 0;
				if (oc->link3->link0 != NULL) {
					ic0++;
				}
				if (oc->link3->link3 != NULL) {
					ic0++;
				}
				if (oc->link3->link4 != NULL) {
					ic0++;
				}
				if (oc->link3->link7 != NULL) {
					ic0++;
				}
				if (ic0 == 0) {
					c3 = 1;
				}
				else {
					c3 = ic0; // 4 или 2.
				}
			}
			if (oc->link4 != NULL) {
				c4 = 1;
				integer ic0 = 0;
				if (oc->link4->link0 != NULL) {
					ic0++;
				}
				if (oc->link4->link3 != NULL) {
					ic0++;
				}
				if (oc->link4->link4 != NULL) {
					ic0++;
				}
				if (oc->link4->link7 != NULL) {
					ic0++;
				}
				if (ic0 == 0) {
					c4 = 1;
				}
				else {
					c4 = ic0; // 4 или 2.
				}
			}
			if (oc->link7 != NULL) {
				c7 = 1;
				integer ic0 = 0;
				if (oc->link7->link0 != NULL) {
					ic0++;
				}
				if (oc->link7->link3 != NULL) {
					ic0++;
				}
				if (oc->link7->link4 != NULL) {
					ic0++;
				}
				if (oc->link7->link7 != NULL) {
					ic0++;
				}
				if (ic0 == 0) {
					c7 = 1;
				}
				else {
					c7 = ic0; // 4 или 2.
				}
			}
			break;
		case SSIDE: // 0,1,4,5 
			if ((oc->link0 != NULL) && (oc->link1 != NULL) && (oc->link4 != NULL) && (oc->link5 != NULL)) {
				if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
					if ((oc->link1->link0 == NULL) && (oc->link1->link1 == NULL) && (oc->link1->link2 == NULL) && (oc->link1->link3 == NULL) && (oc->link1->link4 == NULL) && (oc->link1->link5 == NULL) && (oc->link1->link6 == NULL) && (oc->link1->link7 == NULL)) {
						if ((oc->link4->link0 == NULL) && (oc->link4->link1 == NULL) && (oc->link4->link2 == NULL) && (oc->link4->link3 == NULL) && (oc->link4->link4 == NULL) && (oc->link4->link5 == NULL) && (oc->link4->link6 == NULL) && (oc->link4->link7 == NULL)) {
							if ((oc->link5->link0 == NULL) && (oc->link5->link1 == NULL) && (oc->link5->link2 == NULL) && (oc->link5->link3 == NULL) && (oc->link5->link4 == NULL) && (oc->link5->link5 == NULL) && (oc->link5->link6 == NULL) && (oc->link5->link7 == NULL)) {
								b1 = true;
							}
						}
					}
				}
			}
			if (oc->link0 != NULL) {
				c0 = 1;
				integer ic0 = 0;
				if (oc->link0->link0 != NULL) {
					ic0++;
				}
				if (oc->link0->link1 != NULL) {
					ic0++;
				}
				if (oc->link0->link4 != NULL) {
					ic0++;
				}
				if (oc->link0->link5 != NULL) {
					ic0++;
				}
				if (ic0 == 0) {
					c0 = 1;
				}
				else {
					c0 = ic0; // 4 или 2.
				}
			}
			if (oc->link1 != NULL) {
				c1 = 1;
				integer ic0 = 0;
				if (oc->link1->link0 != NULL) {
					ic0++;
				}
				if (oc->link1->link1 != NULL) {
					ic0++;
				}
				if (oc->link1->link4 != NULL) {
					ic0++;
				}
				if (oc->link1->link5 != NULL) {
					ic0++;
				}
				if (ic0 == 0) {
					c1 = 1;
				}
				else {
					c1 = ic0; // 4 или 2.
				}
			}
			if (oc->link4 != NULL) {
				c4 = 1;
				integer ic0 = 0;
				if (oc->link4->link0 != NULL) {
					ic0++;
				}
				if (oc->link4->link1 != NULL) {
					ic0++;
				}
				if (oc->link4->link4 != NULL) {
					ic0++;
				}
				if (oc->link4->link5 != NULL) {
					ic0++;
				}
				if (ic0 == 0) {
					c4 = 1;
				}
				else {
					c4 = ic0; // 4 или 2.
				}
			}
			if (oc->link5 != NULL) {
				c5 = 1;
				integer ic0 = 0;
				if (oc->link5->link0 != NULL) {
					ic0++;
				}
				if (oc->link5->link1 != NULL) {
					ic0++;
				}
				if (oc->link5->link4 != NULL) {
					ic0++;
				}
				if (oc->link5->link5 != NULL) {
					ic0++;
				}
				if (ic0 == 0) {
					c5 = 1;
				}
				else {
					c5 = ic0; // 4 или 2.
				}
			}


			break;
		case BSIDE: // 0,1,2,3
			// Т.к. может быть вырождение по Z.
			if ((oc->link0 != NULL) && (oc->link1 != NULL) && (oc->link2 != NULL) && (oc->link3 != NULL)) {
				if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
					if ((oc->link1->link0 == NULL) && (oc->link1->link1 == NULL) && (oc->link1->link2 == NULL) && (oc->link1->link3 == NULL) && (oc->link1->link4 == NULL) && (oc->link1->link5 == NULL) && (oc->link1->link6 == NULL) && (oc->link1->link7 == NULL)) {
						if ((oc->link2->link0 == NULL) && (oc->link2->link1 == NULL) && (oc->link2->link2 == NULL) && (oc->link2->link3 == NULL) && (oc->link2->link4 == NULL) && (oc->link2->link5 == NULL) && (oc->link2->link6 == NULL) && (oc->link2->link7 == NULL)) {
							if ((oc->link3->link0 == NULL) && (oc->link3->link1 == NULL) && (oc->link3->link2 == NULL) && (oc->link3->link3 == NULL) && (oc->link3->link4 == NULL) && (oc->link3->link5 == NULL) && (oc->link3->link6 == NULL) && (oc->link3->link7 == NULL)) {
								b1 = true;
							}
						}
					}
				}
			}
			if (oc->link0 != NULL) {
				c0 = 1;
				integer ic0 = 0;
				if (oc->link0->link0 != NULL) {
					ic0++;
				}
				if (oc->link0->link1 != NULL) {
					ic0++;
				}
				if (oc->link0->link2 != NULL) {
					ic0++;
				}
				if (oc->link0->link3 != NULL) {
					ic0++;
				}
				if (ic0 == 0) {
					c0 = 1;
				}
				else {
					c0 = ic0; // 4 или 2.
				}
			}

			if (oc->link1 != NULL) {
				c1 = 1;
				integer ic0 = 0;
				if (oc->link1->link0 != NULL) {
					ic0++;
				}
				if (oc->link1->link1 != NULL) {
					ic0++;
				}
				if (oc->link1->link2 != NULL) {
					ic0++;
				}
				if (oc->link1->link3 != NULL) {
					ic0++;
				}
				if (ic0 == 0) {
					c1 = 1;
				}
				else {
					c1 = ic0; // 4 или 2.
				}
			}
			if (oc->link2 != NULL) {
				c2 = 1;
				integer ic0 = 0;
				if (oc->link2->link0 != NULL) {
					ic0++;
				}
				if (oc->link2->link1 != NULL) {
					ic0++;
				}
				if (oc->link2->link2 != NULL) {
					ic0++;
				}
				if (oc->link2->link3 != NULL) {
					ic0++;
				}
				if (ic0 == 0) {
					c2 = 1;
				}
				else {
					c2 = ic0; // 4 или 2.
				}
			}
			if (oc->link3 != NULL) {
				c3 = 1;
				integer ic0 = 0;
				if (oc->link3->link0 != NULL) {
					ic0++;
				}
				if (oc->link3->link1 != NULL) {
					ic0++;
				}
				if (oc->link3->link2 != NULL) {
					ic0++;
				}
				if (oc->link3->link3 != NULL) {
					ic0++;
				}
				if (ic0 == 0) {
					c3 = 1;
				}
				else {
					c3 = ic0; // 4 или 2.
				}
			}


			break;
		default:
			printf("ERROR!!! is_null1 error in direct\n");
			//getchar();
			system("PAUSE");
			exit(1);
			break;
		}

	}
	return b1;
} // is_null2

bool is_null3(ToctTree* &oc, integer direct, integer &c0, integer &c1, integer &c2, integer &c3, integer &c4, integer &c5, integer &c6, integer &c7)
{
	// cface - это количество соседей по face грани.

	c0 = 0;
	c1 = 0;
	c2 = 0;
	c3 = 0;
	c4 = 0;
	c5 = 0;
	c6 = 0;
	c7 = 0;

	//    N
	//  W P E
	//    S

	// direct WSIDE, SSIDE, B:
	integer dir = direct;

	bool bSituationX = false;
	bool bSituationY = false;
	bool bSituationZ = false;
	if (oc != NULL) {
		if ((oc->link0 != NULL) && (oc->link1 != NULL) && (oc->link2 != NULL) && (oc->link3 != NULL) && (oc->link4 == NULL) && (oc->link5 == NULL) && (oc->link6 == NULL) && (oc->link7 == NULL)) {
			bSituationZ = true;
		}
		if ((oc->link0 != NULL) && (oc->link1 == NULL) && (oc->link2 == NULL) && (oc->link3 != NULL) && (oc->link4 != NULL) && (oc->link5 == NULL) && (oc->link6 == NULL) && (oc->link7 != NULL)) {
			bSituationX = true;
		}
		if ((oc->link0 != NULL) && (oc->link1 != NULL) && (oc->link2 == NULL) && (oc->link3 == NULL) && (oc->link4 != NULL) && (oc->link5 != NULL) && (oc->link6 == NULL) && (oc->link7 == NULL)) {
			bSituationY = true;
		}
	}

	// на данный момент запрограммирован только случай невырожденной ячейки которая раздроблена на 8 равных подъячеек.
	// внешний алгоритм видит эту ячейку именно такой, отдельные случаи вырождения требуют особого прописывания в коде.

	bool b1 = false;
	if ((bSituationZ) && (!bSituationY) && (!bSituationX)) {
		// Вырождение по Z
		if (oc != NULL) {
			switch (dir) {
			case TSIDE: case  BSIDE: // 0,1,2,3

				if (oc->link0 != NULL) {
					c0 = 1; c4 = 1;
					integer ic0 = 0;
					if (oc->link0->link0 != NULL) {
						ic0++;
					}
					if (oc->link0->link1 != NULL) {
						ic0++;
					}
					if (oc->link0->link2 != NULL) {
						ic0++;
					}
					if (oc->link0->link3 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
						c4 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
						c4 = ic0;
					}
				}

				if (oc->link1 != NULL) {
					c1 = 1; c5 = 1;
					integer ic0 = 0;
					if (oc->link1->link0 != NULL) {
						ic0++;
					}
					if (oc->link1->link1 != NULL) {
						ic0++;
					}
					if (oc->link1->link2 != NULL) {
						ic0++;
					}
					if (oc->link1->link3 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1;
						c5 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
						c5 = ic0;
					}
				}
				if (oc->link2 != NULL) {
					c2 = 1; c6 = 1;
					integer ic0 = 0;
					if (oc->link2->link0 != NULL) {
						ic0++;
					}
					if (oc->link2->link1 != NULL) {
						ic0++;
					}
					if (oc->link2->link2 != NULL) {
						ic0++;
					}
					if (oc->link2->link3 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c2 = 1;
						c6 = 1;
					}
					else {
						c2 = ic0; // 4 или 2.
						c6 = ic0;
					}
				}
				if (oc->link3 != NULL) {
					c3 = 1; c7 = 1;
					integer ic0 = 0;
					if (oc->link3->link0 != NULL) {
						ic0++;
					}
					if (oc->link3->link1 != NULL) {
						ic0++;
					}
					if (oc->link3->link2 != NULL) {
						ic0++;
					}
					if (oc->link3->link3 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
						c7 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
						c7 = ic0;
					}
				}


				break;
			case WSIDE:  // 1,2
				if ((oc->link1 != NULL) && (oc->link2 != NULL)) {
					if ((oc->link1->link0 == NULL) && (oc->link1->link1 == NULL) && (oc->link1->link2 == NULL) && (oc->link1->link3 == NULL) && (oc->link1->link4 == NULL) && (oc->link1->link5 == NULL) && (oc->link1->link6 == NULL) && (oc->link1->link7 == NULL)) {
						if ((oc->link2->link0 == NULL) && (oc->link2->link1 == NULL) && (oc->link2->link2 == NULL) && (oc->link2->link3 == NULL) && (oc->link2->link4 == NULL) && (oc->link2->link5 == NULL) && (oc->link2->link6 == NULL) && (oc->link2->link7 == NULL)) {
							b1 = true;
						}

					}
				}
				if (oc->link1 != NULL) {
					c1 = 1;
					integer ic0 = 0;
					if (oc->link1->link1 != NULL) {
						ic0++;
					}
					if (oc->link1->link2 != NULL) {
						ic0++;
					}
					if (oc->link1->link5 != NULL) {
						ic0++;
					}
					if (oc->link1->link6 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
					}
				}
				if (oc->link2 != NULL) {
					c2 = 1;
					integer ic0 = 0;
					if (oc->link2->link1 != NULL) {
						ic0++;
					}
					if (oc->link2->link2 != NULL) {
						ic0++;
					}
					if (oc->link2->link5 != NULL) {
						ic0++;
					}
					if (oc->link2->link6 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c2 = 1;
					}
					else {
						c2 = ic0; // 4 или 2.
					}
				}
				// Этих ячеек нет значит и счётчики равны нулю.
				c5 = 0;
				c6 = 0;

				break;
			case ESIDE: // 0,3
				if ((oc->link0 != NULL) && (oc->link3 != NULL)) {
					if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
						if ((oc->link3->link0 == NULL) && (oc->link3->link1 == NULL) && (oc->link3->link2 == NULL) && (oc->link3->link3 == NULL) && (oc->link3->link4 == NULL) && (oc->link3->link5 == NULL) && (oc->link3->link6 == NULL) && (oc->link3->link7 == NULL)) {
							b1 = true;
						}

					}
				}
				if (oc->link0 != NULL) {
					c0 = 1;
					integer ic0 = 0;
					if (oc->link0->link0 != NULL) {
						ic0++;
					}
					if (oc->link0->link3 != NULL) {
						ic0++;
					}
					if (oc->link0->link4 != NULL) {
						ic0++;
					}
					if (oc->link0->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
					}
				}
				if (oc->link3 != NULL) {
					c3 = 1;
					integer ic0 = 0;
					if (oc->link3->link0 != NULL) {
						ic0++;
					}
					if (oc->link3->link3 != NULL) {
						ic0++;
					}
					if (oc->link3->link4 != NULL) {
						ic0++;
					}
					if (oc->link3->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
					}
				}
				c4 = 0;
				c7 = 0;

				break;
			case SSIDE: // 2,3
				if ((oc->link2 != NULL) && (oc->link3 != NULL) && (oc->link6 != NULL) && (oc->link7 != NULL)) {
					if ((oc->link2->link0 == NULL) && (oc->link2->link1 == NULL) && (oc->link2->link2 == NULL) && (oc->link2->link3 == NULL) && (oc->link2->link4 == NULL) && (oc->link2->link5 == NULL) && (oc->link2->link6 == NULL) && (oc->link2->link7 == NULL)) {
						if ((oc->link3->link0 == NULL) && (oc->link3->link1 == NULL) && (oc->link3->link2 == NULL) && (oc->link3->link3 == NULL) && (oc->link3->link4 == NULL) && (oc->link3->link5 == NULL) && (oc->link3->link6 == NULL) && (oc->link3->link7 == NULL)) {
							b1 = true;
						}

					}
				}
				if (oc->link2 != NULL) {
					c2 = 1;
					integer ic0 = 0;
					if (oc->link2->link2 != NULL) {
						ic0++;
					}
					if (oc->link2->link3 != NULL) {
						ic0++;
					}
					if (oc->link2->link6 != NULL) {
						ic0++;
					}
					if (oc->link2->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c2 = 1;
					}
					else {
						c2 = ic0; // 4 или 2.
					}
				}
				if (oc->link3 != NULL) {
					c3 = 1;
					integer ic0 = 0;
					if (oc->link3->link2 != NULL) {
						ic0++;
					}
					if (oc->link3->link3 != NULL) {
						ic0++;
					}
					if (oc->link3->link6 != NULL) {
						ic0++;
					}
					if (oc->link3->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
					}
				}
				c6 = 0;
				c7 = 0;

				break;
			case NSIDE: // 0,1
				if ((oc->link0 != NULL) && (oc->link1 != NULL) && (oc->link4 != NULL) && (oc->link5 != NULL)) {
					if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
						if ((oc->link1->link0 == NULL) && (oc->link1->link1 == NULL) && (oc->link1->link2 == NULL) && (oc->link1->link3 == NULL) && (oc->link1->link4 == NULL) && (oc->link1->link5 == NULL) && (oc->link1->link6 == NULL) && (oc->link1->link7 == NULL)) {
							b1 = true;
						}
					}
				}
				if (oc->link0 != NULL) {
					c0 = 1;
					integer ic0 = 0;
					if (oc->link0->link0 != NULL) {
						ic0++;
					}
					if (oc->link0->link1 != NULL) {
						ic0++;
					}
					if (oc->link0->link4 != NULL) {
						ic0++;
					}
					if (oc->link0->link5 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
					}
				}
				if (oc->link1 != NULL) {
					c1 = 1;
					integer ic0 = 0;
					if (oc->link1->link0 != NULL) {
						ic0++;
					}
					if (oc->link1->link1 != NULL) {
						ic0++;
					}
					if (oc->link1->link4 != NULL) {
						ic0++;
					}
					if (oc->link1->link5 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
					}
				}
				c4 = 0;
				c5 = 0;

				break;
			default: printf("error : is_null3 if ((bSituationZ) && (!bSituationY) && (!bSituationX)) \n");
				//getchar();
				system("PAUSE");
				break;
			}
		}
	}

	if ((bSituationY) && (!bSituationZ) && (!bSituationX)) {
		// Вырождение по Y
		if (oc != NULL) {
			switch (dir) {
			case NSIDE: case SSIDE: // 0,1,4,5 
				if ((oc->link0 != NULL) && (oc->link1 != NULL) && (oc->link4 != NULL) && (oc->link5 != NULL)) {
					if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
						if ((oc->link1->link0 == NULL) && (oc->link1->link1 == NULL) && (oc->link1->link2 == NULL) && (oc->link1->link3 == NULL) && (oc->link1->link4 == NULL) && (oc->link1->link5 == NULL) && (oc->link1->link6 == NULL) && (oc->link1->link7 == NULL)) {
							if ((oc->link4->link0 == NULL) && (oc->link4->link1 == NULL) && (oc->link4->link2 == NULL) && (oc->link4->link3 == NULL) && (oc->link4->link4 == NULL) && (oc->link4->link5 == NULL) && (oc->link4->link6 == NULL) && (oc->link4->link7 == NULL)) {
								if ((oc->link5->link0 == NULL) && (oc->link5->link1 == NULL) && (oc->link5->link2 == NULL) && (oc->link5->link3 == NULL) && (oc->link5->link4 == NULL) && (oc->link5->link5 == NULL) && (oc->link5->link6 == NULL) && (oc->link5->link7 == NULL)) {
									b1 = true;
								}
							}
						}
					}
				}
				if (oc->link0 != NULL) {
					c0 = 1; c3 = 1;
					integer ic0 = 0;
					if (oc->link0->link0 != NULL) {
						ic0++;
					}
					if (oc->link0->link1 != NULL) {
						ic0++;
					}
					if (oc->link0->link4 != NULL) {
						ic0++;
					}
					if (oc->link0->link5 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
						c3 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
						c3 = ic0;
					}
				}
				if (oc->link1 != NULL) {
					c1 = 1; c2 = 1;
					integer ic0 = 0;
					if (oc->link1->link0 != NULL) {
						ic0++;
					}
					if (oc->link1->link1 != NULL) {
						ic0++;
					}
					if (oc->link1->link4 != NULL) {
						ic0++;
					}
					if (oc->link1->link5 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1;
						c2 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
						c2 = ic0;
					}
				}
				if (oc->link4 != NULL) {
					c4 = 1; c7 = 1;
					integer ic0 = 0;
					if (oc->link4->link0 != NULL) {
						ic0++;
					}
					if (oc->link4->link1 != NULL) {
						ic0++;
					}
					if (oc->link4->link4 != NULL) {
						ic0++;
					}
					if (oc->link4->link5 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1;
						c7 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
						c7 = ic0;
					}
				}
				if (oc->link5 != NULL) {
					c5 = 1;
					c6 = 1;
					integer ic0 = 0;
					if (oc->link5->link0 != NULL) {
						ic0++;
					}
					if (oc->link5->link1 != NULL) {
						ic0++;
					}
					if (oc->link5->link4 != NULL) {
						ic0++;
					}
					if (oc->link5->link5 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c5 = 1;
						c6 = 1;
					}
					else {
						c5 = ic0; // 4 или 2.
						c6 = ic0;
					}
				}
				break;
			case ESIDE: // 0,4
				if ((oc->link0 != NULL) && (oc->link3 != NULL) && (oc->link4 != NULL) && (oc->link7 != NULL)) {
					if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
						if ((oc->link4->link0 == NULL) && (oc->link4->link1 == NULL) && (oc->link4->link2 == NULL) && (oc->link4->link3 == NULL) && (oc->link4->link4 == NULL) && (oc->link4->link5 == NULL) && (oc->link4->link6 == NULL) && (oc->link4->link7 == NULL)) {
							b1 = true;
						}

					}
				}
				if (oc->link0 != NULL) {
					c0 = 1;
					integer ic0 = 0;
					if (oc->link0->link0 != NULL) {
						ic0++;
					}
					if (oc->link0->link3 != NULL) {
						ic0++;
					}
					if (oc->link0->link4 != NULL) {
						ic0++;
					}
					if (oc->link0->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
					}
				}

				if (oc->link4 != NULL) {
					c4 = 1;
					integer ic0 = 0;
					if (oc->link4->link0 != NULL) {
						ic0++;
					}
					if (oc->link4->link3 != NULL) {
						ic0++;
					}
					if (oc->link4->link4 != NULL) {
						ic0++;
					}
					if (oc->link4->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
					}
				}
				c7 = 0;
				c3 = 0;
				break;
			case WSIDE: // 1,2,5,6
				// 1,5
				if ((oc->link1 != NULL) && (oc->link2 != NULL) && (oc->link5 != NULL) && (oc->link6 != NULL)) {
					if ((oc->link1->link0 == NULL) && (oc->link1->link1 == NULL) && (oc->link1->link2 == NULL) && (oc->link1->link3 == NULL) && (oc->link1->link4 == NULL) && (oc->link1->link5 == NULL) && (oc->link1->link6 == NULL) && (oc->link1->link7 == NULL)) {
						if ((oc->link5->link0 == NULL) && (oc->link5->link1 == NULL) && (oc->link5->link2 == NULL) && (oc->link5->link3 == NULL) && (oc->link5->link4 == NULL) && (oc->link5->link5 == NULL) && (oc->link5->link6 == NULL) && (oc->link5->link7 == NULL)) {
							b1 = true;
						}

					}
				}
				if (oc->link1 != NULL) {
					c1 = 1;
					integer ic0 = 0;
					if (oc->link1->link1 != NULL) {
						ic0++;
					}
					if (oc->link1->link2 != NULL) {
						ic0++;
					}
					if (oc->link1->link5 != NULL) {
						ic0++;
					}
					if (oc->link1->link6 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
					}
				}
				c2 = 0;

				if (oc->link5 != NULL) {
					c5 = 1;
					integer ic0 = 0;
					if (oc->link5->link1 != NULL) {
						ic0++;
					}
					if (oc->link5->link2 != NULL) {
						ic0++;
					}
					if (oc->link5->link5 != NULL) {
						ic0++;
					}
					if (oc->link5->link6 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c5 = 1;
					}
					else {
						c5 = ic0; // 4 или 2.
					}
				}
				c6 = 0;

				break;
			case TSIDE: // 0,1,2,3
				// 0,1
				// Т.к. может быть вырождение по Z.
				if ((oc->link0 != NULL) && (oc->link1 != NULL) && (oc->link2 != NULL) && (oc->link3 != NULL)) {
					if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
						if ((oc->link1->link0 == NULL) && (oc->link1->link1 == NULL) && (oc->link1->link2 == NULL) && (oc->link1->link3 == NULL) && (oc->link1->link4 == NULL) && (oc->link1->link5 == NULL) && (oc->link1->link6 == NULL) && (oc->link1->link7 == NULL)) {
							b1 = true;
						}

					}
				}
				if (oc->link0 != NULL) {
					c0 = 1;
					integer ic0 = 0;
					if (oc->link0->link0 != NULL) {
						ic0++;
					}
					if (oc->link0->link1 != NULL) {
						ic0++;
					}
					if (oc->link0->link2 != NULL) {
						ic0++;
					}
					if (oc->link0->link3 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
					}
				}

				if (oc->link1 != NULL) {
					c1 = 1;
					integer ic0 = 0;
					if (oc->link1->link0 != NULL) {
						ic0++;
					}
					if (oc->link1->link1 != NULL) {
						ic0++;
					}
					if (oc->link1->link2 != NULL) {
						ic0++;
					}
					if (oc->link1->link3 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
					}
				}
				c2 = 0;
				c3 = 0;
				break;
			case BSIDE: // 4,5,6,7
				// 4,5
				// Т.к. может быть вырождение по Z.
				if ((oc->link4 != NULL) && (oc->link5 != NULL) && (oc->link6 != NULL) && (oc->link7 != NULL)) {
					if ((oc->link4->link0 == NULL) && (oc->link4->link1 == NULL) && (oc->link4->link2 == NULL) && (oc->link4->link3 == NULL) && (oc->link4->link4 == NULL) && (oc->link4->link5 == NULL) && (oc->link4->link6 == NULL) && (oc->link4->link7 == NULL)) {
						if ((oc->link5->link0 == NULL) && (oc->link5->link1 == NULL) && (oc->link5->link2 == NULL) && (oc->link5->link3 == NULL) && (oc->link5->link4 == NULL) && (oc->link5->link5 == NULL) && (oc->link5->link6 == NULL) && (oc->link5->link7 == NULL)) {
							b1 = true;
						}

					}
				}
				if (oc->link4 != NULL) {
					c4 = 1;
					integer ic0 = 0;
					if (oc->link4->link4 != NULL) {
						ic0++;
					}
					if (oc->link4->link5 != NULL) {
						ic0++;
					}
					if (oc->link4->link6 != NULL) {
						ic0++;
					}
					if (oc->link4->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
					}
				}

				if (oc->link5 != NULL) {
					c5 = 1;
					integer ic0 = 0;
					if (oc->link5->link4 != NULL) {
						ic0++;
					}
					if (oc->link5->link5 != NULL) {
						ic0++;
					}
					if (oc->link5->link6 != NULL) {
						ic0++;
					}
					if (oc->link5->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c5 = 1;
					}
					else {
						c5 = ic0; // 4 или 2.
					}
				}
				c6 = 0;
				c7 = 0;
				break;

			default: printf("error : is_null3 if ((bSituationY) && (!bSituationZ) && (!bSituationX))  \n");
				//getchar();
				system("PAUSE");
				break;
			}
		}
	}

	if ((bSituationX) && (!bSituationZ) && (!bSituationY)) {
		// Вырождение по X
		if (oc != NULL) {
			switch (dir) {
			case ESIDE: case WSIDE:// 0,3,4,7

				if (oc->link0 != NULL) {
					c0 = 1; c1 = 1;
					integer ic0 = 0;
					if (oc->link0->link0 != NULL) {
						ic0++;
					}
					if (oc->link0->link3 != NULL) {
						ic0++;
					}
					if (oc->link0->link4 != NULL) {
						ic0++;
					}
					if (oc->link0->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
						c1 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
						c1 = ic0;
					}
				}
				if (oc->link3 != NULL) {
					c3 = 1; c2 = 1;
					integer ic0 = 0;
					if (oc->link3->link0 != NULL) {
						ic0++;
					}
					if (oc->link3->link3 != NULL) {
						ic0++;
					}
					if (oc->link3->link4 != NULL) {
						ic0++;
					}
					if (oc->link3->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
						c2 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
						c2 = ic0;
					}
				}
				if (oc->link4 != NULL) {
					c4 = 1; c5 = 1;
					integer ic0 = 0;
					if (oc->link4->link0 != NULL) {
						ic0++;
					}
					if (oc->link4->link3 != NULL) {
						ic0++;
					}
					if (oc->link4->link4 != NULL) {
						ic0++;
					}
					if (oc->link4->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1;
						c5 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
						c5 = ic0;
					}
				}
				if (oc->link7 != NULL) {
					c7 = 1; c6 = 1;
					integer ic0 = 0;
					if (oc->link7->link0 != NULL) {
						ic0++;
					}
					if (oc->link7->link3 != NULL) {
						ic0++;
					}
					if (oc->link7->link4 != NULL) {
						ic0++;
					}
					if (oc->link7->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c7 = 1;
						c6 = 1;
					}
					else {
						c7 = ic0; // 4 или 2.
						c6 = ic0;
					}
				}
				break;
			case NSIDE: // 0,1,4,5 
				// 0,4
				if ((oc->link0 != NULL) && (oc->link1 != NULL) && (oc->link4 != NULL) && (oc->link5 != NULL)) {
					if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
						if ((oc->link4->link0 == NULL) && (oc->link4->link1 == NULL) && (oc->link4->link2 == NULL) && (oc->link4->link3 == NULL) && (oc->link4->link4 == NULL) && (oc->link4->link5 == NULL) && (oc->link4->link6 == NULL) && (oc->link4->link7 == NULL)) {
							b1 = true;
						}

					}
				}
				if (oc->link0 != NULL) {
					c0 = 1;
					integer ic0 = 0;
					if (oc->link0->link0 != NULL) {
						ic0++;
					}
					if (oc->link0->link1 != NULL) {
						ic0++;
					}
					if (oc->link0->link4 != NULL) {
						ic0++;
					}
					if (oc->link0->link5 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
					}
				}
				c1 = 0;

				if (oc->link4 != NULL) {
					c4 = 1;
					integer ic0 = 0;
					if (oc->link4->link0 != NULL) {
						ic0++;
					}
					if (oc->link4->link1 != NULL) {
						ic0++;
					}
					if (oc->link4->link4 != NULL) {
						ic0++;
					}
					if (oc->link4->link5 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
					}
				}
				c5 = 0;

				break;
			case SSIDE: // 3,7 
				if ((oc->link2 != NULL) && (oc->link3 != NULL) && (oc->link6 != NULL) && (oc->link7 != NULL)) {
					if ((oc->link3->link0 == NULL) && (oc->link3->link1 == NULL) && (oc->link3->link2 == NULL) && (oc->link3->link3 == NULL) && (oc->link3->link4 == NULL) && (oc->link3->link5 == NULL) && (oc->link3->link6 == NULL) && (oc->link3->link7 == NULL)) {
						if ((oc->link7->link0 == NULL) && (oc->link7->link1 == NULL) && (oc->link7->link2 == NULL) && (oc->link7->link3 == NULL) && (oc->link7->link4 == NULL) && (oc->link7->link5 == NULL) && (oc->link7->link6 == NULL) && (oc->link7->link7 == NULL)) {
							b1 = true;
						}

					}
				}
				c2 = 0;

				if (oc->link3 != NULL) {
					c3 = 1;
					integer ic0 = 0;
					if (oc->link3->link2 != NULL) {
						ic0++;
					}
					if (oc->link3->link3 != NULL) {
						ic0++;
					}
					if (oc->link3->link6 != NULL) {
						ic0++;
					}
					if (oc->link3->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
					}
				}
				c6 = 0;

				if (oc->link7 != NULL) {
					c7 = 1;
					integer ic0 = 0;
					if (oc->link7->link2 != NULL) {
						ic0++;
					}
					if (oc->link7->link3 != NULL) {
						ic0++;
					}
					if (oc->link7->link6 != NULL) {
						ic0++;
					}
					if (oc->link7->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c7 = 1;
					}
					else {
						c7 = ic0; // 4 или 2.
					}
				}


				break;
			case TSIDE: // 0,1,2,3
				// 0,3
				// Т.к. может быть вырождение по Z.
				if ((oc->link0 != NULL) && (oc->link1 != NULL) && (oc->link2 != NULL) && (oc->link3 != NULL)) {
					if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
						if ((oc->link3->link0 == NULL) && (oc->link3->link1 == NULL) && (oc->link3->link2 == NULL) && (oc->link3->link3 == NULL) && (oc->link3->link4 == NULL) && (oc->link3->link5 == NULL) && (oc->link3->link6 == NULL) && (oc->link3->link7 == NULL)) {
							b1 = true;
						}

					}
				}
				if (oc->link0 != NULL) {
					c0 = 1;
					integer ic0 = 0;
					if (oc->link0->link0 != NULL) {
						ic0++;
					}
					if (oc->link0->link1 != NULL) {
						ic0++;
					}
					if (oc->link0->link2 != NULL) {
						ic0++;
					}
					if (oc->link0->link3 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
					}
				}
				c1 = 0;
				c2 = 0;


				if (oc->link3 != NULL) {
					c3 = 1;
					integer ic0 = 0;
					if (oc->link3->link0 != NULL) {
						ic0++;
					}
					if (oc->link3->link1 != NULL) {
						ic0++;
					}
					if (oc->link3->link2 != NULL) {
						ic0++;
					}
					if (oc->link3->link3 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
					}
				}


				break;
			case BSIDE: // 4,5,6,7
				// 4,7
				// Т.к. может быть вырождение по Z.
				if ((oc->link4 != NULL) && (oc->link5 != NULL) && (oc->link6 != NULL) && (oc->link7 != NULL)) {
					if ((oc->link4->link0 == NULL) && (oc->link4->link1 == NULL) && (oc->link4->link2 == NULL) && (oc->link4->link3 == NULL) && (oc->link4->link4 == NULL) && (oc->link4->link5 == NULL) && (oc->link4->link6 == NULL) && (oc->link4->link7 == NULL)) {
						if ((oc->link7->link0 == NULL) && (oc->link7->link1 == NULL) && (oc->link7->link2 == NULL) && (oc->link7->link3 == NULL) && (oc->link7->link4 == NULL) && (oc->link7->link5 == NULL) && (oc->link7->link6 == NULL) && (oc->link7->link7 == NULL)) {
							b1 = true;
						}

					}
				}
				if (oc->link4 != NULL) {
					c4 = 1;
					integer ic0 = 0;
					if (oc->link4->link4 != NULL) {
						ic0++;
					}
					if (oc->link4->link5 != NULL) {
						ic0++;
					}
					if (oc->link4->link6 != NULL) {
						ic0++;
					}
					if (oc->link4->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
					}
				}
				c5 = 0;
				c6 = 0;


				if (oc->link7 != NULL) {
					c7 = 1;
					integer ic0 = 0;
					if (oc->link7->link4 != NULL) {
						ic0++;
					}
					if (oc->link7->link5 != NULL) {
						ic0++;
					}
					if (oc->link7->link6 != NULL) {
						ic0++;
					}
					if (oc->link7->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c7 = 1;
					}
					else {
						c7 = ic0; // 4 или 2.
					}
				}


				break;

			default: printf("error : is_null3  if ((bSituationX) && (!bSituationZ) && (!bSituationY)) \n");
				//getchar();
				system("PAUSE");
				break;
			}
		}
	}

	// остались direction вырождения ячейки.
	// Возможны только три случая.
	if ((bSituationZ) && (bSituationY) && (!bSituationX)) {
		// X direction.
		// полноценная ячейка.
		if (oc != NULL) {

			switch (dir) {
			case WSIDE: case ESIDE:
				c0 = c1 = 1;
				c2 = c3 = c4 = c5 = c6 = c7 = 0;
				break;
			case NSIDE: // 0,1,4,5 
				// 0,1
			case SSIDE: // 2,3,6,7
				//(0,3) (1,2) (4,7) (5,6)
				if ((oc->link0 != NULL) && (oc->link1 != NULL)) {
					if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
						if ((oc->link1->link0 == NULL) && (oc->link1->link1 == NULL) && (oc->link1->link2 == NULL) && (oc->link1->link3 == NULL) && (oc->link1->link4 == NULL) && (oc->link1->link5 == NULL) && (oc->link1->link6 == NULL) && (oc->link1->link7 == NULL)) {
							b1 = true;
						}
					}
				}
				if (oc->link0 != NULL) {
					c0 = 1; c3 = 1;
					integer ic0 = 0;
					if (oc->link0->link0 != NULL) {
						ic0++;
					}
					if (oc->link0->link1 != NULL) {
						ic0++;
					}
					if (oc->link0->link4 != NULL) {
						ic0++;
					}
					if (oc->link0->link5 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
						c3 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
						c3 = ic0;
					}
				}
				if (oc->link1 != NULL) {
					c1 = 1; c2 = 1;
					integer ic0 = 0;
					if (oc->link1->link0 != NULL) {
						ic0++;
					}
					if (oc->link1->link1 != NULL) {
						ic0++;
					}
					if (oc->link1->link4 != NULL) {
						ic0++;
					}
					if (oc->link1->link5 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1;
						c2 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
						c2 = ic0;
					}
				}
				c4 = c5 = c6 = c7 = 0;

				break;
			case TSIDE: // 0,1,2,3
				//0,1
			case BSIDE: // 4,5,6,7
				// 4,5
				// Т.к. может быть вырождение по Z.
				if ((oc->link0 != NULL) && (oc->link1 != NULL)) {
					if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
						if ((oc->link1->link0 == NULL) && (oc->link1->link1 == NULL) && (oc->link1->link2 == NULL) && (oc->link1->link3 == NULL) && (oc->link1->link4 == NULL) && (oc->link1->link5 == NULL) && (oc->link1->link6 == NULL) && (oc->link1->link7 == NULL)) {
							b1 = true;
						}
					}
				}
				if (oc->link0 != NULL) {
					c0 = 1; c4 = 1;
					integer ic0 = 0;
					if (oc->link0->link0 != NULL) {
						ic0++;
					}
					if (oc->link0->link1 != NULL) {
						ic0++;
					}
					if (oc->link0->link2 != NULL) {
						ic0++;
					}
					if (oc->link0->link3 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
						c4 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
						c4 = ic0;
					}
				}

				if (oc->link1 != NULL) {
					c1 = 1; c5 = 1;
					integer ic0 = 0;
					if (oc->link1->link0 != NULL) {
						ic0++;
					}
					if (oc->link1->link1 != NULL) {
						ic0++;
					}
					if (oc->link1->link2 != NULL) {
						ic0++;
					}
					if (oc->link1->link3 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1; c5 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
						c5 = ic0;
					}
				}
				c2 = c3 = c6 = c7 = 0;

				break;

			}
		}
	}
	if ((bSituationZ) && (!bSituationY) && (bSituationX)) {
		// Y direction.
		// полноценная ячейка.
		if (oc != NULL) {

			switch (dir) {
			case SSIDE: case NSIDE:
				c0 = c3 = 1;
				c2 = c1 = c4 = c5 = c6 = c7 = 0;
				break;
			case ESIDE: // 0,3,4,7
				// 0,3
			case WSIDE: // 1,2,5,6
				// (0,1) (3,2) (4,5) (7,6) 
				if ((oc->link0 != NULL) && (oc->link3 != NULL)) {
					if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
						if ((oc->link3->link0 == NULL) && (oc->link3->link1 == NULL) && (oc->link3->link2 == NULL) && (oc->link3->link3 == NULL) && (oc->link3->link4 == NULL) && (oc->link3->link5 == NULL) && (oc->link3->link6 == NULL) && (oc->link3->link7 == NULL)) {
							b1 = true;
						}
					}
				}
				if (oc->link0 != NULL) {
					c0 = 1;
					c1 = 1;
					integer ic0 = 0;
					if (oc->link0->link0 != NULL) {
						ic0++;
					}
					if (oc->link0->link3 != NULL) {
						ic0++;
					}
					if (oc->link0->link4 != NULL) {
						ic0++;
					}
					if (oc->link0->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
						c1 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
						c1 = ic0;
					}
				}
				if (oc->link3 != NULL) {
					c3 = 1;
					c2 = 1;
					integer ic0 = 0;
					if (oc->link3->link0 != NULL) {
						ic0++;
					}
					if (oc->link3->link3 != NULL) {
						ic0++;
					}
					if (oc->link3->link4 != NULL) {
						ic0++;
					}
					if (oc->link3->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
						c2 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
						c2 = ic0;
					}
				}
				c4 = c5 = c6 = c7 = 0;
				break;
			case TSIDE: // 0,1,2,3
				//0,3
			case BSIDE: // 4, 5, 6, 7
				//(0,4) (1,5) (2,6) (3,7)
				// Т.к. может быть вырождение по Z.
				if ((oc->link0 != NULL) && (oc->link3 != NULL)) {
					if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
						if ((oc->link3->link0 == NULL) && (oc->link3->link1 == NULL) && (oc->link3->link2 == NULL) && (oc->link3->link3 == NULL) && (oc->link3->link4 == NULL) && (oc->link3->link5 == NULL) && (oc->link3->link6 == NULL) && (oc->link3->link7 == NULL)) {
							b1 = true;
						}
					}
				}
				if (oc->link0 != NULL) {
					c0 = 1; c4 = 1;
					integer ic0 = 0;
					if (oc->link0->link0 != NULL) {
						ic0++;
					}
					if (oc->link0->link1 != NULL) {
						ic0++;
					}
					if (oc->link0->link2 != NULL) {
						ic0++;
					}
					if (oc->link0->link3 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
						c4 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
						c4 = ic0;
					}
				}
				c1 = c5 = c2 = c6 = 0;

				if (oc->link3 != NULL) {
					c3 = 1; c7 = 1;
					integer ic0 = 0;
					if (oc->link3->link0 != NULL) {
						ic0++;
					}
					if (oc->link3->link1 != NULL) {
						ic0++;
					}
					if (oc->link3->link2 != NULL) {
						ic0++;
					}
					if (oc->link3->link3 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
						c7 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
						c7 = ic0;
					}
				}


				break;
			}
		}
	}
	if ((!bSituationZ) && (bSituationY) && (bSituationX)) {
		// Z direction.
		// полноценная ячейка.
		if (oc != NULL) {

			switch (dir) {
			case TSIDE: case  BSIDE:
				c0 = c4 = 1;
				c1 = c2 = c3 = c5 = c6 = c7 = 0;
				break;
			case ESIDE: case WSIDE:// 0,3,4,7
				// 0, 4
				// W 1,2,5,6
				// 1,5
				if ((oc->link0 != NULL) && (oc->link3 != NULL) && (oc->link4 != NULL) && (oc->link7 != NULL)) {
					if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
						if ((oc->link4->link0 == NULL) && (oc->link4->link1 == NULL) && (oc->link4->link2 == NULL) && (oc->link4->link3 == NULL) && (oc->link4->link4 == NULL) && (oc->link4->link5 == NULL) && (oc->link4->link6 == NULL) && (oc->link4->link7 == NULL)) {
							b1 = true;
						}

					}
				}
				if (oc->link0 != NULL) {
					c0 = 1; c1 = 1;
					integer ic0 = 0;
					if (oc->link0->link0 != NULL) {
						ic0++;
					}
					if (oc->link0->link3 != NULL) {
						ic0++;
					}
					if (oc->link0->link4 != NULL) {
						ic0++;
					}
					if (oc->link0->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1; c1 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
						c1 = ic0;
					}
				}
				c3 = 0;
				c2 = 0;


				if (oc->link4 != NULL) {
					c4 = 1; c5 = 1;
					integer ic0 = 0;
					if (oc->link4->link0 != NULL) {
						ic0++;
					}
					if (oc->link4->link3 != NULL) {
						ic0++;
					}
					if (oc->link4->link4 != NULL) {
						ic0++;
					}
					if (oc->link4->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1; c5 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
						c5 = ic0;
					}
				}
				c7 = 0;
				c6 = 0;
				break;
			case NSIDE: // 0,1,4,5
				// 0, 4
			case SSIDE: // 2,3,6,7
				// (0,3) (1,2) (4,7) (5,6)
				if ((oc->link0 != NULL) && (oc->link4 != NULL)) {
					if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
						if ((oc->link4->link0 == NULL) && (oc->link4->link1 == NULL) && (oc->link4->link2 == NULL) && (oc->link4->link3 == NULL) && (oc->link4->link4 == NULL) && (oc->link4->link5 == NULL) && (oc->link4->link6 == NULL) && (oc->link4->link7 == NULL)) {
							b1 = true;
						}
					}
				}
				if (oc->link0 != NULL) {
					c0 = 1; c3 = 1;
					integer ic0 = 0;
					if (oc->link0->link0 != NULL) {
						ic0++;
					}
					if (oc->link0->link1 != NULL) {
						ic0++;
					}
					if (oc->link0->link4 != NULL) {
						ic0++;
					}
					if (oc->link0->link5 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
						c3 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
						c3 = ic0;
					}
				}
				c1 = 0;
				c2 = 0;
				if (oc->link4 != NULL) {
					c4 = 1; c7 = 1;
					integer ic0 = 0;
					if (oc->link4->link0 != NULL) {
						ic0++;
					}
					if (oc->link4->link1 != NULL) {
						ic0++;
					}
					if (oc->link4->link4 != NULL) {
						ic0++;
					}
					if (oc->link4->link5 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1;
						c7 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
						c7 = ic0;
					}
				}
				c5 = 0;
				c6 = 0;
				break;
			}
		}
	}

	if ((!bSituationZ) && (!bSituationY) && (!bSituationX)) {
		// полноценная ячейка.
		if (oc != NULL) {

			switch (dir) {
			case ESIDE: // 0,3,4,7
				if ((oc->link0 != NULL) && (oc->link3 != NULL) && (oc->link4 != NULL) && (oc->link7 != NULL)) {
					if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
						if ((oc->link3->link0 == NULL) && (oc->link3->link1 == NULL) && (oc->link3->link2 == NULL) && (oc->link3->link3 == NULL) && (oc->link3->link4 == NULL) && (oc->link3->link5 == NULL) && (oc->link3->link6 == NULL) && (oc->link3->link7 == NULL)) {
							if ((oc->link4->link0 == NULL) && (oc->link4->link1 == NULL) && (oc->link4->link2 == NULL) && (oc->link4->link3 == NULL) && (oc->link4->link4 == NULL) && (oc->link4->link5 == NULL) && (oc->link4->link6 == NULL) && (oc->link4->link7 == NULL)) {
								if ((oc->link7->link0 == NULL) && (oc->link7->link1 == NULL) && (oc->link7->link2 == NULL) && (oc->link7->link3 == NULL) && (oc->link7->link4 == NULL) && (oc->link7->link5 == NULL) && (oc->link7->link6 == NULL) && (oc->link7->link7 == NULL)) {
									b1 = true;
								}
							}
						}
					}
				}
				if (oc->link0 != NULL) {
					c0 = 1;
					integer ic0 = 0;
					if (oc->link0->link0 != NULL) {
						ic0++;
					}
					if (oc->link0->link3 != NULL) {
						ic0++;
					}
					if (oc->link0->link4 != NULL) {
						ic0++;
					}
					if (oc->link0->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
					}
				}
				if (oc->link3 != NULL) {
					c3 = 1;
					integer ic0 = 0;
					if (oc->link3->link0 != NULL) {
						ic0++;
					}
					if (oc->link3->link3 != NULL) {
						ic0++;
					}
					if (oc->link3->link4 != NULL) {
						ic0++;
					}
					if (oc->link3->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
					}
				}
				if (oc->link4 != NULL) {
					c4 = 1;
					integer ic0 = 0;
					if (oc->link4->link0 != NULL) {
						ic0++;
					}
					if (oc->link4->link3 != NULL) {
						ic0++;
					}
					if (oc->link4->link4 != NULL) {
						ic0++;
					}
					if (oc->link4->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
					}
				}
				if (oc->link7 != NULL) {
					c7 = 1;
					integer ic0 = 0;
					if (oc->link7->link0 != NULL) {
						ic0++;
					}
					if (oc->link7->link3 != NULL) {
						ic0++;
					}
					if (oc->link7->link4 != NULL) {
						ic0++;
					}
					if (oc->link7->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c7 = 1;
					}
					else {
						c7 = ic0; // 4 или 2.
					}
				}
				break;
			case WSIDE: // 1,2,5,6
				if ((oc->link1 != NULL) && (oc->link2 != NULL) && (oc->link5 != NULL) && (oc->link6 != NULL)) {
					if ((oc->link1->link0 == NULL) && (oc->link1->link1 == NULL) && (oc->link1->link2 == NULL) && (oc->link1->link3 == NULL) && (oc->link1->link4 == NULL) && (oc->link1->link5 == NULL) && (oc->link1->link6 == NULL) && (oc->link1->link7 == NULL)) {
						if ((oc->link2->link0 == NULL) && (oc->link2->link1 == NULL) && (oc->link2->link2 == NULL) && (oc->link2->link3 == NULL) && (oc->link2->link4 == NULL) && (oc->link2->link5 == NULL) && (oc->link2->link6 == NULL) && (oc->link2->link7 == NULL)) {
							if ((oc->link5->link0 == NULL) && (oc->link5->link1 == NULL) && (oc->link5->link2 == NULL) && (oc->link5->link3 == NULL) && (oc->link5->link4 == NULL) && (oc->link5->link5 == NULL) && (oc->link5->link6 == NULL) && (oc->link5->link7 == NULL)) {
								if ((oc->link6->link0 == NULL) && (oc->link6->link1 == NULL) && (oc->link6->link2 == NULL) && (oc->link6->link3 == NULL) && (oc->link6->link4 == NULL) && (oc->link6->link5 == NULL) && (oc->link6->link6 == NULL) && (oc->link6->link7 == NULL)) {
									b1 = true;
								}
							}
						}
					}
				}
				if (oc->link1 != NULL) {
					c1 = 1;
					integer ic0 = 0;
					if (oc->link1->link1 != NULL) {
						ic0++;
					}
					if (oc->link1->link2 != NULL) {
						ic0++;
					}
					if (oc->link1->link5 != NULL) {
						ic0++;
					}
					if (oc->link1->link6 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
					}
				}
				if (oc->link2 != NULL) {
					c2 = 1;
					integer ic0 = 0;
					if (oc->link2->link1 != NULL) {
						ic0++;
					}
					if (oc->link2->link2 != NULL) {
						ic0++;
					}
					if (oc->link2->link5 != NULL) {
						ic0++;
					}
					if (oc->link2->link6 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c2 = 1;
					}
					else {
						c2 = ic0; // 4 или 2.
					}
				}
				if (oc->link5 != NULL) {
					c5 = 1;
					integer ic0 = 0;
					if (oc->link5->link1 != NULL) {
						ic0++;
					}
					if (oc->link5->link2 != NULL) {
						ic0++;
					}
					if (oc->link5->link5 != NULL) {
						ic0++;
					}
					if (oc->link5->link6 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c5 = 1;
					}
					else {
						c5 = ic0; // 4 или 2.
					}
				}
				if (oc->link6 != NULL) {
					c6 = 1;
					integer ic0 = 0;
					if (oc->link6->link1 != NULL) {
						ic0++;
					}
					if (oc->link6->link2 != NULL) {
						ic0++;
					}
					if (oc->link6->link5 != NULL) {
						ic0++;
					}
					if (oc->link6->link6 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c6 = 1;
					}
					else {
						c6 = ic0; // 4 или 2.
					}
				}
				break;
			case NSIDE: // 0,1,4,5 
				if ((oc->link0 != NULL) && (oc->link1 != NULL) && (oc->link4 != NULL) && (oc->link5 != NULL)) {
					if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
						if ((oc->link1->link0 == NULL) && (oc->link1->link1 == NULL) && (oc->link1->link2 == NULL) && (oc->link1->link3 == NULL) && (oc->link1->link4 == NULL) && (oc->link1->link5 == NULL) && (oc->link1->link6 == NULL) && (oc->link1->link7 == NULL)) {
							if ((oc->link4->link0 == NULL) && (oc->link4->link1 == NULL) && (oc->link4->link2 == NULL) && (oc->link4->link3 == NULL) && (oc->link4->link4 == NULL) && (oc->link4->link5 == NULL) && (oc->link4->link6 == NULL) && (oc->link4->link7 == NULL)) {
								if ((oc->link5->link0 == NULL) && (oc->link5->link1 == NULL) && (oc->link5->link2 == NULL) && (oc->link5->link3 == NULL) && (oc->link5->link4 == NULL) && (oc->link5->link5 == NULL) && (oc->link5->link6 == NULL) && (oc->link5->link7 == NULL)) {
									b1 = true;
								}
							}
						}
					}
				}
				if (oc->link0 != NULL) {
					c0 = 1;
					integer ic0 = 0;
					if (oc->link0->link0 != NULL) {
						ic0++;
					}
					if (oc->link0->link1 != NULL) {
						ic0++;
					}
					if (oc->link0->link4 != NULL) {
						ic0++;
					}
					if (oc->link0->link5 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
					}
				}
				if (oc->link1 != NULL) {
					c1 = 1;
					integer ic0 = 0;
					if (oc->link1->link0 != NULL) {
						ic0++;
					}
					if (oc->link1->link1 != NULL) {
						ic0++;
					}
					if (oc->link1->link4 != NULL) {
						ic0++;
					}
					if (oc->link1->link5 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
					}
				}
				if (oc->link4 != NULL) {
					c4 = 1;
					integer ic0 = 0;
					if (oc->link4->link0 != NULL) {
						ic0++;
					}
					if (oc->link4->link1 != NULL) {
						ic0++;
					}
					if (oc->link4->link4 != NULL) {
						ic0++;
					}
					if (oc->link4->link5 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
					}
				}
				if (oc->link5 != NULL) {
					c5 = 1;
					integer ic0 = 0;
					if (oc->link5->link0 != NULL) {
						ic0++;
					}
					if (oc->link5->link1 != NULL) {
						ic0++;
					}
					if (oc->link5->link4 != NULL) {
						ic0++;
					}
					if (oc->link5->link5 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c5 = 1;
					}
					else {
						c5 = ic0; // 4 или 2.
					}
				}


				break;
			case SSIDE: // 2,3,6,7 
				if ((oc->link2 != NULL) && (oc->link3 != NULL) && (oc->link6 != NULL) && (oc->link7 != NULL)) {
					if ((oc->link2->link0 == NULL) && (oc->link2->link1 == NULL) && (oc->link2->link2 == NULL) && (oc->link2->link3 == NULL) && (oc->link2->link4 == NULL) && (oc->link2->link5 == NULL) && (oc->link2->link6 == NULL) && (oc->link2->link7 == NULL)) {
						if ((oc->link3->link0 == NULL) && (oc->link3->link1 == NULL) && (oc->link3->link2 == NULL) && (oc->link3->link3 == NULL) && (oc->link3->link4 == NULL) && (oc->link3->link5 == NULL) && (oc->link3->link6 == NULL) && (oc->link3->link7 == NULL)) {
							if ((oc->link6->link0 == NULL) && (oc->link6->link1 == NULL) && (oc->link6->link2 == NULL) && (oc->link6->link3 == NULL) && (oc->link6->link4 == NULL) && (oc->link6->link5 == NULL) && (oc->link6->link6 == NULL) && (oc->link6->link7 == NULL)) {
								if ((oc->link7->link0 == NULL) && (oc->link7->link1 == NULL) && (oc->link7->link2 == NULL) && (oc->link7->link3 == NULL) && (oc->link7->link4 == NULL) && (oc->link7->link5 == NULL) && (oc->link7->link6 == NULL) && (oc->link7->link7 == NULL)) {
									b1 = true;
								}
							}
						}
					}
				}
				if (oc->link2 != NULL) {
					c2 = 1;
					integer ic0 = 0;
					if (oc->link2->link2 != NULL) {
						ic0++;
					}
					if (oc->link2->link3 != NULL) {
						ic0++;
					}
					if (oc->link2->link6 != NULL) {
						ic0++;
					}
					if (oc->link2->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c2 = 1;
					}
					else {
						c2 = ic0; // 4 или 2.
					}
				}
				if (oc->link3 != NULL) {
					c3 = 1;
					integer ic0 = 0;
					if (oc->link3->link2 != NULL) {
						ic0++;
					}
					if (oc->link3->link3 != NULL) {
						ic0++;
					}
					if (oc->link3->link6 != NULL) {
						ic0++;
					}
					if (oc->link3->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
					}
				}
				if (oc->link6 != NULL) {
					c6 = 1;
					integer ic0 = 0;
					if (oc->link6->link2 != NULL) {
						ic0++;
					}
					if (oc->link6->link3 != NULL) {
						ic0++;
					}
					if (oc->link6->link6 != NULL) {
						ic0++;
					}
					if (oc->link6->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c6 = 1;
					}
					else {
						c6 = ic0; // 4 или 2.
					}
				}
				if (oc->link7 != NULL) {
					c7 = 1;
					integer ic0 = 0;
					if (oc->link7->link2 != NULL) {
						ic0++;
					}
					if (oc->link7->link3 != NULL) {
						ic0++;
					}
					if (oc->link7->link6 != NULL) {
						ic0++;
					}
					if (oc->link7->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c7 = 1;
					}
					else {
						c7 = ic0; // 4 или 2.
					}
				}


				break;
			case TSIDE: // 0,1,2,3
				// Т.к. может быть вырождение по Z.
				if ((oc->link0 != NULL) && (oc->link1 != NULL) && (oc->link2 != NULL) && (oc->link3 != NULL)) {
					if ((oc->link0->link0 == NULL) && (oc->link0->link1 == NULL) && (oc->link0->link2 == NULL) && (oc->link0->link3 == NULL) && (oc->link0->link4 == NULL) && (oc->link0->link5 == NULL) && (oc->link0->link6 == NULL) && (oc->link0->link7 == NULL)) {
						if ((oc->link1->link0 == NULL) && (oc->link1->link1 == NULL) && (oc->link1->link2 == NULL) && (oc->link1->link3 == NULL) && (oc->link1->link4 == NULL) && (oc->link1->link5 == NULL) && (oc->link1->link6 == NULL) && (oc->link1->link7 == NULL)) {
							if ((oc->link2->link0 == NULL) && (oc->link2->link1 == NULL) && (oc->link2->link2 == NULL) && (oc->link2->link3 == NULL) && (oc->link2->link4 == NULL) && (oc->link2->link5 == NULL) && (oc->link2->link6 == NULL) && (oc->link2->link7 == NULL)) {
								if ((oc->link3->link0 == NULL) && (oc->link3->link1 == NULL) && (oc->link3->link2 == NULL) && (oc->link3->link3 == NULL) && (oc->link3->link4 == NULL) && (oc->link3->link5 == NULL) && (oc->link3->link6 == NULL) && (oc->link3->link7 == NULL)) {
									b1 = true;
								}
							}
						}
					}
				}
				if (oc->link0 != NULL) {
					c0 = 1;
					integer ic0 = 0;
					if (oc->link0->link0 != NULL) {
						ic0++;
					}
					if (oc->link0->link1 != NULL) {
						ic0++;
					}
					if (oc->link0->link2 != NULL) {
						ic0++;
					}
					if (oc->link0->link3 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
					}
				}

				if (oc->link1 != NULL) {
					c1 = 1;
					integer ic0 = 0;
					if (oc->link1->link0 != NULL) {
						ic0++;
					}
					if (oc->link1->link1 != NULL) {
						ic0++;
					}
					if (oc->link1->link2 != NULL) {
						ic0++;
					}
					if (oc->link1->link3 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
					}
				}
				if (oc->link2 != NULL) {
					c2 = 1;
					integer ic0 = 0;
					if (oc->link2->link0 != NULL) {
						ic0++;
					}
					if (oc->link2->link1 != NULL) {
						ic0++;
					}
					if (oc->link2->link2 != NULL) {
						ic0++;
					}
					if (oc->link2->link3 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c2 = 1;
					}
					else {
						c2 = ic0; // 4 или 2.
					}
				}
				if (oc->link3 != NULL) {
					c3 = 1;
					integer ic0 = 0;
					if (oc->link3->link0 != NULL) {
						ic0++;
					}
					if (oc->link3->link1 != NULL) {
						ic0++;
					}
					if (oc->link3->link2 != NULL) {
						ic0++;
					}
					if (oc->link3->link3 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
					}
				}


				break;
			case BSIDE: // 4,5,6,7
				// Т.к. может быть вырождение по Z.
				if ((oc->link4 != NULL) && (oc->link5 != NULL) && (oc->link6 != NULL) && (oc->link7 != NULL)) {
					if ((oc->link4->link0 == NULL) && (oc->link4->link1 == NULL) && (oc->link4->link2 == NULL) && (oc->link4->link3 == NULL) && (oc->link4->link4 == NULL) && (oc->link4->link5 == NULL) && (oc->link4->link6 == NULL) && (oc->link4->link7 == NULL)) {
						if ((oc->link5->link0 == NULL) && (oc->link5->link1 == NULL) && (oc->link5->link2 == NULL) && (oc->link5->link3 == NULL) && (oc->link5->link4 == NULL) && (oc->link5->link5 == NULL) && (oc->link5->link6 == NULL) && (oc->link5->link7 == NULL)) {
							if ((oc->link6->link0 == NULL) && (oc->link6->link1 == NULL) && (oc->link6->link2 == NULL) && (oc->link6->link3 == NULL) && (oc->link6->link4 == NULL) && (oc->link6->link5 == NULL) && (oc->link6->link6 == NULL) && (oc->link6->link7 == NULL)) {
								if ((oc->link7->link0 == NULL) && (oc->link7->link1 == NULL) && (oc->link7->link2 == NULL) && (oc->link7->link3 == NULL) && (oc->link7->link4 == NULL) && (oc->link7->link5 == NULL) && (oc->link7->link6 == NULL) && (oc->link7->link7 == NULL)) {
									b1 = true;
								}
							}
						}
					}
				}
				if (oc->link4 != NULL) {
					c4 = 1;
					integer ic0 = 0;
					if (oc->link4->link4 != NULL) {
						ic0++;
					}
					if (oc->link4->link5 != NULL) {
						ic0++;
					}
					if (oc->link4->link6 != NULL) {
						ic0++;
					}
					if (oc->link4->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
					}
				}

				if (oc->link5 != NULL) {
					c5 = 1;
					integer ic0 = 0;
					if (oc->link5->link4 != NULL) {
						ic0++;
					}
					if (oc->link5->link5 != NULL) {
						ic0++;
					}
					if (oc->link5->link6 != NULL) {
						ic0++;
					}
					if (oc->link5->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c5 = 1;
					}
					else {
						c5 = ic0; // 4 или 2.
					}
				}
				if (oc->link6 != NULL) {
					c6 = 1;
					integer ic0 = 0;
					if (oc->link6->link4 != NULL) {
						ic0++;
					}
					if (oc->link6->link5 != NULL) {
						ic0++;
					}
					if (oc->link6->link6 != NULL) {
						ic0++;
					}
					if (oc->link6->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c6 = 1;
					}
					else {
						c6 = ic0; // 4 или 2.
					}
				}
				if (oc->link7 != NULL) {
					c7 = 1;
					integer ic0 = 0;
					if (oc->link7->link4 != NULL) {
						ic0++;
					}
					if (oc->link7->link5 != NULL) {
						ic0++;
					}
					if (oc->link7->link6 != NULL) {
						ic0++;
					}
					if (oc->link7->link7 != NULL) {
						ic0++;
					}
					if (ic0 == 0) {
						c7 = 1;
					}
					else {
						c7 = ic0; // 4 или 2.
					}
				}


				break;
			default:
				printf("ERROR!!! is_null1 error in direct\n");
				//getchar();
				system("PAUSE");
				exit(1);
				break;
			}

		}
	}
	return b1;
} // is_null3



void patch_sosed_count(integer &isosed, octTree* &oc_info, integer iside_info) {

	switch (isosed) {
	case 0: printf("error!!! patch_sosed_count increment  isosed=0\n");
#if doubleintprecision == 1
		printf("root=%lld\n", oc_info->root);
		if (oc_info->parent != NULL) {
			printf("parent->root=%lld\n", oc_info->parent->root);
			if (oc_info->parent->parent != NULL) {
				printf("parent->parent->root=%lld\n", oc_info->parent->parent->root);
			}
	}
#else
		printf("root=%d\n", oc_info->root);
		if (oc_info->parent != NULL) {
			printf("parent->root=%d\n", oc_info->parent->root);
			if (oc_info->parent->parent != NULL) {
				printf("parent->parent->root=%d\n", oc_info->parent->parent->root);
			}
		}
#endif
		
		switch (iside_info) {
		case ESIDE: printf("ESIDE\n"); break;
		case WSIDE: printf("W\n"); break;
		case NSIDE: printf("NSIDE\n"); break;
		case SSIDE: printf("SSIDE\n"); break;
		case TSIDE: printf("TSIDE\n"); break;
		case BSIDE: printf("B\n"); break;
		}
		//getchar();
		system("PAUSE");
		exit(1);
		//isosed = 4;
		break;
	case 1: isosed = 4;
		break;
	case 4: isosed = 7;
		break;
	case 7: isosed = 10;
		break;
	case 10: isosed = 13; break;
	case 13: isosed = 16; break;
	default: // Это признак того что ячейка должна дробиться очень сильно.
		isosed += 4 - 1;
		break;
	}
} // patch_sosed_count

void patch_sosed_count2(integer &isosed) {
	// При вырождениии в направлении одной из осей.
	switch (isosed) {
	case 0: printf("error!!! patch_sosed_count2 increment  isosed=0\n");
		//getchar();
		system("PAUSE");
		exit(1);
		//isosed = 2;
		break;
	case 1: isosed = 2;
		break;
	case 2: isosed = 3;
		break;
	case 3: isosed = 4;
		break;
	case 4: isosed = 5; break;
	case 5: isosed = 6; break;
	default: // Это признак того что ячейка должна дробиться очень сильно.
		isosed += 2 - 1;
		break;
	}
} // patch_sosed_count




// Алгоритм дробления листа на 8 частей с учётом вырождений.
void droblenie_internal(octTree* &oc, integer minx, integer maxx, integer miny, integer maxy, integer minz, integer maxz, doublereal* xpos, doublereal* ypos, doublereal* zpos, integer &ret, bool dodroblenie,
	bool bdrobimX, bool bdrobimY, bool bdrobimZ) {

	if (maxx <= minx) {
		printf("maxx <= minx in droblenie_internal\n");
		//getchar();
		system("PAUSE");
		exit(1);
	}
	if (maxy <= miny) {
		printf("maxy <= miny in droblenie_internal\n");
		//getchar();
		system("PAUSE");
		exit(1);
	}
	if (maxz <= minz) {
		printf("maxz <= minz in droblenie_internal\n");
		//getchar();
		system("PAUSE");
		exit(1);
	}

	bool bold_stable_version = true;

	bool b0 = true;
	bool b1 = true;
	bool b2 = true;
	bool b3 = true;
	bool b4 = true;
	bool b5 = true;
	bool b6 = true;
	bool b7 = true;
	ret = 0;

	// Вырождение по Z.
	bool bSituationZ = false;
	// Вырождение по X.
	bool bSituationX = false;
	// Вырождение по Y.
	bool bSituationY = false;

	
	
	integer avgx = (integer)(0.5*(minx + maxx));
	integer avgy = (integer)(0.5*(miny + maxy));
	integer avgz = (integer)(0.5*(minz + maxz));
	
    if (1) {
		// 2 september 2017.

		doublereal xc28 = 0.5*(xpos[minx]+xpos[maxx]);
		integer isearch = -1;
		doublereal dmax28 = 1.0e40;
		// поиск наимее удалённого от геометрического центра индекса.
		for (integer i28 = minx; i28 <= maxx; i28++) {
			if (fabs(xpos[i28] - xc28) < dmax28) {
				isearch = i28;
				dmax28 = fabs(xpos[i28] - xc28);
			}
		}
		avgx = isearch;

		xc28 = 0.5*(ypos[miny] + ypos[maxy]);
		isearch = -1;
		dmax28 = 1.0e40;
		// поиск наимее удалённого от геометрического центра индекса.
		for (integer i28 = miny; i28 <= maxy; i28++) {
			if (fabs(ypos[i28] - xc28) < dmax28) {
				isearch = i28;
				dmax28 = fabs(ypos[i28] - xc28);
			}
		}
		avgy = isearch;

		xc28 = 0.5*(zpos[minz] + zpos[maxz]);
		isearch = -1;
		dmax28 = 1.0e40;
		// поиск наимее удалённого от геометрического центра индекса.
		for (integer i28 = minz; i28 <= maxz; i28++) {
			if (fabs(zpos[i28] - xc28) < dmax28) {
				isearch = i28;
				dmax28 = fabs(zpos[i28] - xc28);
			}
		}
		avgz = isearch;
	}

	if (minz + 1 == maxz) {
		avgz = maxz;
		b4 = false;
		b5 = false;
		b6 = false;
		b7 = false;
		// Вырождение по Z.
		bSituationZ = true;
	}
	if (minx + 1 == maxx) {
		avgx = maxx;
		b1 = false;
		b2 = false;
		b5 = false;
		b6 = false;
		// Вырождение по X.
		bSituationX = true;
	}
	if (miny + 1 == maxy) {
		avgy = maxy;
		b2 = false;
		b3 = false;
		b6 = false;
		b7 = false;
		// Вырождение по Y.
		bSituationY = true;
	}

	// Вырождение по Z.
	bool bSituationZ_prefix = bSituationZ;
	// Вырождение по X.
	bool bSituationX_prefix = bSituationX;
	// Вырождение по Y.
	bool bSituationY_prefix = bSituationY;

	if (!bold_stable_version) {
		if (!bdrobimX) {
			avgx = maxx;
			b1 = false;
			b2 = false;
			b5 = false;
			b6 = false;
			// Вырождение по X.
			bSituationX = true;
		}

		if (!bdrobimY) {
			avgy = maxy;
			b2 = false;
			b3 = false;
			b6 = false;
			b7 = false;
			// Вырождение по Y.
			bSituationY = true;
		}

		if (!bdrobimZ) {
			avgz = maxz;
			b4 = false;
			b5 = false;
			b6 = false;
			b7 = false;
			// Вырождение по Z.
			bSituationZ = true;
		}
	}

	bool bold_stable_version1 = bold_stable_version;

	if (!b1&&!b2&&!b3&&!b4&&!b5&&!b6&&!b7) {
		//iret++;
		//printf("error list droblenie internal. ");
		if (DEBUG_ALICE_MESH) {
			printf("list ostaetsq listom.\n");
		}
		oc->dlist = true;
		//getchar();
	}
	else {

		bool bonly_dir_X = false;
		bool bonly_dir_Y = false;
		bool bonly_dir_Z = false;

		// дробление на iret частей.
		if (b1&&b2&&b3&&b4&&b5&&b6&&b7) {
			ret = 8;
		}
		else {
			if (bSituationX && (!bSituationY) && (!bSituationZ)) ret = 4;
			if (bSituationY && (!bSituationX) && (!bSituationZ)) ret = 4;
			if (bSituationZ && (!bSituationY) && (!bSituationX)) ret = 4;
			if (bSituationX && (bSituationY) && (!bSituationZ)) {
				ret = 2;
				bonly_dir_Z = true;
			}
			if (bSituationX && (bSituationZ) && (!bSituationY)) {
				ret = 2;
				bonly_dir_Y = true;
			}
			if (bSituationY && (bSituationZ) && (!bSituationX)) {
				ret = 2;
				bonly_dir_X = true;
			}
		}

		if (b0&&!b1&&!b2&&!b3&&!b4&&!b5&&!b6&&!b7) {
			printf("ERROR ZACHEM DELITX!!!\n");
			//getchar();
			system("PAUSE");
		}

		// дробление
		integer minx0 = minx;
		integer maxx0 = avgx;
		integer miny0 = miny;
		integer maxy0 = avgy;
		integer minz0 = minz;
		integer maxz0 = avgz;
		doublereal rminx0 = xpos[minx];
		doublereal rmaxx0 = xpos[avgx];
		doublereal rminy0 = ypos[miny];
		doublereal rmaxy0 = ypos[avgy];
		doublereal rminz0 = zpos[minz];
		doublereal rmaxz0 = zpos[avgz];
		if (b0) {
			//droblenie(xpos, ypos, zpos,
			//	inx, iny, inz, oc->link0,
			//	minx0, maxx0, miny0, maxy0, minz0, maxz0, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx0;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx0;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny0;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy0;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz0;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz0;


			oc->link0 = new octTree;
			oc->link0->inum_TD = 0; // Не принадлежит расчётной области.
			oc->link0->inum_FD = 0;// Не принадлежит расчётной области.
			if (oc->link0 == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for oc->link0 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			oc->link0->parent = oc;
			oc->link0->ilevel = oc->ilevel + 1;
			if (bold_stable_version1) {
				oc->link0->brootSituationX = bSituationX;
				oc->link0->brootSituationY = bSituationY;
				oc->link0->brootSituationZ = bSituationZ;

				oc->link0->brootSituationX_virtual = bSituationX;
				oc->link0->brootSituationY_virtual = bSituationY;
				oc->link0->brootSituationZ_virtual = bSituationZ;
			}
			else {
				oc->link0->brootSituationX = bSituationX;
				oc->link0->brootSituationY = bSituationY;
				oc->link0->brootSituationZ = bSituationZ;

				oc->link0->brootSituationX_virtual = bSituationX_prefix;
				oc->link0->brootSituationY_virtual = bSituationY_prefix;
				oc->link0->brootSituationZ_virtual = bSituationZ_prefix;
			}
			oc->link0->root = 0;
			oc->link0->minx = minx0;
			oc->link0->maxx = maxx0;
			oc->link0->miny = miny0;
			oc->link0->maxy = maxy0;
			oc->link0->minz = minz0;
			oc->link0->maxz = maxz0;

			oc->link0->p0.x = rminx0;
			oc->link0->p0.y = rminy0;
			oc->link0->p0.z = rminz0;
			oc->link0->p1.x = rmaxx0;
			oc->link0->p1.y = rminy0;
			oc->link0->p1.z = rminz0;
			oc->link0->p2.x = rmaxx0;
			oc->link0->p2.y = rmaxy0;
			oc->link0->p2.z = rminz0;
			oc->link0->p3.x = rminx0;
			oc->link0->p3.y = rmaxy0;
			oc->link0->p3.z = rminz0;

			oc->link0->p4.x = rminx0;
			oc->link0->p4.y = rminy0;
			oc->link0->p4.z = rmaxz0;
			oc->link0->p5.x = rmaxx0;
			oc->link0->p5.y = rminy0;
			oc->link0->p5.z = rmaxz0;
			oc->link0->p6.x = rmaxx0;
			oc->link0->p6.y = rmaxy0;
			oc->link0->p6.z = rmaxz0;
			oc->link0->p7.x = rminx0;
			oc->link0->p7.y = rmaxy0;
			oc->link0->p7.z = rmaxz0;
			oc->link0->link0 = NULL;
			oc->link0->link1 = NULL;
			oc->link0->link2 = NULL;
			oc->link0->link3 = NULL;
			oc->link0->link4 = NULL;
			oc->link0->link5 = NULL;
			oc->link0->link6 = NULL;
			oc->link0->link7 = NULL;
			// пока соседей просто нету.
			oc->link0->linkW = NULL;
			oc->link0->linkE = NULL;
			oc->link0->linkS = NULL;
			oc->link0->linkN = NULL;
			oc->link0->linkB = NULL;
			oc->link0->linkT = NULL;
			oc->link0->b4W = false;
			oc->link0->b4E = false;
			oc->link0->b4S = false;
			oc->link0->b4N = false;
			oc->link0->b4B = false;
			oc->link0->b4T = false;
			oc->link0->linkW0 = NULL;
			oc->link0->linkW3 = NULL;
			oc->link0->linkW4 = NULL;
			oc->link0->linkW7 = NULL;
			oc->link0->linkE1 = NULL;
			oc->link0->linkE2 = NULL;
			oc->link0->linkE5 = NULL;
			oc->link0->linkE6 = NULL;
			oc->link0->linkS0 = NULL;
			oc->link0->linkS1 = NULL;
			oc->link0->linkS4 = NULL;
			oc->link0->linkS5 = NULL;
			oc->link0->linkN2 = NULL;
			oc->link0->linkN3 = NULL;
			oc->link0->linkN6 = NULL;
			oc->link0->linkN7 = NULL;
			oc->link0->linkB0 = NULL;
			oc->link0->linkB1 = NULL;
			oc->link0->linkB2 = NULL;
			oc->link0->linkB3 = NULL;
			oc->link0->linkT4 = NULL;
			oc->link0->linkT5 = NULL;
			oc->link0->linkT6 = NULL;
			oc->link0->linkT7 = NULL;
			oc->dlist = false;
			oc->link0->dlist = true;
			oc->link0->b_the_geometric_fragmentation = true;
			if (dodroblenie) {
				oc->link0->bcrushing_when_balancing = true;
			}
			else {
				oc->link0->bcrushing_when_balancing = false;
			}


			oc->link0->maxBsosed = 10000000;
			oc->link0->maxTsosed = 10000000;
			oc->link0->maxSsosed = 10000000;
			oc->link0->maxNsosed = 10000000;
			oc->link0->maxWsosed = 10000000;
			oc->link0->maxEsosed = 10000000;




			my_ALICE_STACK[top_ALICE_STACK].link = oc->link0;
			top_ALICE_STACK++;
		}
		else {
			oc->link0 = NULL;
		}
		integer minx1 = avgx;
		integer maxx1 = maxx;
		integer miny1 = miny;
		integer maxy1 = avgy;
		integer minz1 = minz;
		integer maxz1 = avgz;
		doublereal rminx1 = xpos[avgx];
		doublereal rmaxx1 = xpos[maxx];
		doublereal rminy1 = ypos[miny];
		doublereal rmaxy1 = ypos[avgy];
		doublereal rminz1 = zpos[minz];
		doublereal rmaxz1 = zpos[avgz];
		if (b1) {
			//droblenie(xpos, ypos, zpos,
			//	inx, iny, inz, oc->link1,
			//	minx1, maxx1, miny1, maxy1, minz1, maxz1, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx1;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx1;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny1;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy1;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz1;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz1;

			oc->link1 = new octTree;
			oc->link1->inum_TD = 0; // Не принадлежит расчётной области.
			oc->link1->inum_FD = 0;// Не принадлежит расчётной области.
			if (oc->link1 == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for oc->link1 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			oc->link1->parent = oc;
			oc->link1->ilevel = oc->ilevel + 1;
			
			if (bold_stable_version1) {
				oc->link1->brootSituationX = bSituationX;
				oc->link1->brootSituationY = bSituationY;
				oc->link1->brootSituationZ = bSituationZ;

				oc->link1->brootSituationX_virtual = bSituationX;
				oc->link1->brootSituationY_virtual = bSituationY;
				oc->link1->brootSituationZ_virtual = bSituationZ;
			}
			else {
				oc->link1->brootSituationX = bSituationX;
				oc->link1->brootSituationY = bSituationY;
				oc->link1->brootSituationZ = bSituationZ;

				oc->link1->brootSituationX_virtual = bSituationX_prefix;
				oc->link1->brootSituationY_virtual = bSituationY_prefix;
				oc->link1->brootSituationZ_virtual = bSituationZ_prefix;
			}

			oc->link1->root = 1;
			oc->link1->minx = minx1;
			oc->link1->maxx = maxx1;
			oc->link1->miny = miny1;
			oc->link1->maxy = maxy1;
			oc->link1->minz = minz1;
			oc->link1->maxz = maxz1;
			oc->link1->p0.x = rminx1;
			oc->link1->p0.y = rminy1;
			oc->link1->p0.z = rminz1;
			oc->link1->p1.x = rmaxx1;
			oc->link1->p1.y = rminy1;
			oc->link1->p1.z = rminz1;
			oc->link1->p2.x = rmaxx1;
			oc->link1->p2.y = rmaxy1;
			oc->link1->p2.z = rminz1;
			oc->link1->p3.x = rminx1;
			oc->link1->p3.y = rmaxy1;
			oc->link1->p3.z = rminz1;
			oc->link1->p4.x = rminx1;
			oc->link1->p4.y = rminy1;
			oc->link1->p4.z = rmaxz1;
			oc->link1->p5.x = rmaxx1;
			oc->link1->p5.y = rminy1;
			oc->link1->p5.z = rmaxz1;
			oc->link1->p6.x = rmaxx1;
			oc->link1->p6.y = rmaxy1;
			oc->link1->p6.z = rmaxz1;
			oc->link1->p7.x = rminx1;
			oc->link1->p7.y = rmaxy1;
			oc->link1->p7.z = rmaxz1;
			oc->link1->link0 = NULL;
			oc->link1->link1 = NULL;
			oc->link1->link2 = NULL;
			oc->link1->link3 = NULL;
			oc->link1->link4 = NULL;
			oc->link1->link5 = NULL;
			oc->link1->link6 = NULL;
			oc->link1->link7 = NULL;
			// пока соседей просто нету.
			oc->link1->linkW = NULL;
			oc->link1->linkE = NULL;
			oc->link1->linkS = NULL;
			oc->link1->linkN = NULL;
			oc->link1->linkB = NULL;
			oc->link1->linkT = NULL;
			oc->link1->b4W = false;
			oc->link1->b4E = false;
			oc->link1->b4S = false;
			oc->link1->b4N = false;
			oc->link1->b4B = false;
			oc->link1->b4T = false;
			oc->link1->linkW0 = NULL;
			oc->link1->linkW3 = NULL;
			oc->link1->linkW4 = NULL;
			oc->link1->linkW7 = NULL;
			oc->link1->linkE1 = NULL;
			oc->link1->linkE2 = NULL;
			oc->link1->linkE5 = NULL;
			oc->link1->linkE6 = NULL;
			oc->link1->linkS0 = NULL;
			oc->link1->linkS1 = NULL;
			oc->link1->linkS4 = NULL;
			oc->link1->linkS5 = NULL;
			oc->link1->linkN2 = NULL;
			oc->link1->linkN3 = NULL;
			oc->link1->linkN6 = NULL;
			oc->link1->linkN7 = NULL;
			oc->link1->linkB0 = NULL;
			oc->link1->linkB1 = NULL;
			oc->link1->linkB2 = NULL;
			oc->link1->linkB3 = NULL;
			oc->link1->linkT4 = NULL;
			oc->link1->linkT5 = NULL;
			oc->link1->linkT6 = NULL;
			oc->link1->linkT7 = NULL;
			oc->link1->dlist = true;
			oc->link1->b_the_geometric_fragmentation = true;
			if (dodroblenie) {
				oc->link1->bcrushing_when_balancing = true;
			}
			else {
				oc->link1->bcrushing_when_balancing = false;
			}
			oc->link1->maxBsosed = 10000000;
			oc->link1->maxTsosed = 10000000;
			oc->link1->maxSsosed = 10000000;
			oc->link1->maxNsosed = 10000000;
			oc->link1->maxWsosed = 10000000;
			oc->link1->maxEsosed = 10000000;



			my_ALICE_STACK[top_ALICE_STACK].link = oc->link1;
			top_ALICE_STACK++;
		}
		else {
			oc->link1 = NULL;
		}
		integer minx2 = avgx;
		integer maxx2 = maxx;
		integer miny2 = avgy;
		integer maxy2 = maxy;
		integer minz2 = minz;
		integer maxz2 = avgz;
		doublereal rminx2 = xpos[avgx];
		doublereal rmaxx2 = xpos[maxx];
		doublereal rminy2 = ypos[avgy];
		doublereal rmaxy2 = ypos[maxy];
		doublereal rminz2 = zpos[minz];
		doublereal rmaxz2 = zpos[avgz];
		if (b2) {
			//droblenie(xpos, ypos, zpos,
			//inx, iny, inz, oc->link2,
			//minx2, maxx2, miny2, maxy2, minz2, maxz2, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx2;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx2;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny2;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy2;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz2;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz2;

			oc->link2 = new octTree;
			oc->link2->inum_TD = 0; // Не принадлежит расчётной области.
			oc->link2->inum_FD = 0;// Не принадлежит расчётной области.
			if (oc->link2 == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for oc->link2 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			oc->link2->parent = oc;
			oc->link2->ilevel = oc->ilevel + 1;

			if (bold_stable_version1) {
				oc->link2->brootSituationX = bSituationX;
				oc->link2->brootSituationY = bSituationY;
				oc->link2->brootSituationZ = bSituationZ;

				oc->link2->brootSituationX_virtual = bSituationX;
				oc->link2->brootSituationY_virtual = bSituationY;
				oc->link2->brootSituationZ_virtual = bSituationZ;
			}
			else {

				oc->link2->brootSituationX = bSituationX;
				oc->link2->brootSituationY = bSituationY;
				oc->link2->brootSituationZ = bSituationZ;

				oc->link2->brootSituationX_virtual = bSituationX_prefix;
				oc->link2->brootSituationY_virtual = bSituationY_prefix;
				oc->link2->brootSituationZ_virtual = bSituationZ_prefix;
			}

			oc->link2->root = 2;
			oc->link2->minx = minx2;
			oc->link2->maxx = maxx2;
			oc->link2->miny = miny2;
			oc->link2->maxy = maxy2;
			oc->link2->minz = minz2;
			oc->link2->maxz = maxz2;
			oc->link2->p0.x = rminx2;
			oc->link2->p0.y = rminy2;
			oc->link2->p0.z = rminz2;
			oc->link2->p1.x = rmaxx2;
			oc->link2->p1.y = rminy2;
			oc->link2->p1.z = rminz2;
			oc->link2->p2.x = rmaxx2;
			oc->link2->p2.y = rmaxy2;
			oc->link2->p2.z = rminz2;
			oc->link2->p3.x = rminx2;
			oc->link2->p3.y = rmaxy2;
			oc->link2->p3.z = rminz2;
			oc->link2->p4.x = rminx2;
			oc->link2->p4.y = rminy2;
			oc->link2->p4.z = rmaxz2;
			oc->link2->p5.x = rmaxx2;
			oc->link2->p5.y = rminy2;
			oc->link2->p5.z = rmaxz2;
			oc->link2->p6.x = rmaxx2;
			oc->link2->p6.y = rmaxy2;
			oc->link2->p6.z = rmaxz2;
			oc->link2->p7.x = rminx2;
			oc->link2->p7.y = rmaxy2;
			oc->link2->p7.z = rmaxz2;
			oc->link2->link0 = NULL;
			oc->link2->link1 = NULL;
			oc->link2->link2 = NULL;
			oc->link2->link3 = NULL;
			oc->link2->link4 = NULL;
			oc->link2->link5 = NULL;
			oc->link2->link6 = NULL;
			oc->link2->link7 = NULL;
			// пока соседей просто нету.
			oc->link2->linkW = NULL;
			oc->link2->linkE = NULL;
			oc->link2->linkS = NULL;
			oc->link2->linkN = NULL;
			oc->link2->linkB = NULL;
			oc->link2->linkT = NULL;
			oc->link2->b4W = false;
			oc->link2->b4E = false;
			oc->link2->b4S = false;
			oc->link2->b4N = false;
			oc->link2->b4B = false;
			oc->link2->b4T = false;
			oc->link2->linkW0 = NULL;
			oc->link2->linkW3 = NULL;
			oc->link2->linkW4 = NULL;
			oc->link2->linkW7 = NULL;
			oc->link2->linkE1 = NULL;
			oc->link2->linkE2 = NULL;
			oc->link2->linkE5 = NULL;
			oc->link2->linkE6 = NULL;
			oc->link2->linkS0 = NULL;
			oc->link2->linkS1 = NULL;
			oc->link2->linkS4 = NULL;
			oc->link2->linkS5 = NULL;
			oc->link2->linkN2 = NULL;
			oc->link2->linkN3 = NULL;
			oc->link2->linkN6 = NULL;
			oc->link2->linkN7 = NULL;
			oc->link2->linkB0 = NULL;
			oc->link2->linkB1 = NULL;
			oc->link2->linkB2 = NULL;
			oc->link2->linkB3 = NULL;
			oc->link2->linkT4 = NULL;
			oc->link2->linkT5 = NULL;
			oc->link2->linkT6 = NULL;
			oc->link2->linkT7 = NULL;
			oc->link2->dlist = true;
			oc->link2->b_the_geometric_fragmentation = true;
			if (dodroblenie) {
				oc->link2->bcrushing_when_balancing = true;
			}
			else {
				oc->link2->bcrushing_when_balancing = false;
			}
			oc->link2->maxBsosed = 10000000;
			oc->link2->maxTsosed = 10000000;
			oc->link2->maxSsosed = 10000000;
			oc->link2->maxNsosed = 10000000;
			oc->link2->maxWsosed = 10000000;
			oc->link2->maxEsosed = 10000000;


			my_ALICE_STACK[top_ALICE_STACK].link = oc->link2;
			top_ALICE_STACK++;
		}
		else {
			oc->link2 = NULL;
		}
		integer minx3 = minx;
		integer maxx3 = avgx;
		integer miny3 = avgy;
		integer maxy3 = maxy;
		integer minz3 = minz;
		integer maxz3 = avgz;
		doublereal rminx3 = xpos[minx];
		doublereal rmaxx3 = xpos[avgx];
		doublereal rminy3 = ypos[avgy];
		doublereal rmaxy3 = ypos[maxy];
		doublereal rminz3 = zpos[minz];
		doublereal rmaxz3 = zpos[avgz];

		if (b3) {
			//droblenie(xpos, ypos, zpos,
			//	inx, iny, inz, oc->link3,
			//	minx3, maxx3, miny3, maxy3, minz3, maxz3, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx3;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx3;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny3;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy3;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz3;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz3;

			oc->link3 = new octTree;
			oc->link3->inum_TD = 0; // Не принадлежит расчётной области.
			oc->link3->inum_FD = 0;// Не принадлежит расчётной области.
			if (oc->link3 == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for oc->link3 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			oc->link3->parent = oc;
			oc->link3->ilevel = oc->ilevel + 1;

			if (bold_stable_version1) {
				oc->link3->brootSituationX = bSituationX;
				oc->link3->brootSituationY = bSituationY;
				oc->link3->brootSituationZ = bSituationZ;

				oc->link3->brootSituationX_virtual = bSituationX;
				oc->link3->brootSituationY_virtual = bSituationY;
				oc->link3->brootSituationZ_virtual = bSituationZ;

			}
			else {

				oc->link3->brootSituationX = bSituationX;
				oc->link3->brootSituationY = bSituationY;
				oc->link3->brootSituationZ = bSituationZ;

				oc->link3->brootSituationX_virtual = bSituationX_prefix;
				oc->link3->brootSituationY_virtual = bSituationY_prefix;
				oc->link3->brootSituationZ_virtual = bSituationZ_prefix;
			}

			oc->link3->root = 3;
			oc->link3->minx = minx3;
			oc->link3->maxx = maxx3;
			oc->link3->miny = miny3;
			oc->link3->maxy = maxy3;
			oc->link3->minz = minz3;
			oc->link3->maxz = maxz3;
			oc->link3->p0.x = rminx3;
			oc->link3->p0.y = rminy3;
			oc->link3->p0.z = rminz3;
			oc->link3->p1.x = rmaxx3;
			oc->link3->p1.y = rminy3;
			oc->link3->p1.z = rminz3;
			oc->link3->p2.x = rmaxx3;
			oc->link3->p2.y = rmaxy3;
			oc->link3->p2.z = rminz3;
			oc->link3->p3.x = rminx3;
			oc->link3->p3.y = rmaxy3;
			oc->link3->p3.z = rminz3;
			oc->link3->p4.x = rminx3;
			oc->link3->p4.y = rminy3;
			oc->link3->p4.z = rmaxz3;
			oc->link3->p5.x = rmaxx3;
			oc->link3->p5.y = rminy3;
			oc->link3->p5.z = rmaxz3;
			oc->link3->p6.x = rmaxx3;
			oc->link3->p6.y = rmaxy3;
			oc->link3->p6.z = rmaxz3;
			oc->link3->p7.x = rminx3;
			oc->link3->p7.y = rmaxy3;
			oc->link3->p7.z = rmaxz3;
			oc->link3->link0 = NULL;
			oc->link3->link1 = NULL;
			oc->link3->link2 = NULL;
			oc->link3->link3 = NULL;
			oc->link3->link4 = NULL;
			oc->link3->link5 = NULL;
			oc->link3->link6 = NULL;
			oc->link3->link7 = NULL;
			// пока соседей просто нету.
			oc->link3->linkW = NULL;
			oc->link3->linkE = NULL;
			oc->link3->linkS = NULL;
			oc->link3->linkN = NULL;
			oc->link3->linkB = NULL;
			oc->link3->linkT = NULL;
			oc->link3->b4W = false;
			oc->link3->b4E = false;
			oc->link3->b4S = false;
			oc->link3->b4N = false;
			oc->link3->b4B = false;
			oc->link3->b4T = false;
			oc->link3->linkW0 = NULL;
			oc->link3->linkW3 = NULL;
			oc->link3->linkW4 = NULL;
			oc->link3->linkW7 = NULL;
			oc->link3->linkE1 = NULL;
			oc->link3->linkE2 = NULL;
			oc->link3->linkE5 = NULL;
			oc->link3->linkE6 = NULL;
			oc->link3->linkS0 = NULL;
			oc->link3->linkS1 = NULL;
			oc->link3->linkS4 = NULL;
			oc->link3->linkS5 = NULL;
			oc->link3->linkN2 = NULL;
			oc->link3->linkN3 = NULL;
			oc->link3->linkN6 = NULL;
			oc->link3->linkN7 = NULL;
			oc->link3->linkB0 = NULL;
			oc->link3->linkB1 = NULL;
			oc->link3->linkB2 = NULL;
			oc->link3->linkB3 = NULL;
			oc->link3->linkT4 = NULL;
			oc->link3->linkT5 = NULL;
			oc->link3->linkT6 = NULL;
			oc->link3->linkT7 = NULL;
			oc->link3->dlist = true;
			oc->link3->b_the_geometric_fragmentation = true;
			if (dodroblenie) {
				oc->link3->bcrushing_when_balancing = true;
			}
			else {
				oc->link3->bcrushing_when_balancing = false;
			}
			oc->link3->maxBsosed = 10000000;
			oc->link3->maxTsosed = 10000000;
			oc->link3->maxSsosed = 10000000;
			oc->link3->maxNsosed = 10000000;
			oc->link3->maxWsosed = 10000000;
			oc->link3->maxEsosed = 10000000;


			my_ALICE_STACK[top_ALICE_STACK].link = oc->link3;
			top_ALICE_STACK++;
		}
		else {
			oc->link3 = NULL;
		}

		integer minx4 = minx;
		integer maxx4 = avgx;
		integer miny4 = miny;
		integer maxy4 = avgy;
		integer minz4 = avgz;
		integer maxz4 = maxz;
		doublereal rminx4 = xpos[minx];
		doublereal rmaxx4 = xpos[avgx];
		doublereal rminy4 = ypos[miny];
		doublereal rmaxy4 = ypos[avgy];
		doublereal rminz4 = zpos[avgz];
		doublereal rmaxz4 = zpos[maxz];
		if (b4) {
			//droblenie(xpos, ypos, zpos,
			//	inx, iny, inz, oc->link4,
			//	minx4, maxx4, miny4, maxy4, minz4, maxz4, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx4;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx4;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny4;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy4;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz4;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz4;

			oc->link4 = new octTree;
			oc->link4->inum_TD = 0; // Не принадлежит расчётной области.
			oc->link4->inum_FD = 0;// Не принадлежит расчётной области.
			if (oc->link4 == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for oc->link4 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			oc->link4->parent = oc;
			oc->link4->ilevel = oc->ilevel + 1;

			if (bold_stable_version1) {
				oc->link4->brootSituationX = bSituationX;
				oc->link4->brootSituationY = bSituationY;
				oc->link4->brootSituationZ = bSituationZ;

				oc->link4->brootSituationX_virtual = bSituationX;
				oc->link4->brootSituationY_virtual = bSituationY;
				oc->link4->brootSituationZ_virtual = bSituationZ;

			}
			else {

				oc->link4->brootSituationX = bSituationX;
				oc->link4->brootSituationY = bSituationY;
				oc->link4->brootSituationZ = bSituationZ;

				oc->link4->brootSituationX_virtual = bSituationX_prefix;
				oc->link4->brootSituationY_virtual = bSituationY_prefix;
				oc->link4->brootSituationZ_virtual = bSituationZ_prefix;
			}

			oc->link4->root = 4;
			oc->link4->minx = minx4;
			oc->link4->maxx = maxx4;
			oc->link4->miny = miny4;
			oc->link4->maxy = maxy4;
			oc->link4->minz = minz4;
			oc->link4->maxz = maxz4;
			oc->link4->p0.x = rminx4;
			oc->link4->p0.y = rminy4;
			oc->link4->p0.z = rminz4;
			oc->link4->p1.x = rmaxx4;
			oc->link4->p1.y = rminy4;
			oc->link4->p1.z = rminz4;
			oc->link4->p2.x = rmaxx4;
			oc->link4->p2.y = rmaxy4;
			oc->link4->p2.z = rminz4;
			oc->link4->p3.x = rminx4;
			oc->link4->p3.y = rmaxy4;
			oc->link4->p3.z = rminz4;
			oc->link4->p4.x = rminx4;
			oc->link4->p4.y = rminy4;
			oc->link4->p4.z = rmaxz4;
			oc->link4->p5.x = rmaxx4;
			oc->link4->p5.y = rminy4;
			oc->link4->p5.z = rmaxz4;
			oc->link4->p6.x = rmaxx4;
			oc->link4->p6.y = rmaxy4;
			oc->link4->p6.z = rmaxz4;
			oc->link4->p7.x = rminx4;
			oc->link4->p7.y = rmaxy4;
			oc->link4->p7.z = rmaxz4;
			oc->link4->link0 = NULL;
			oc->link4->link1 = NULL;
			oc->link4->link2 = NULL;
			oc->link4->link3 = NULL;
			oc->link4->link4 = NULL;
			oc->link4->link5 = NULL;
			oc->link4->link6 = NULL;
			oc->link4->link7 = NULL;
			// пока соседей просто нету.
			oc->link4->linkW = NULL;
			oc->link4->linkE = NULL;
			oc->link4->linkS = NULL;
			oc->link4->linkN = NULL;
			oc->link4->linkB = NULL;
			oc->link4->linkT = NULL;
			oc->link4->b4W = false;
			oc->link4->b4E = false;
			oc->link4->b4S = false;
			oc->link4->b4N = false;
			oc->link4->b4B = false;
			oc->link4->b4T = false;
			oc->link4->linkW0 = NULL;
			oc->link4->linkW3 = NULL;
			oc->link4->linkW4 = NULL;
			oc->link4->linkW7 = NULL;
			oc->link4->linkE1 = NULL;
			oc->link4->linkE2 = NULL;
			oc->link4->linkE5 = NULL;
			oc->link4->linkE6 = NULL;
			oc->link4->linkS0 = NULL;
			oc->link4->linkS1 = NULL;
			oc->link4->linkS4 = NULL;
			oc->link4->linkS5 = NULL;
			oc->link4->linkN2 = NULL;
			oc->link4->linkN3 = NULL;
			oc->link4->linkN6 = NULL;
			oc->link4->linkN7 = NULL;
			oc->link4->linkB0 = NULL;
			oc->link4->linkB1 = NULL;
			oc->link4->linkB2 = NULL;
			oc->link4->linkB3 = NULL;
			oc->link4->linkT4 = NULL;
			oc->link4->linkT5 = NULL;
			oc->link4->linkT6 = NULL;
			oc->link4->linkT7 = NULL;
			oc->link4->dlist = true;
			oc->link4->b_the_geometric_fragmentation = true;
			if (dodroblenie) {
				oc->link4->bcrushing_when_balancing = true;
			}
			else {
				oc->link4->bcrushing_when_balancing = false;
			}
			oc->link4->maxBsosed = 10000000;
			oc->link4->maxTsosed = 10000000;
			oc->link4->maxSsosed = 10000000;
			oc->link4->maxNsosed = 10000000;
			oc->link4->maxWsosed = 10000000;
			oc->link4->maxEsosed = 10000000;
			oc->link4->maxBsosed = 1;


			my_ALICE_STACK[top_ALICE_STACK].link = oc->link4;
			top_ALICE_STACK++;
		}
		else {
			oc->link4 = NULL;
		}
		integer minx5 = avgx;
		integer maxx5 = maxx;
		integer miny5 = miny;
		integer maxy5 = avgy;
		integer minz5 = avgz;
		integer maxz5 = maxz;
		doublereal rminx5 = xpos[avgx];
		doublereal rmaxx5 = xpos[maxx];
		doublereal rminy5 = ypos[miny];
		doublereal rmaxy5 = ypos[avgy];
		doublereal rminz5 = zpos[avgz];
		doublereal rmaxz5 = zpos[maxz];
		if (b5) {
			//droblenie(xpos, ypos, zpos,
			//inx, iny, inz, oc->link5,
			//minx5, maxx5, miny5, maxy5, minz5, maxz5, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx5;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx5;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny5;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy5;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz5;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz5;

			oc->link5 = new octTree;
			oc->link5->inum_TD = 0; // Не принадлежит расчётной области.
			oc->link5->inum_FD = 0;// Не принадлежит расчётной области.
			if (oc->link5 == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for oc->link5 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			oc->link5->parent = oc;
			oc->link5->ilevel = oc->ilevel + 1;
			
			if (bold_stable_version1) {
				oc->link5->brootSituationX = bSituationX;
				oc->link5->brootSituationY = bSituationY;
				oc->link5->brootSituationZ = bSituationZ;

				oc->link5->brootSituationX_virtual = bSituationX;
				oc->link5->brootSituationY_virtual = bSituationY;
				oc->link5->brootSituationZ_virtual = bSituationZ;

			}
			else {

				oc->link5->brootSituationX = bSituationX;
				oc->link5->brootSituationY = bSituationY;
				oc->link5->brootSituationZ = bSituationZ;

				oc->link5->brootSituationX_virtual = bSituationX_prefix;
				oc->link5->brootSituationY_virtual = bSituationY_prefix;
				oc->link5->brootSituationZ_virtual = bSituationZ_prefix;
			}

			oc->link5->root = 5;
			oc->link5->minx = minx5;
			oc->link5->maxx = maxx5;
			oc->link5->miny = miny5;
			oc->link5->maxy = maxy5;
			oc->link5->minz = minz5;
			oc->link5->maxz = maxz5;
			oc->link5->p0.x = rminx5;
			oc->link5->p0.y = rminy5;
			oc->link5->p0.z = rminz5;
			oc->link5->p1.x = rmaxx5;
			oc->link5->p1.y = rminy5;
			oc->link5->p1.z = rminz5;
			oc->link5->p2.x = rmaxx5;
			oc->link5->p2.y = rmaxy5;
			oc->link5->p2.z = rminz5;
			oc->link5->p3.x = rminx5;
			oc->link5->p3.y = rmaxy5;
			oc->link5->p3.z = rminz5;
			oc->link5->p4.x = rminx5;
			oc->link5->p4.y = rminy5;
			oc->link5->p4.z = rmaxz5;
			oc->link5->p5.x = rmaxx5;
			oc->link5->p5.y = rminy5;
			oc->link5->p5.z = rmaxz5;
			oc->link5->p6.x = rmaxx5;
			oc->link5->p6.y = rmaxy5;
			oc->link5->p6.z = rmaxz5;
			oc->link5->p7.x = rminx5;
			oc->link5->p7.y = rmaxy5;
			oc->link5->p7.z = rmaxz5;
			oc->link5->link0 = NULL;
			oc->link5->link1 = NULL;
			oc->link5->link2 = NULL;
			oc->link5->link3 = NULL;
			oc->link5->link4 = NULL;
			oc->link5->link5 = NULL;
			oc->link5->link6 = NULL;
			oc->link5->link7 = NULL;
			// пока соседей просто нету.
			oc->link5->linkW = NULL;
			oc->link5->linkE = NULL;
			oc->link5->linkS = NULL;
			oc->link5->linkN = NULL;
			oc->link5->linkB = NULL;
			oc->link5->linkT = NULL;
			oc->link5->b4W = false;
			oc->link5->b4E = false;
			oc->link5->b4S = false;
			oc->link5->b4N = false;
			oc->link5->b4B = false;
			oc->link5->b4T = false;
			oc->link5->linkW0 = NULL;
			oc->link5->linkW3 = NULL;
			oc->link5->linkW4 = NULL;
			oc->link5->linkW7 = NULL;
			oc->link5->linkE1 = NULL;
			oc->link5->linkE2 = NULL;
			oc->link5->linkE5 = NULL;
			oc->link5->linkE6 = NULL;
			oc->link5->linkS0 = NULL;
			oc->link5->linkS1 = NULL;
			oc->link5->linkS4 = NULL;
			oc->link5->linkS5 = NULL;
			oc->link5->linkN2 = NULL;
			oc->link5->linkN3 = NULL;
			oc->link5->linkN6 = NULL;
			oc->link5->linkN7 = NULL;
			oc->link5->linkB0 = NULL;
			oc->link5->linkB1 = NULL;
			oc->link5->linkB2 = NULL;
			oc->link5->linkB3 = NULL;
			oc->link5->linkT4 = NULL;
			oc->link5->linkT5 = NULL;
			oc->link5->linkT6 = NULL;
			oc->link5->linkT7 = NULL;
			oc->link5->dlist = true;
			oc->link5->b_the_geometric_fragmentation = true;
			if (dodroblenie) {
				oc->link5->bcrushing_when_balancing = true;
			}
			else {
				oc->link5->bcrushing_when_balancing = false;
			}
			oc->link5->maxBsosed = 10000000;
			oc->link5->maxTsosed = 10000000;
			oc->link5->maxSsosed = 10000000;
			oc->link5->maxNsosed = 10000000;
			oc->link5->maxWsosed = 10000000;
			oc->link5->maxEsosed = 10000000;

			my_ALICE_STACK[top_ALICE_STACK].link = oc->link5;
			top_ALICE_STACK++;
		}
		else {
			oc->link5 = NULL;
		}
		integer minx6 = avgx;
		integer maxx6 = maxx;
		integer miny6 = avgy;
		integer maxy6 = maxy;
		integer minz6 = avgz;
		integer maxz6 = maxz;
		doublereal rminx6 = xpos[avgx];
		doublereal rmaxx6 = xpos[maxx];
		doublereal rminy6 = ypos[avgy];
		doublereal rmaxy6 = ypos[maxy];
		doublereal rminz6 = zpos[avgz];
		doublereal rmaxz6 = zpos[maxz];
		if (b6) {
			//droblenie(xpos, ypos, zpos,
			//inx, iny, inz, oc->link6,
			//minx6, maxx6, miny6, maxy6, minz6, maxz6, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx6;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx6;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny6;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy6;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz6;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz6;

			oc->link6 = new octTree;
			oc->link6->inum_TD = 0; // Не принадлежит расчётной области.
			oc->link6->inum_FD = 0;// Не принадлежит расчётной области.
			if (oc->link6 == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for oc->link6 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			oc->link6->parent = oc;
			oc->link6->ilevel = oc->ilevel + 1;

			if (bold_stable_version1) {
				oc->link6->brootSituationX = bSituationX;
				oc->link6->brootSituationY = bSituationY;
				oc->link6->brootSituationZ = bSituationZ;

				oc->link6->brootSituationX_virtual = bSituationX;
				oc->link6->brootSituationY_virtual = bSituationY;
				oc->link6->brootSituationZ_virtual = bSituationZ;
			}
			else {

				oc->link6->brootSituationX = bSituationX;
				oc->link6->brootSituationY = bSituationY;
				oc->link6->brootSituationZ = bSituationZ;

				oc->link6->brootSituationX_virtual = bSituationX_prefix;
				oc->link6->brootSituationY_virtual = bSituationY_prefix;
				oc->link6->brootSituationZ_virtual = bSituationZ_prefix;
			}

			oc->link6->root = 6;
			oc->link6->minx = minx6;
			oc->link6->maxx = maxx6;
			oc->link6->miny = miny6;
			oc->link6->maxy = maxy6;
			oc->link6->minz = minz6;
			oc->link6->maxz = maxz6;
			oc->link6->p0.x = rminx6;
			oc->link6->p0.y = rminy6;
			oc->link6->p0.z = rminz6;
			oc->link6->p1.x = rmaxx6;
			oc->link6->p1.y = rminy6;
			oc->link6->p1.z = rminz6;
			oc->link6->p2.x = rmaxx6;
			oc->link6->p2.y = rmaxy6;
			oc->link6->p2.z = rminz6;
			oc->link6->p3.x = rminx6;
			oc->link6->p3.y = rmaxy6;
			oc->link6->p3.z = rminz6;
			oc->link6->p4.x = rminx6;
			oc->link6->p4.y = rminy6;
			oc->link6->p4.z = rmaxz6;
			oc->link6->p5.x = rmaxx6;
			oc->link6->p5.y = rminy6;
			oc->link6->p5.z = rmaxz6;
			oc->link6->p6.x = rmaxx6;
			oc->link6->p6.y = rmaxy6;
			oc->link6->p6.z = rmaxz6;
			oc->link6->p7.x = rminx6;
			oc->link6->p7.y = rmaxy6;
			oc->link6->p7.z = rmaxz6;
			oc->link6->link0 = NULL;
			oc->link6->link1 = NULL;
			oc->link6->link2 = NULL;
			oc->link6->link3 = NULL;
			oc->link6->link4 = NULL;
			oc->link6->link5 = NULL;
			oc->link6->link6 = NULL;
			oc->link6->link7 = NULL;
			// пока соседей просто нету.
			oc->link6->linkW = NULL;
			oc->link6->linkE = NULL;
			oc->link6->linkS = NULL;
			oc->link6->linkN = NULL;
			oc->link6->linkB = NULL;
			oc->link6->linkT = NULL;
			oc->link6->b4W = false;
			oc->link6->b4E = false;
			oc->link6->b4S = false;
			oc->link6->b4N = false;
			oc->link6->b4B = false;
			oc->link6->b4T = false;
			oc->link6->linkW0 = NULL;
			oc->link6->linkW3 = NULL;
			oc->link6->linkW4 = NULL;
			oc->link6->linkW7 = NULL;
			oc->link6->linkE1 = NULL;
			oc->link6->linkE2 = NULL;
			oc->link6->linkE5 = NULL;
			oc->link6->linkE6 = NULL;
			oc->link6->linkS0 = NULL;
			oc->link6->linkS1 = NULL;
			oc->link6->linkS4 = NULL;
			oc->link6->linkS5 = NULL;
			oc->link6->linkN2 = NULL;
			oc->link6->linkN3 = NULL;
			oc->link6->linkN6 = NULL;
			oc->link6->linkN7 = NULL;
			oc->link6->linkB0 = NULL;
			oc->link6->linkB1 = NULL;
			oc->link6->linkB2 = NULL;
			oc->link6->linkB3 = NULL;
			oc->link6->linkT4 = NULL;
			oc->link6->linkT5 = NULL;
			oc->link6->linkT6 = NULL;
			oc->link6->linkT7 = NULL;
			oc->link6->dlist = true;
			oc->link6->b_the_geometric_fragmentation = true;
			if (dodroblenie) {
				oc->link6->bcrushing_when_balancing = true;
			}
			else {
				oc->link6->bcrushing_when_balancing = false;
			}
			oc->link6->maxBsosed = 10000000;
			oc->link6->maxTsosed = 10000000;
			oc->link6->maxSsosed = 10000000;
			oc->link6->maxNsosed = 10000000;
			oc->link6->maxWsosed = 10000000;
			oc->link6->maxEsosed = 10000000;


			my_ALICE_STACK[top_ALICE_STACK].link = oc->link6;
			top_ALICE_STACK++;
		}
		else {
			oc->link6 = NULL;
		}
		integer minx7 = minx;
		integer maxx7 = avgx;
		integer miny7 = avgy;
		integer maxy7 = maxy;
		integer minz7 = avgz;
		integer maxz7 = maxz;
		doublereal rminx7 = xpos[minx];
		doublereal rmaxx7 = xpos[avgx];
		doublereal rminy7 = ypos[avgy];
		doublereal rmaxy7 = ypos[maxy];
		doublereal rminz7 = zpos[avgz];
		doublereal rmaxz7 = zpos[maxz];
		if (b7) {
			//droblenie(xpos, ypos, zpos,
			//inx, iny, inz, oc->link7,
			//minx7, maxx7, miny7, maxy7, minz7, maxz7, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx7;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx7;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny7;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy7;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz7;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz7;

			oc->link7 = new octTree;
			oc->link7->inum_TD = 0; // Не принадлежит расчётной области.
			oc->link7->inum_FD = 0;// Не принадлежит расчётной области.
			if (oc->link7 == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for oc->link7 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			oc->link7->parent = oc;
			oc->link7->ilevel = oc->ilevel + 1;
			

			if (bold_stable_version1) {
				oc->link7->brootSituationX = bSituationX;
				oc->link7->brootSituationY = bSituationY;
				oc->link7->brootSituationZ = bSituationZ;

				oc->link7->brootSituationX_virtual = bSituationX;
				oc->link7->brootSituationY_virtual = bSituationY;
				oc->link7->brootSituationZ_virtual = bSituationZ;
			}
			else {
				oc->link7->brootSituationX = bSituationX;
				oc->link7->brootSituationY = bSituationY;
				oc->link7->brootSituationZ = bSituationZ;

				oc->link7->brootSituationX_virtual = bSituationX_prefix;
				oc->link7->brootSituationY_virtual = bSituationY_prefix;
				oc->link7->brootSituationZ_virtual = bSituationZ_prefix;
			}


			oc->link7->root = 7;
			oc->link7->minx = minx7;
			oc->link7->maxx = maxx7;
			oc->link7->miny = miny7;
			oc->link7->maxy = maxy7;
			oc->link7->minz = minz7;
			oc->link7->maxz = maxz7;

			oc->link7->p0.x = rminx7;
			oc->link7->p0.y = rminy7;
			oc->link7->p0.z = rminz7;
			oc->link7->p1.x = rmaxx7;
			oc->link7->p1.y = rminy7;
			oc->link7->p1.z = rminz7;
			oc->link7->p2.x = rmaxx7;
			oc->link7->p2.y = rmaxy7;
			oc->link7->p2.z = rminz7;
			oc->link7->p3.x = rminx7;
			oc->link7->p3.y = rmaxy7;
			oc->link7->p3.z = rminz7;

			oc->link7->p4.x = rminx7;
			oc->link7->p4.y = rminy7;
			oc->link7->p4.z = rmaxz7;
			oc->link7->p5.x = rmaxx7;
			oc->link7->p5.y = rminy7;
			oc->link7->p5.z = rmaxz7;
			oc->link7->p6.x = rmaxx7;
			oc->link7->p6.y = rmaxy7;
			oc->link7->p6.z = rmaxz7;
			oc->link7->p7.x = rminx7;
			oc->link7->p7.y = rmaxy7;
			oc->link7->p7.z = rmaxz7;
			oc->link7->link0 = NULL;
			oc->link7->link1 = NULL;
			oc->link7->link2 = NULL;
			oc->link7->link3 = NULL;
			oc->link7->link4 = NULL;
			oc->link7->link5 = NULL;
			oc->link7->link6 = NULL;
			oc->link7->link7 = NULL;
			// пока соседей просто нету.
			oc->link7->linkW = NULL;
			oc->link7->linkE = NULL;
			oc->link7->linkS = NULL;
			oc->link7->linkN = NULL;
			oc->link7->linkB = NULL;
			oc->link7->linkT = NULL;
			oc->link7->b4W = false;
			oc->link7->b4E = false;
			oc->link7->b4S = false;
			oc->link7->b4N = false;
			oc->link7->b4B = false;
			oc->link7->b4T = false;
			oc->link7->linkW0 = NULL;
			oc->link7->linkW3 = NULL;
			oc->link7->linkW4 = NULL;
			oc->link7->linkW7 = NULL;
			oc->link7->linkE1 = NULL;
			oc->link7->linkE2 = NULL;
			oc->link7->linkE5 = NULL;
			oc->link7->linkE6 = NULL;
			oc->link7->linkS0 = NULL;
			oc->link7->linkS1 = NULL;
			oc->link7->linkS4 = NULL;
			oc->link7->linkS5 = NULL;
			oc->link7->linkN2 = NULL;
			oc->link7->linkN3 = NULL;
			oc->link7->linkN6 = NULL;
			oc->link7->linkN7 = NULL;
			oc->link7->linkB0 = NULL;
			oc->link7->linkB1 = NULL;
			oc->link7->linkB2 = NULL;
			oc->link7->linkB3 = NULL;
			oc->link7->linkT4 = NULL;
			oc->link7->linkT5 = NULL;
			oc->link7->linkT6 = NULL;
			oc->link7->linkT7 = NULL;
			oc->link7->dlist = true;
			oc->link7->b_the_geometric_fragmentation = true;
			if (dodroblenie) {
				oc->link7->bcrushing_when_balancing = true;
			}
			else {
				oc->link7->bcrushing_when_balancing = false;
			}
			oc->link7->maxBsosed = 10000000;
			oc->link7->maxTsosed = 10000000;
			oc->link7->maxSsosed = 10000000;
			oc->link7->maxNsosed = 10000000;
			oc->link7->maxWsosed = 10000000;
			oc->link7->maxEsosed = 10000000;


			my_ALICE_STACK[top_ALICE_STACK].link = oc->link7;
			top_ALICE_STACK++;
		}
		else {
			oc->link7 = NULL;
		}

		if (DEBUG_ALICE_MESH) {
			if (oc->b4N) {
				printf("Ok b4N vstretilsq pri droblenii.");
				//getchar();
				system("PAUSE");
			}
		}

		// Здесь  предусмотрен случай четырёх соседей по face грани ячейки.
		if (oc->link0 != NULL) {
			if (bSituationZ) {
				if (oc->b4T) {
					oc->link0->linkT = oc->linkT4;
				}
				else {
					oc->link0->linkT = oc->linkT;
				}
			}
			else {
				oc->link0->linkT = oc->link4;
			}
			// Y 0,1,4,5
			if (bSituationY) {
				if (oc->b4N) {
					oc->link0->linkN = oc->linkN3;
				}
				else {
					oc->link0->linkN = oc->linkN;
				}
			}
			else {
				oc->link0->linkN = oc->link3;
			}
			// X 0,3,4,7
			if (bSituationX) {
				if (oc->b4E) {
					oc->link0->linkE = oc->linkE1;
				}
				else {
					oc->link0->linkE = oc->linkE;
				}
			}
			else {
				oc->link0->linkE = oc->link1;
			}

			if (oc->b4B) {
				oc->link0->linkB = oc->linkB0;
			}
			else {
				oc->link0->linkB = oc->linkB;
			}
			if (oc->b4W) {
				oc->link0->linkW = oc->linkW0;
			}
			else {
				oc->link0->linkW = oc->linkW;
			}
			if (oc->b4S) {
				oc->link0->linkS = oc->linkS0;
			}
			else {
				oc->link0->linkS = oc->linkS;
			}
		}
		if (oc->link1 != NULL) {
			if (bSituationZ) {
				if (oc->b4T) {
					oc->link1->linkT = oc->linkT5;
				}
				else {
					oc->link1->linkT = oc->linkT;
				}
			}
			else {
				oc->link1->linkT = oc->link5;
			}
			if (bSituationY) {
				if (oc->b4N) {
					oc->link1->linkN = oc->linkN2;
				}
				else {
					oc->link1->linkN = oc->linkN;
				}
			}
			else {
				oc->link1->linkN = oc->link2;
			}
			oc->link1->linkW = oc->link0;

			if (oc->b4B) {
				oc->link1->linkB = oc->linkB1;
			}
			else {
				oc->link1->linkB = oc->linkB;
			}
			if (oc->b4E) {
				oc->link1->linkE = oc->linkE1;
			}
			else {
				oc->link1->linkE = oc->linkE;
			}
			if (oc->b4S) {
				oc->link1->linkS = oc->linkS1;
			}
			else {
				oc->link1->linkS = oc->linkS;
			}
		}
		if (oc->link2 != NULL) {
			if (bSituationZ) {
				if (oc->b4T) {
					oc->link2->linkT = oc->linkT6;
				}
				else {
					oc->link2->linkT = oc->linkT;
				}
			}
			else {
				oc->link2->linkT = oc->link6;
			}
			oc->link2->linkS = oc->link1;
			oc->link2->linkW = oc->link3;
			if (oc->b4B) {
				oc->link2->linkB = oc->linkB2;
			}
			else {
				oc->link2->linkB = oc->linkB;
			}
			if (oc->b4E) {
				oc->link2->linkE = oc->linkE2;
			}
			else {
				oc->link2->linkE = oc->linkE;
			}
			if (oc->b4N) {
				oc->link2->linkN = oc->linkN2;
			}
			else {
				oc->link2->linkN = oc->linkN;
			}
		}
		if (oc->link3 != NULL) {
			if (bSituationZ) {
				if (oc->b4T) {
					oc->link3->linkT = oc->linkT7;
				}
				else {
					oc->link3->linkT = oc->linkT;
				}
			}
			else {
				oc->link3->linkT = oc->link7;
			}
			oc->link3->linkS = oc->link0;
			if (bSituationX) {
				if (oc->b4E) {
					oc->link3->linkE = oc->linkE2;
				}
				else {
					oc->link3->linkE = oc->linkE;
				}
			}
			else {
				oc->link3->linkE = oc->link2;
			}

			if (oc->b4B) {
				oc->link3->linkB = oc->linkB3;
			}
			else {
				oc->link3->linkB = oc->linkB;
			}
			if (oc->b4W) {
				oc->link3->linkW = oc->linkW3;
			}
			else {
				oc->link3->linkW = oc->linkW;
			}
			if (oc->b4N) {
				oc->link3->linkN = oc->linkN3;
			}
			else {
				oc->link3->linkN = oc->linkN;
			}
		}
		if (oc->link4 != NULL) {
			oc->link4->linkB = oc->link0;
			if (bSituationY) {
				if (oc->b4N) {
					oc->link4->linkN = oc->linkN7;
				}
				else {
					oc->link4->linkN = oc->linkN;
				}
			}
			else {
				oc->link4->linkN = oc->link7;
			}
			if (bSituationX) {
				if (oc->b4E) {
					oc->link4->linkE = oc->linkE5;
				}
				else {
					oc->link4->linkE = oc->linkE;
				}
			}
			else {
				oc->link4->linkE = oc->link5;
			}

			if (oc->b4T) {
				oc->link4->linkT = oc->linkT4;
			}
			else {
				oc->link4->linkT = oc->linkT;
			}
			if (oc->b4W) {
				oc->link4->linkW = oc->linkW4;
			}
			else {
				oc->link4->linkW = oc->linkW;
			}
			if (oc->b4S) {
				oc->link4->linkS = oc->linkS4;
			}
			else {
				oc->link4->linkS = oc->linkS;
			}
		}
		if (oc->link5 != NULL) {
			oc->link5->linkB = oc->link1;
			if (bSituationY) {
				if (oc->b4N) {
					oc->link5->linkN = oc->linkN6;
				}
				else {
					oc->link5->linkN = oc->linkN;
				}
			}
			else {
				oc->link5->linkN = oc->link6;
			}
			oc->link5->linkW = oc->link4;
			if (oc->b4T) {
				oc->link5->linkT = oc->linkT5;
			}
			else {
				oc->link5->linkT = oc->linkT;
			}
			if (oc->b4E) {
				oc->link5->linkE = oc->linkE5;
			}
			else {
				oc->link5->linkE = oc->linkE;
			}
			if (oc->b4S) {
				oc->link5->linkS = oc->linkS5;
			}
			else {
				oc->link5->linkS = oc->linkS;
			}
		}
		if (oc->link6 != NULL) {
			oc->link6->linkB = oc->link2;
			oc->link6->linkS = oc->link5;
			oc->link6->linkW = oc->link7;
			if (oc->b4T) {
				oc->link6->linkT = oc->linkT6;
			}
			else {
				oc->link6->linkT = oc->linkT;
			}
			if (oc->b4E) {
				oc->link6->linkE = oc->linkE6;
			}
			else {
				oc->link6->linkE = oc->linkE;
			}
			if (oc->b4N) {
				oc->link6->linkN = oc->linkN6;
			}
			else {
				oc->link6->linkN = oc->linkN;
			}
		}
		if (oc->link7 != NULL) {
			oc->link7->linkB = oc->link3;
			oc->link7->linkS = oc->link4;
			if (bSituationX) {
				if (oc->b4E) {
					oc->link7->linkE = oc->linkE6;
				}
				else {
					oc->link7->linkE = oc->linkE;
				}
			}
			else {
				oc->link7->linkE = oc->link6;
			}

			if (oc->b4T) {
				oc->link7->linkT = oc->linkT7;
			}
			else {
				oc->link7->linkT = oc->linkT;
			}
			if (oc->b4W) {
				oc->link7->linkW = oc->linkW7;
			}
			else {
				oc->link7->linkW = oc->linkW;
			}			
			if (oc->b4N) {
				oc->link7->linkN = oc->linkN7;
			}
			else {
				oc->link7->linkN = oc->linkN;
			}
		}
		/*
		if (bSituationZ) {
		// Вырождение по Z
		if (oc->linkB != NULL) {
		if (is_null(oc->linkB)) {
		//oc->linkB->maxTsosed += 4 - 1;
		patch_sosed_count2(oc->linkB->maxTsosed);
		}
		if (is_null1(oc->linkB)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkB->link4->maxTsosed = 1; //
		oc->linkB->link5->maxTsosed = 1;
		oc->linkB->link6->maxTsosed = 1;
		oc->linkB->link7->maxTsosed = 1;
		}
		}
		if (oc->linkT != NULL) {
		if (is_null(oc->linkT)) {
		//oc->linkT->maxBsosed += 4 - 1;
		patch_sosed_count2(oc->linkT->maxBsosed);
		}
		if (is_null1(oc->linkT)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkT->link0->maxBsosed = 1; //
		oc->linkT->link1->maxBsosed = 1;
		oc->linkT->link2->maxBsosed = 1;
		oc->linkT->link3->maxBsosed = 1;
		}
		}
		}
		else {
		// Полноценное деление на 8 частей.
		if (b0|| b1 || b2 || b3) {
		if (oc->linkB != NULL) {
		if (is_null(oc->linkB)) {
		//oc->linkB->maxTsosed += 4 - 1;
		patch_sosed_count(oc->linkB->maxTsosed, oc->linkB,T);
		}
		if (is_null1(oc->linkB)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkB->link4->maxTsosed = 1; //
		oc->linkB->link5->maxTsosed = 1;
		oc->linkB->link6->maxTsosed = 1;
		oc->linkB->link7->maxTsosed = 1;
		}
		}
		}
		if (b4 || b5 || b6 || b7) {
		if (oc->linkT != NULL) {
		if (is_null(oc->linkT)) {
		//oc->linkT->maxBsosed += 4 - 1;
		patch_sosed_count(oc->linkT->maxBsosed, oc->linkT,B);
		}
		if (is_null1(oc->linkT)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkT->link0->maxBsosed = 1; //
		oc->linkT->link1->maxBsosed = 1;
		oc->linkT->link2->maxBsosed = 1;
		oc->linkT->link3->maxBsosed = 1;
		}
		}
		}
		}


		if (bSituationY) {
		if (oc->linkN != NULL) {
		if (is_null(oc->linkN)) {
		//oc->linkN->maxSsosed += 4 - 1;
		patch_sosed_count2(oc->linkN->maxSsosed);
		}
		else if (is_null1(oc->linkN)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkN->link0->maxSsosed = 1; //
		oc->linkN->link1->maxSsosed = 1;
		oc->linkN->link4->maxSsosed = 1;
		oc->linkN->link5->maxSsosed = 1;
		}
		else {
		// других вариантов быть не может, здесь только 4.
		// может быть 2, 4, 5, 8
		// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
		integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
		is_null2(oc->linkN, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
		if (oc->linkN != NULL) {
		if (oc->linkN->link0 != NULL) {
		oc->linkN->link0->maxSsosed = 1; //
		}
		if (oc->linkN->link1 != NULL) {
		oc->linkN->link1->maxSsosed = 1;
		}
		if (oc->linkN->link4 != NULL) {
		oc->linkN->link4->maxSsosed = 1;
		}
		if (oc->linkN->link5 != NULL) {
		oc->linkN->link5->maxSsosed = 1;
		}
		}
		}
		}
		if (oc->linkS != NULL) {
		if (is_null(oc->linkS)) {
		//oc->linkS->maxNsosed += 4 - 1;
		patch_sosed_count2(oc->linkS->maxNsosed);
		}
		else if (is_null1(oc->linkS)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkS->link2->maxNsosed = 1; //
		oc->linkS->link3->maxNsosed = 1;
		oc->linkS->link6->maxNsosed = 1;
		oc->linkS->link7->maxNsosed = 1;
		}
		else {
		// других вариантов быть не может, здесь только 4.
		// может быть 2, 4, 5, 8
		// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
		integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
		is_null2(oc->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
		if (oc->linkS != NULL) {
		if (oc->linkS->link2 != NULL) {
		oc->linkS->link2->maxNsosed = 1; //
		}
		if (oc->linkS->link3 != NULL) {
		oc->linkS->link3->maxNsosed = 1;
		}
		if (oc->linkS->link6 != NULL) {
		oc->linkS->link6->maxNsosed = 1;
		}
		if (oc->linkS->link7 != NULL) {
		oc->linkS->link7->maxNsosed = 1;
		}
		}
		}
		}
		}
		else {
		// полноценное дробление на 8.
		if (b2 || b3 || b6 || b7) {
		if (oc->linkN != NULL) {
		if (is_null(oc->linkN)) {
		//oc->linkN->maxSsosed += 4 - 1;
		patch_sosed_count(oc->linkN->maxSsosed, oc->linkN,S);
		}
		}
		else if (is_null1(oc->linkN)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkN->link0->maxSsosed = 1; //
		oc->linkN->link1->maxSsosed = 1;
		oc->linkN->link4->maxSsosed = 1;
		oc->linkN->link5->maxSsosed = 1;
		}
		else {
		// других вариантов быть не может, здесь только 4.
		// может быть 2, 4, 5, 8
		// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
		integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
		is_null2(oc->linkN, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
		if (oc->linkN != NULL) {
		if (oc->linkN->link0 != NULL) {
		oc->linkN->link0->maxSsosed = 1; //
		}
		if (oc->linkN->link1 != NULL) {
		oc->linkN->link1->maxSsosed = 1;
		}
		if (oc->linkN->link4 != NULL) {
		oc->linkN->link4->maxSsosed = 1;
		}
		if (oc->linkN->link5 != NULL) {
		oc->linkN->link5->maxSsosed = 1;
		}
		}
		}
		}
		if (b0 || b1 || b4 || b5) {
		if (oc->linkS != NULL) {
		if (is_null(oc->linkS)) {
		//oc->linkS->maxNsosed += 4 - 1;
		patch_sosed_count(oc->linkS->maxNsosed, oc->linkS,N);
		}
		else if (is_null1(oc->linkS)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkS->link2->maxNsosed = 1; //
		oc->linkS->link3->maxNsosed = 1;
		oc->linkS->link6->maxNsosed = 1;
		oc->linkS->link7->maxNsosed = 1;
		}
		else {
		// других вариантов быть не может, здесь только 4.
		// может быть 2, 4, 5, 8
		// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
		integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
		is_null2(oc->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
		if (oc->linkS != NULL) {
		if (oc->linkS->link2 != NULL) {
		oc->linkS->link2->maxNsosed = 1; //
		}
		if (oc->linkS->link3 != NULL) {
		oc->linkS->link3->maxNsosed = 1;
		}
		if (oc->linkS->link6 != NULL) {
		oc->linkS->link6->maxNsosed = 1;
		}
		if (oc->linkS->link7 != NULL) {
		oc->linkS->link7->maxNsosed = 1;
		}
		}
		}
		}
		}
		}

		if (bSituationX) {
		if (oc->linkW != NULL) {
		if (is_null(oc->linkW)) {
		//oc->linkW->maxEsosed += 4 - 1;
		patch_sosed_count2(oc->linkW->maxEsosed);
		}
		if (is_null1(oc->linkW)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkW->link1->maxEsosed = 1; //
		oc->linkW->link2->maxEsosed = 1;
		oc->linkW->link5->maxEsosed = 1;
		oc->linkW->link6->maxEsosed = 1;
		}
		}
		if (oc->linkE != NULL) {
		if (is_null(oc->linkE)) {
		//oc->linkE->maxWsosed += 4 - 1;
		patch_sosed_count2(oc->linkE->maxWsosed);
		}
		if (is_null1(oc->linkE)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkE->link0->maxWsosed = 1; //
		oc->linkE->link3->maxWsosed = 1;
		oc->linkE->link4->maxWsosed = 1;
		oc->linkE->link7->maxWsosed = 1;
		}
		}
		}
		else {
		// полноценное дробление на 8.
		if (b0 || b3 || b4 || b7) {
		if (oc->linkW != NULL) {
		if (is_null(oc->linkW)) {
		//oc->linkW->maxEsosed += 4 - 1;
		patch_sosed_count(oc->linkW->maxEsosed, oc->linkW,E);
		}
		if (is_null1(oc->linkW)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkW->link1->maxEsosed = 1; //
		oc->linkW->link2->maxEsosed = 1;
		oc->linkW->link5->maxEsosed = 1;
		oc->linkW->link6->maxEsosed = 1;
		}
		}
		}
		if (b1 || b2 || b5 || b6) {
		if (oc->linkE != NULL) {
		if (is_null(oc->linkE)) {
		//oc->linkE->maxWsosed += 4 - 1;
		patch_sosed_count(oc->linkE->maxWsosed, oc->linkE,WSIDE);
		}
		if (is_null1(oc->linkE)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkE->link0->maxWsosed = 1; //
		oc->linkE->link3->maxWsosed = 1;
		oc->linkE->link4->maxWsosed = 1;
		oc->linkE->link7->maxWsosed = 1;
		}
		}
		}
		}
		*/
	}

} // droblenie_internal


//  droblenie_internal_old завершена в 15:35 27.08.2016. надо делать delenie_internal.
// данный код устарел 30 августа 2016 и больше не поддерживается,
// поэтому см. реализацию droblenie internal.
void droblenie_internal_old(octTree* &oc, integer minx, integer maxx, integer miny, integer maxy, integer minz, integer maxz, doublereal* xpos, doublereal* ypos, doublereal* zpos, integer &ret) {
	bool b0 = true;
	bool b1 = true;
	bool b2 = true;
	bool b3 = true;
	bool b4 = true;
	bool b5 = true;
	bool b6 = true;
	bool b7 = true;
	ret = 0;

	// Вырождение по Z.
	bool bSituationZ = false;
	// Вырождение по X.
	bool bSituationX = false;
	// Вырождение по Y.
	bool bSituationY = false;

	integer avgx = (integer)(0.5*(minx + maxx));
	integer avgy = (integer)(0.5*(miny + maxy));
	integer avgz = (integer)(0.5*(minz + maxz));

	if (1) {
		doublereal xc28 = 0.5*(xpos[minx] + xpos[maxx]);
		integer isearch = -1;
		doublereal dmax28 = 1.0e40;
		// поиск наимее удалённого от геометрического центра индекса.
		for (integer i28 = minx; i28 <= maxx; i28++) {
			if (fabs(xpos[i28] - xc28) < dmax28) {
				isearch = i28;
				dmax28 = fabs(xpos[i28] - xc28);
			}
		}
		avgx = isearch;

		xc28 = 0.5*(ypos[miny] + ypos[maxy]);
		isearch = -1;
		dmax28 = 1.0e40;
		// поиск наимее удалённого от геометрического центра индекса.
		for (integer i28 = miny; i28 <= maxy; i28++) {
			if (fabs(ypos[i28] - xc28) < dmax28) {
				isearch = i28;
				dmax28 = fabs(ypos[i28] - xc28);
			}
		}
		avgy = isearch;

		xc28 = 0.5*(zpos[minz] + zpos[maxz]);
		isearch = -1;
		dmax28 = 1.0e40;
		// поиск наимее удалённого от геометрического центра индекса.
		for (integer i28 = minz; i28 <= maxz; i28++) {
			if (fabs(zpos[i28] - xc28) < dmax28) {
				isearch = i28;
				dmax28 = fabs(zpos[i28] - xc28);
			}
		}
		avgz = isearch;
	}



	if (minz + 1 == maxz) {
		avgz = maxz;
		b4 = false;
		b5 = false;
		b6 = false;
		b7 = false;
		// Вырождение по Z.
		bSituationZ = true;
	}
	if (minx + 1 == maxx) {
		avgx = maxx;
		b1 = false;
		b2 = false;
		b5 = false;
		b6 = false;
		// Вырождение по X.
		bSituationX = true;
	}
	if (miny + 1 == maxy) {
		avgy = maxy;
		b2 = false;
		b3 = false;
		b6 = false;
		b7 = false;
		// Вырождение по Y.
		bSituationY = true;
	}
	if (!b1&&!b2&&!b3&&!b4&&!b5&&!b6&&!b7) {
		//iret++;
		printf("error list droblenie internal. ");
		//getchar();
		system("PAUSE");
	}
	else {

		bool bonly_dir_X = false;
		bool bonly_dir_Y = false;
		bool bonly_dir_Z = false;

		// дробление на iret частей.
		if (b1&&b2&&b3&&b4&&b5&&b6&&b7) {
			ret = 8;
		}
		else {
			if (bSituationX && (!bSituationY) && (!bSituationZ)) ret = 4;
			if (bSituationY && (!bSituationX) && (!bSituationZ)) ret = 4;
			if (bSituationZ && (!bSituationY) && (!bSituationX)) ret = 4;
			if (bSituationX && (bSituationY) && (!bSituationZ)) {
				ret = 2;
				bonly_dir_Z = true;
			}
			if (bSituationX && (bSituationZ) && (!bSituationY)) {
				ret = 2;
				bonly_dir_Y = true;
			}
			if (bSituationY && (bSituationZ) && (!bSituationX)) {
				ret = 2;
				bonly_dir_X = true;
			}
		}

		// дробление
		integer minx0 = minx;
		integer maxx0 = avgx;
		integer miny0 = miny;
		integer maxy0 = avgy;
		integer minz0 = minz;
		integer maxz0 = avgz;
		doublereal rminx0 = xpos[minx];
		doublereal rmaxx0 = xpos[avgx];
		doublereal rminy0 = ypos[miny];
		doublereal rmaxy0 = ypos[avgy];
		doublereal rminz0 = zpos[minz];
		doublereal rmaxz0 = zpos[avgz];
		if (b0) {
			//droblenie(xpos, ypos, zpos,
			//	inx, iny, inz, oc->link0,
			//	minx0, maxx0, miny0, maxy0, minz0, maxz0, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx0;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx0;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny0;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy0;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz0;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz0;


			oc->link0 = new octTree;
			if (oc->link0 == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for oc->link0 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			oc->link0->parent = oc;
			oc->link0->ilevel = oc->ilevel + 1;
			oc->link0->brootSituationX = bSituationX;
			oc->link0->brootSituationY = bSituationY;
			oc->link0->brootSituationZ = bSituationZ;
			oc->link0->root = 0;
			oc->link0->minx = minx0;
			oc->link0->maxx = maxx0;
			oc->link0->miny = miny0;
			oc->link0->maxy = maxy0;
			oc->link0->minz = minz0;
			oc->link0->maxz = maxz0;

			oc->link0->p0.x = rminx0;
			oc->link0->p0.y = rminy0;
			oc->link0->p0.z = rminz0;
			oc->link0->p1.x = rmaxx0;
			oc->link0->p1.y = rminy0;
			oc->link0->p1.z = rminz0;
			oc->link0->p2.x = rmaxx0;
			oc->link0->p2.y = rmaxy0;
			oc->link0->p2.z = rminz0;
			oc->link0->p3.x = rminx0;
			oc->link0->p3.y = rmaxy0;
			oc->link0->p3.z = rminz0;

			oc->link0->p4.x = rminx0;
			oc->link0->p4.y = rminy0;
			oc->link0->p4.z = rmaxz0;
			oc->link0->p5.x = rmaxx0;
			oc->link0->p5.y = rminy0;
			oc->link0->p5.z = rmaxz0;
			oc->link0->p6.x = rmaxx0;
			oc->link0->p6.y = rmaxy0;
			oc->link0->p6.z = rmaxz0;
			oc->link0->p7.x = rminx0;
			oc->link0->p7.y = rmaxy0;
			oc->link0->p7.z = rmaxz0;
			oc->link0->link0 = NULL;
			oc->link0->link1 = NULL;
			oc->link0->link2 = NULL;
			oc->link0->link3 = NULL;
			oc->link0->link4 = NULL;
			oc->link0->link5 = NULL;
			oc->link0->link6 = NULL;
			oc->link0->link7 = NULL;
			// пока соседей просто нету.
			oc->link0->linkW = NULL;
			oc->link0->linkE = NULL;
			oc->link0->linkS = NULL;
			oc->link0->linkN = NULL;
			oc->link0->linkB = NULL;
			oc->link0->linkT = NULL;
			oc->link0->b4W = false;
			oc->link0->b4E = false;
			oc->link0->b4S = false;
			oc->link0->b4N = false;
			oc->link0->b4B = false;
			oc->link0->b4T = false;
			oc->link0->linkW0 = NULL;
			oc->link0->linkW3 = NULL;
			oc->link0->linkW4 = NULL;
			oc->link0->linkW7 = NULL;
			oc->link0->linkE1 = NULL;
			oc->link0->linkE2 = NULL;
			oc->link0->linkE5 = NULL;
			oc->link0->linkE6 = NULL;
			oc->link0->linkS0 = NULL;
			oc->link0->linkS1 = NULL;
			oc->link0->linkS4 = NULL;
			oc->link0->linkS5 = NULL;
			oc->link0->linkN2 = NULL;
			oc->link0->linkN3 = NULL;
			oc->link0->linkN6 = NULL;
			oc->link0->linkN7 = NULL;
			oc->link0->linkB0 = NULL;
			oc->link0->linkB1 = NULL;
			oc->link0->linkB2 = NULL;
			oc->link0->linkB3 = NULL;
			oc->link0->linkT4 = NULL;
			oc->link0->linkT5 = NULL;
			oc->link0->linkT6 = NULL;
			oc->link0->linkT7 = NULL;
			oc->link0->dlist = true;
			oc->link0->b_the_geometric_fragmentation = true;

			oc->link0->maxBsosed = 10000000;
			oc->link0->maxTsosed = 10000000;
			oc->link0->maxSsosed = 10000000;
			oc->link0->maxNsosed = 10000000;
			oc->link0->maxWsosed = 10000000;
			oc->link0->maxEsosed = 10000000;

			if (bSituationZ) {
				// Вырождение по OZ.
				if (oc->linkT != NULL) {
					if (is_null(oc->linkT)) {
						// 1 остаётся 1.
						oc->link0->maxTsosed = 1; // oc->maxTsosed;
					}
					else if (is_null1(oc->linkT)) {

						if ((bonly_dir_X) || (bonly_dir_Y)) {
							oc->link0->maxTsosed = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link0->maxTsosed = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if ((bonly_dir_X) || (bonly_dir_Y)) {
							if (bonly_dir_X) {
								// дробим только по оси Ох.
								oc->link0->maxTsosed = c0 + c3;
							}
							if (bonly_dir_Y) {
								// дробим только по оси Oy.
								oc->link0->maxTsosed = c0 + c1;
							}
						}
						else {
							//oc->link0->maxTsosed = 4;
							oc->link0->maxTsosed = c0;
						}
					}
				}
				else {
					// 0 остаётся 0.
					oc->link0->maxTsosed = 0;// oc->maxTsosed;
				}
			}
			else {
				// это была внутренняя ячейка.
				oc->link0->maxTsosed = 1;

			}
			if (bSituationY) {
				if (oc->linkN != NULL) {
					if (is_null(oc->linkN)) {
						// 1 остаётся 1.
						oc->link0->maxNsosed = 1; // oc->maxNsosed;
					}
					else if (is_null1(oc->linkN)) {
						if ((bonly_dir_X) || (bonly_dir_Z)) {
							oc->link0->maxNsosed = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link0->maxNsosed = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if ((bonly_dir_X) || (bonly_dir_Z)) {
							if (bonly_dir_X) {
								oc->link0->maxNsosed = c0 + c4;
							}
							if (bonly_dir_Z) {
								oc->link0->maxNsosed = c0 + c1;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							//oc->link0->maxNsosed = 4;
							oc->link0->maxNsosed = c0;
						}
					}
				}
				else {
					// 0 остаётся 0.
					oc->link0->maxNsosed = 0; // oc->maxNsosed;
				}
			}
			else {

				oc->link0->maxNsosed = 1;

			}
			if (bSituationX) {
				if (oc->linkE != NULL) {
					if (is_null(oc->linkE)) {
						// 1 остаётся 1.
						oc->link0->maxEsosed = 1; // oc->maxEsosed;
					}
					else if (is_null1(oc->linkE)) {
						if ((bonly_dir_Z) || (bonly_dir_Y)) {
							oc->link0->maxEsosed = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link0->maxEsosed = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if ((bonly_dir_Y) || (bonly_dir_Z)) {
							if (bonly_dir_Y) {
								// дробим только по оси Oy.
								oc->link0->maxEsosed = c0 + c4;
							}
							if (bonly_dir_Z) {
								// дробим только по оси Oz.
								oc->link0->maxEsosed = c0 + c3;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							//oc->link0->maxEsosed = 4;
							oc->link0->maxEsosed = c0;
						}
					}
				}
				else {
					// 0 остаётся 0.
					oc->link0->maxEsosed = 0; // oc->maxEsosed;
				}
			}
			else {
				oc->link0->maxEsosed = 1;
			}
			// Должно быть уменьшение при дроблении:
			if (oc->linkW != NULL) {
				if (bSituationY && (!bSituationX) && (!bSituationZ)) {
					if (is_null(oc->linkW)) {
						// 1 остаётся 1.
						oc->link0->maxWsosed = 1;// oc->maxBsosed;
					}
					else if (is_null1(oc->linkW)) {
						// двойная прилегает к четверной.
						oc->link0->maxWsosed = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link0->maxWsosed = c1 + c2;
					}
				}
				else if (bSituationZ && (!bSituationX) && (!bSituationY)) {
					if (is_null(oc->linkW)) {
						// 1 остаётся 1.
						oc->link0->maxWsosed = 1;// oc->maxBsosed;
					}
					else if (is_null1(oc->linkW)) {
						// двойная прилегает к четверной.
						oc->link0->maxWsosed = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link0->maxWsosed = c1 + c5;
					}
				}
				else {
					if (is_null(oc->linkW)) {
						// 1 остаётся 1.
						oc->link0->maxWsosed = 1;// oc->maxWsosed;
					}
					else if (is_null1(oc->linkW)) {
						if (bonly_dir_Y){
							oc->link0->maxWsosed = 2;
						}
						else if (bonly_dir_Z) {
							oc->link0->maxWsosed = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link0->maxWsosed = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//oc->link0->maxWsosed = 4;
						if (bonly_dir_Y) {
							oc->link0->maxWsosed = c1 + c5;
						}
						else if (bonly_dir_Z) {
							oc->link0->maxWsosed = c1 + c2;
						}
						else {
							oc->link0->maxWsosed = c1;
						}

					}
				}
			}
			else {
				// 0 остаётся 0.
				oc->link0->maxWsosed = 0; // oc->maxWsosed;
			}
			if (oc->linkS != NULL) {
				if (bSituationX && (!bSituationY) && (!bSituationZ)) {
					if (is_null(oc->linkS)) {
						// 1 остаётся 1.
						oc->link0->maxSsosed = 1;// oc->maxBsosed;
					}
					else if (is_null1(oc->linkS)) {
						// двойная прилегает к четверной.
						oc->link0->maxSsosed = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link0->maxSsosed = c3 + c2;
					}
				}
				else if (bSituationZ && (!bSituationX) && (!bSituationY)) {
					if (is_null(oc->linkS)) {
						// 1 остаётся 1.
						oc->link0->maxSsosed = 1;// oc->maxBsosed;
					}
					else if (is_null1(oc->linkS)) {
						// двойная прилегает к четверной.
						oc->link0->maxSsosed = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link0->maxSsosed = c3 + c7;
					}
				}
				else {
					if (is_null(oc->linkS)) {
						// 1 остаётся 1.
						oc->link0->maxSsosed = 1;// oc->maxSsosed;
					}
					else if (is_null1(oc->linkS)) {
						if (bonly_dir_Z) {
							oc->link0->maxSsosed = 2;
						}
						else if (bonly_dir_X) {
							oc->link0->maxSsosed = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link0->maxSsosed = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						if (bonly_dir_Z) {
							oc->link0->maxSsosed = c3 + c2;
						}
						else if (bonly_dir_X) {
							oc->link0->maxSsosed = c3 + c7;
						}
						else {
							//oc->link0->maxSsosed = 4;
							oc->link0->maxSsosed = c3;
						}
					}
				}
			}
			else {
				// 0 остаётся 0.
				oc->link0->maxSsosed = 0;// oc->maxSsosed;
			}
			if (oc->linkB != NULL) {
				if (bSituationY && (!bSituationX) && (!bSituationZ)) {
					if (is_null(oc->linkB)) {
						// 1 остаётся 1.
						oc->link0->maxBsosed = 1;// oc->maxBsosed;
					}
					else if (is_null1(oc->linkB)) {
						// двойная прилегает к четверной.
						oc->link0->maxBsosed = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link0->maxBsosed = c4 + c7;
					}
				}
				else if (bSituationX && (!bSituationY) && (!bSituationZ)) {
					if (is_null(oc->linkB)) {
						// 1 остаётся 1.
						oc->link0->maxBsosed = 1;// oc->maxBsosed;
					}
					else if (is_null1(oc->linkB)) {
						// двойная прилегает к четверной.
						oc->link0->maxBsosed = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link0->maxBsosed = c4 + c5;
					}
				}
				else {
					if (is_null(oc->linkB)) {
						// 1 остаётся 1.
						oc->link0->maxBsosed = 1;// oc->maxBsosed;
					}
					else if (is_null1(oc->linkB)) {
						if (bonly_dir_Y) {
							oc->link0->maxBsosed = 2;
						}
						else if (bonly_dir_X) {
							oc->link0->maxBsosed = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link0->maxBsosed = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if (bonly_dir_Y) {
							oc->link0->maxBsosed = c4 + c5;
						}
						else if (bonly_dir_X) {
							oc->link0->maxBsosed = c4 + c7;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							//oc->link0->maxBsosed = 4;
							oc->link0->maxBsosed = c4;
						}
					}
				}
			}
			else {
				// 0 остаётся 0.
				oc->link0->maxBsosed = 0;// oc->maxBsosed;
			}


			// А вот у соседей B, SSIDE, W количество соседей стало уже 4.
			// чтобы к ним обратится нужна ссылка на эти ячейки.
			// для этого нужна ссылка вврх на шести соседей oc ячейки 
			/*.
			if (oc->linkB != NULL) {
			oc->linkB->maxTsosed += 4 - 1;
			}
			if (oc->linkS != NULL) {
			oc->linkS->maxNsosed += 4 - 1;
			}
			if (oc->linkW != NULL) {
			oc->linkW->maxEsosed += 4 - 1;
			}
			*/
			my_ALICE_STACK[top_ALICE_STACK].link = oc->link0;
			top_ALICE_STACK++;
		}
		else {
			oc->link0 = NULL;
		}
		integer minx1 = avgx;
		integer maxx1 = maxx;
		integer miny1 = miny;
		integer maxy1 = avgy;
		integer minz1 = minz;
		integer maxz1 = avgz;
		doublereal rminx1 = xpos[avgx];
		doublereal rmaxx1 = xpos[maxx];
		doublereal rminy1 = ypos[miny];
		doublereal rmaxy1 = ypos[avgy];
		doublereal rminz1 = zpos[minz];
		doublereal rmaxz1 = zpos[avgz];
		if (b1) {
			//droblenie(xpos, ypos, zpos,
			//	inx, iny, inz, oc->link1,
			//	minx1, maxx1, miny1, maxy1, minz1, maxz1, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx1;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx1;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny1;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy1;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz1;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz1;

			oc->link1 = new octTree;
			if (oc->link1 == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for oc->link1 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			oc->link1->parent = oc;
			oc->link1->ilevel = oc->ilevel + 1;
			oc->link1->brootSituationX = bSituationX;
			oc->link1->brootSituationY = bSituationY;
			oc->link1->brootSituationZ = bSituationZ;
			oc->link1->root = 1;
			oc->link1->minx = minx1;
			oc->link1->maxx = maxx1;
			oc->link1->miny = miny1;
			oc->link1->maxy = maxy1;
			oc->link1->minz = minz1;
			oc->link1->maxz = maxz1;
			oc->link1->p0.x = rminx1;
			oc->link1->p0.y = rminy1;
			oc->link1->p0.z = rminz1;
			oc->link1->p1.x = rmaxx1;
			oc->link1->p1.y = rminy1;
			oc->link1->p1.z = rminz1;
			oc->link1->p2.x = rmaxx1;
			oc->link1->p2.y = rmaxy1;
			oc->link1->p2.z = rminz1;
			oc->link1->p3.x = rminx1;
			oc->link1->p3.y = rmaxy1;
			oc->link1->p3.z = rminz1;
			oc->link1->p4.x = rminx1;
			oc->link1->p4.y = rminy1;
			oc->link1->p4.z = rmaxz1;
			oc->link1->p5.x = rmaxx1;
			oc->link1->p5.y = rminy1;
			oc->link1->p5.z = rmaxz1;
			oc->link1->p6.x = rmaxx1;
			oc->link1->p6.y = rmaxy1;
			oc->link1->p6.z = rmaxz1;
			oc->link1->p7.x = rminx1;
			oc->link1->p7.y = rmaxy1;
			oc->link1->p7.z = rmaxz1;
			oc->link1->link0 = NULL;
			oc->link1->link1 = NULL;
			oc->link1->link2 = NULL;
			oc->link1->link3 = NULL;
			oc->link1->link4 = NULL;
			oc->link1->link5 = NULL;
			oc->link1->link6 = NULL;
			oc->link1->link7 = NULL;
			// пока соседей просто нету.
			oc->link1->linkW = NULL;
			oc->link1->linkE = NULL;
			oc->link1->linkS = NULL;
			oc->link1->linkN = NULL;
			oc->link1->linkB = NULL;
			oc->link1->linkT = NULL;
			oc->link1->b4W = false;
			oc->link1->b4E = false;
			oc->link1->b4S = false;
			oc->link1->b4N = false;
			oc->link1->b4B = false;
			oc->link1->b4T = false;
			oc->link1->linkW0 = NULL;
			oc->link1->linkW3 = NULL;
			oc->link1->linkW4 = NULL;
			oc->link1->linkW7 = NULL;
			oc->link1->linkE1 = NULL;
			oc->link1->linkE2 = NULL;
			oc->link1->linkE5 = NULL;
			oc->link1->linkE6 = NULL;
			oc->link1->linkS0 = NULL;
			oc->link1->linkS1 = NULL;
			oc->link1->linkS4 = NULL;
			oc->link1->linkS5 = NULL;
			oc->link1->linkN2 = NULL;
			oc->link1->linkN3 = NULL;
			oc->link1->linkN6 = NULL;
			oc->link1->linkN7 = NULL;
			oc->link1->linkB0 = NULL;
			oc->link1->linkB1 = NULL;
			oc->link1->linkB2 = NULL;
			oc->link1->linkB3 = NULL;
			oc->link1->linkT4 = NULL;
			oc->link1->linkT5 = NULL;
			oc->link1->linkT6 = NULL;
			oc->link1->linkT7 = NULL;
			oc->link1->dlist = true;
			oc->link1->b_the_geometric_fragmentation = true;
			oc->link1->maxBsosed = 10000000;
			oc->link1->maxTsosed = 10000000;
			oc->link1->maxSsosed = 10000000;
			oc->link1->maxNsosed = 10000000;
			oc->link1->maxWsosed = 10000000;
			oc->link1->maxEsosed = 10000000;

			if (bSituationZ) {
				// Вырождение по OZ.
				if (oc->linkT != NULL) {
					if (is_null(oc->linkT)) {
						// 1 остаётся 1.
						oc->link1->maxTsosed = 1;// oc->maxTsosed;
					}
					else if (is_null1(oc->linkT)) {
						if (bonly_dir_X) {
							oc->link1->maxTsosed = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link1->maxTsosed = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if ((bonly_dir_X)) {
							if (bonly_dir_X) {
								// дробим только по оси Oy.
								oc->link1->maxTsosed = c1 + c2;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть  2, 4, 5, 8
							//oc->link1->maxTsosed = 4;
							oc->link1->maxTsosed = c1;
						}
					}
				}
				else {
					// 0 остаётся 0.
					oc->link1->maxTsosed = 0;// oc->maxTsosed;
				}
			}
			else {
				oc->link1->maxTsosed = 1;
			}
			if (bSituationY) {
				if (oc->linkN != NULL) {
					if (is_null(oc->linkN)) {
						// 1 остаётся 1.
						oc->link1->maxNsosed = 1;// oc->maxNsosed;
					}
					else if (is_null1(oc->linkN)) {
						if (bonly_dir_X) {
							oc->link1->maxNsosed = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link1->maxNsosed = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if ((bonly_dir_X)) {
							if (bonly_dir_X) {
								// дробим только по оси Oy.
								oc->link1->maxNsosed = c1 + c5;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							//oc->link1->maxNsosed = 4;
							oc->link1->maxNsosed = c1;
						}
					}
				}
				else {
					// 0 остаётся 0.
					oc->link1->maxNsosed = 0;// oc->maxNsosed;
				}
			}
			else {
				oc->link1->maxNsosed = 1;
			}


			oc->link1->maxWsosed = 1;



			// Должно быть уменьшение при дроблении:
			if (oc->linkE != NULL) {
				if (is_null(oc->linkE)) {
					// 1 остаётся 1.
					oc->link1->maxEsosed = 1;// oc->maxEsosed;
				}
				else if (is_null1(oc->linkE)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link1->maxEsosed = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link1->maxEsosed = 4;
					oc->link1->maxEsosed = c0;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link1->maxEsosed = 0;// oc->maxEsosed;
			}
			if (oc->linkS != NULL) {
				if (bSituationZ && (!bSituationX) && (!bSituationY)) {
					if (is_null(oc->linkS)) {
						// 1 остаётся 1.
						oc->link1->maxSsosed = 1;// oc->maxBsosed;
					}
					else if (is_null1(oc->linkS)) {
						// двойная прилегает к четверной.
						oc->link1->maxSsosed = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link1->maxSsosed = c2 + c6;
					}
				}
				else {
					if (is_null(oc->linkS)) {
						// 1 остаётся 1.
						oc->link1->maxSsosed = 1;// oc->maxSsosed;
					}
					else if (is_null1(oc->linkS)) {
						if (bonly_dir_X) {
							oc->link1->maxSsosed = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link1->maxSsosed = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if (bonly_dir_X) {
							oc->link1->maxSsosed = c2 + c6;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							//oc->link1->maxSsosed = 4;
							oc->link1->maxSsosed = c2;
						}
					}
				}
			}
			else {
				// 0 остаётся 0.
				oc->link1->maxSsosed = 0;// oc->maxSsosed;
			}
			if (oc->linkB != NULL) {
				if (bSituationY && (!bSituationX) && (!bSituationZ)) {
					if (is_null(oc->linkB)) {
						// 1 остаётся 1.
						oc->link1->maxBsosed = 1;// oc->maxBsosed;
					}
					else if (is_null1(oc->linkB)) {
						// двойная прилегает к четверной.
						oc->link1->maxBsosed = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link1->maxBsosed = c5 + c6;
					}
				}
				else {
					if (is_null(oc->linkB)) {
						// 1 остаётся 1.
						oc->link1->maxBsosed = 1;// oc->maxBsosed;
					}
					else if (is_null1(oc->linkB)) {
						if (bonly_dir_X) {
							oc->link1->maxBsosed = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link1->maxBsosed = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if (bonly_dir_X) {
							oc->link1->maxBsosed = c5 + c6;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							//oc->link1->maxBsosed = 4;
							oc->link1->maxBsosed = c5;
						}
					}
				}
			}
			else {
				// 0 остаётся 0.
				oc->link1->maxBsosed = 0;// oc->maxBsosed;
			}
			/*
			// А вот у соседей B, SSIDE, E количество соседей стало уже 4.
			// чтобы к ним обратится нужна ссылка на эти ячейки.
			// для этого нужна ссылка вврх на шести соседей oc ячейки .
			if (oc->linkB != NULL) {
			oc->linkB->maxTsosed += 4 - 1;
			}
			if (oc->linkS != NULL) {
			oc->linkS->maxNsosed += 4 - 1;
			}
			if (oc->linkE != NULL) {
			oc->linkE->maxWsosed += 4 - 1;
			}
			*/
			my_ALICE_STACK[top_ALICE_STACK].link = oc->link1;
			top_ALICE_STACK++;
		}
		else {
			oc->link1 = NULL;
		}
		integer minx2 = avgx;
		integer maxx2 = maxx;
		integer miny2 = avgy;
		integer maxy2 = maxy;
		integer minz2 = minz;
		integer maxz2 = avgz;
		doublereal rminx2 = xpos[avgx];
		doublereal rmaxx2 = xpos[maxx];
		doublereal rminy2 = ypos[avgy];
		doublereal rmaxy2 = ypos[maxy];
		doublereal rminz2 = zpos[minz];
		doublereal rmaxz2 = zpos[avgz];
		if (b2) {
			//droblenie(xpos, ypos, zpos,
			//inx, iny, inz, oc->link2,
			//minx2, maxx2, miny2, maxy2, minz2, maxz2, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx2;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx2;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny2;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy2;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz2;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz2;

			oc->link2 = new octTree;
			if (oc->link2 == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for oc->link2 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			oc->link2->parent = oc;
			oc->link2->ilevel = oc->ilevel + 1;
			oc->link2->brootSituationX = bSituationX;
			oc->link2->brootSituationY = bSituationY;
			oc->link2->brootSituationZ = bSituationZ;
			oc->link2->root = 2;
			oc->link2->minx = minx2;
			oc->link2->maxx = maxx2;
			oc->link2->miny = miny2;
			oc->link2->maxy = maxy2;
			oc->link2->minz = minz2;
			oc->link2->maxz = maxz2;
			oc->link2->p0.x = rminx2;
			oc->link2->p0.y = rminy2;
			oc->link2->p0.z = rminz2;
			oc->link2->p1.x = rmaxx2;
			oc->link2->p1.y = rminy2;
			oc->link2->p1.z = rminz2;
			oc->link2->p2.x = rmaxx2;
			oc->link2->p2.y = rmaxy2;
			oc->link2->p2.z = rminz2;
			oc->link2->p3.x = rminx2;
			oc->link2->p3.y = rmaxy2;
			oc->link2->p3.z = rminz2;
			oc->link2->p4.x = rminx2;
			oc->link2->p4.y = rminy2;
			oc->link2->p4.z = rmaxz2;
			oc->link2->p5.x = rmaxx2;
			oc->link2->p5.y = rminy2;
			oc->link2->p5.z = rmaxz2;
			oc->link2->p6.x = rmaxx2;
			oc->link2->p6.y = rmaxy2;
			oc->link2->p6.z = rmaxz2;
			oc->link2->p7.x = rminx2;
			oc->link2->p7.y = rmaxy2;
			oc->link2->p7.z = rmaxz2;
			oc->link2->link0 = NULL;
			oc->link2->link1 = NULL;
			oc->link2->link2 = NULL;
			oc->link2->link3 = NULL;
			oc->link2->link4 = NULL;
			oc->link2->link5 = NULL;
			oc->link2->link6 = NULL;
			oc->link2->link7 = NULL;
			// пока соседей просто нету.
			oc->link2->linkW = NULL;
			oc->link2->linkE = NULL;
			oc->link2->linkS = NULL;
			oc->link2->linkN = NULL;
			oc->link2->linkB = NULL;
			oc->link2->linkT = NULL;
			oc->link2->b4W = false;
			oc->link2->b4E = false;
			oc->link2->b4S = false;
			oc->link2->b4N = false;
			oc->link2->b4B = false;
			oc->link2->b4T = false;
			oc->link2->linkW0 = NULL;
			oc->link2->linkW3 = NULL;
			oc->link2->linkW4 = NULL;
			oc->link2->linkW7 = NULL;
			oc->link2->linkE1 = NULL;
			oc->link2->linkE2 = NULL;
			oc->link2->linkE5 = NULL;
			oc->link2->linkE6 = NULL;
			oc->link2->linkS0 = NULL;
			oc->link2->linkS1 = NULL;
			oc->link2->linkS4 = NULL;
			oc->link2->linkS5 = NULL;
			oc->link2->linkN2 = NULL;
			oc->link2->linkN3 = NULL;
			oc->link2->linkN6 = NULL;
			oc->link2->linkN7 = NULL;
			oc->link2->linkB0 = NULL;
			oc->link2->linkB1 = NULL;
			oc->link2->linkB2 = NULL;
			oc->link2->linkB3 = NULL;
			oc->link2->linkT4 = NULL;
			oc->link2->linkT5 = NULL;
			oc->link2->linkT6 = NULL;
			oc->link2->linkT7 = NULL;
			oc->link2->dlist = true;
			oc->link2->b_the_geometric_fragmentation = true;
			oc->link2->maxBsosed = 10000000;
			oc->link2->maxTsosed = 10000000;
			oc->link2->maxSsosed = 10000000;
			oc->link2->maxNsosed = 10000000;
			oc->link2->maxWsosed = 10000000;
			oc->link2->maxEsosed = 10000000;

			if (bSituationZ) {
				// Вырождение по OZ.
				if (oc->linkT != NULL) {
					if (is_null(oc->linkT)) {
						// 1 остаётся 1.
						oc->link2->maxTsosed = 1;// oc->maxTsosed;
					}
					else if (is_null1(oc->linkT)) {
						// две четверные стороны прилегают друг к дружке.
						oc->link2->maxTsosed = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//oc->link2->maxTsosed = 4;
						oc->link2->maxTsosed = c2;
					}
				}
				else {
					// 0 остаётся 0.
					oc->link2->maxTsosed = 0;// oc->maxTsosed;
				}
			}
			else {
				oc->link2->maxTsosed = 1;
			}
			oc->link2->maxSsosed = 1;
			oc->link2->maxWsosed = 1;



			// Должно быть уменьшение при дроблении:
			if (oc->linkE != NULL) {
				if (is_null(oc->linkE)) {
					// 1 остаётся 1.
					oc->link2->maxEsosed = 1;// oc->maxEsosed;
				}
				else if (is_null1(oc->linkE)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link2->maxEsosed = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link2->maxEsosed = 4;
					oc->link2->maxEsosed = c3;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link2->maxEsosed = 0;// oc->maxEsosed;
			}
			if (oc->linkN != NULL) {
				if (is_null(oc->linkN)) {
					// 1 остаётся 1.
					oc->link2->maxNsosed = 1;// oc->maxNsosed;
				}
				else if (is_null1(oc->linkN)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link2->maxNsosed = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);

					// других вариантов быть не может, здесь только 4.
					//oc->link2->maxNsosed = 4;
					oc->link2->maxNsosed = c1;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link2->maxNsosed = 0;// oc->maxNsosed;
			}
			if (oc->linkB != NULL) {
				if (is_null(oc->linkB)) {
					// 1 остаётся 1.
					oc->link2->maxBsosed = 1;// oc->maxBsosed;
				}
				else if (is_null1(oc->linkB)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link2->maxBsosed = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link2->maxBsosed = 4;
					oc->link2->maxBsosed = c6;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link2->maxBsosed = 0;// oc->maxBsosed;
			}
			/*
			// А вот у соседей B, N, E количество соседей стало уже 4.
			// чтобы к ним обратится нужна ссылка на эти ячейки.
			// для этого нужна ссылка вврх на шести соседей oc ячейки .
			if (oc->linkB != NULL) {
			oc->linkB->maxTsosed += 4 - 1;
			}
			if (oc->linkN != NULL) {
			oc->linkN->maxSsosed += 4 - 1;
			}
			if (oc->linkE != NULL) {
			oc->linkE->maxWsosed += 4 - 1;
			}
			*/
			my_ALICE_STACK[top_ALICE_STACK].link = oc->link2;
			top_ALICE_STACK++;
		}
		else {
			oc->link2 = NULL;
		}
		integer minx3 = minx;
		integer maxx3 = avgx;
		integer miny3 = avgy;
		integer maxy3 = maxy;
		integer minz3 = minz;
		integer maxz3 = avgz;
		doublereal rminx3 = xpos[minx];
		doublereal rmaxx3 = xpos[avgx];
		doublereal rminy3 = ypos[avgy];
		doublereal rmaxy3 = ypos[maxy];
		doublereal rminz3 = zpos[minz];
		doublereal rmaxz3 = zpos[avgz];

		if (b3) {
			//droblenie(xpos, ypos, zpos,
			//	inx, iny, inz, oc->link3,
			//	minx3, maxx3, miny3, maxy3, minz3, maxz3, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx3;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx3;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny3;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy3;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz3;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz3;

			oc->link3 = new octTree;
			if (oc->link3 == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for oc->link3 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			oc->link3->parent = oc;
			oc->link3->ilevel = oc->ilevel + 1;
			oc->link3->brootSituationX = bSituationX;
			oc->link3->brootSituationY = bSituationY;
			oc->link3->brootSituationZ = bSituationZ;
			oc->link3->root = 3;
			oc->link3->minx = minx3;
			oc->link3->maxx = maxx3;
			oc->link3->miny = miny3;
			oc->link3->maxy = maxy3;
			oc->link3->minz = minz3;
			oc->link3->maxz = maxz3;
			oc->link3->p0.x = rminx3;
			oc->link3->p0.y = rminy3;
			oc->link3->p0.z = rminz3;
			oc->link3->p1.x = rmaxx3;
			oc->link3->p1.y = rminy3;
			oc->link3->p1.z = rminz3;
			oc->link3->p2.x = rmaxx3;
			oc->link3->p2.y = rmaxy3;
			oc->link3->p2.z = rminz3;
			oc->link3->p3.x = rminx3;
			oc->link3->p3.y = rmaxy3;
			oc->link3->p3.z = rminz3;
			oc->link3->p4.x = rminx3;
			oc->link3->p4.y = rminy3;
			oc->link3->p4.z = rmaxz3;
			oc->link3->p5.x = rmaxx3;
			oc->link3->p5.y = rminy3;
			oc->link3->p5.z = rmaxz3;
			oc->link3->p6.x = rmaxx3;
			oc->link3->p6.y = rmaxy3;
			oc->link3->p6.z = rmaxz3;
			oc->link3->p7.x = rminx3;
			oc->link3->p7.y = rmaxy3;
			oc->link3->p7.z = rmaxz3;
			oc->link3->link0 = NULL;
			oc->link3->link1 = NULL;
			oc->link3->link2 = NULL;
			oc->link3->link3 = NULL;
			oc->link3->link4 = NULL;
			oc->link3->link5 = NULL;
			oc->link3->link6 = NULL;
			oc->link3->link7 = NULL;
			// пока соседей просто нету.
			oc->link3->linkW = NULL;
			oc->link3->linkE = NULL;
			oc->link3->linkS = NULL;
			oc->link3->linkN = NULL;
			oc->link3->linkB = NULL;
			oc->link3->linkT = NULL;
			oc->link3->b4W = false;
			oc->link3->b4E = false;
			oc->link3->b4S = false;
			oc->link3->b4N = false;
			oc->link3->b4B = false;
			oc->link3->b4T = false;
			oc->link3->linkW0 = NULL;
			oc->link3->linkW3 = NULL;
			oc->link3->linkW4 = NULL;
			oc->link3->linkW7 = NULL;
			oc->link3->linkE1 = NULL;
			oc->link3->linkE2 = NULL;
			oc->link3->linkE5 = NULL;
			oc->link3->linkE6 = NULL;
			oc->link3->linkS0 = NULL;
			oc->link3->linkS1 = NULL;
			oc->link3->linkS4 = NULL;
			oc->link3->linkS5 = NULL;
			oc->link3->linkN2 = NULL;
			oc->link3->linkN3 = NULL;
			oc->link3->linkN6 = NULL;
			oc->link3->linkN7 = NULL;
			oc->link3->linkB0 = NULL;
			oc->link3->linkB1 = NULL;
			oc->link3->linkB2 = NULL;
			oc->link3->linkB3 = NULL;
			oc->link3->linkT4 = NULL;
			oc->link3->linkT5 = NULL;
			oc->link3->linkT6 = NULL;
			oc->link3->linkT7 = NULL;
			oc->link3->dlist = true;
			oc->link3->b_the_geometric_fragmentation = true;
			oc->link3->maxBsosed = 10000000;
			oc->link3->maxTsosed = 10000000;
			oc->link3->maxSsosed = 10000000;
			oc->link3->maxNsosed = 10000000;
			oc->link3->maxWsosed = 10000000;
			oc->link3->maxEsosed = 10000000;

			if (bSituationZ) {
				// Вырождение по OZ.
				if (oc->linkT != NULL) {
					if (is_null(oc->linkT)) {
						// 1 остаётся 1.
						oc->link3->maxTsosed = 1;// oc->maxTsosed;
					}
					else if (is_null1(oc->linkT)) {
						if (bonly_dir_Y) {
							oc->link3->maxTsosed = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link3->maxTsosed = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if ((bonly_dir_Y)) {
							if (bonly_dir_Y) {
								// дробим только по оси Oy.
								oc->link3->maxTsosed = c3 + c2;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8.
							//oc->link3->maxTsosed = 4;
							oc->link3->maxTsosed = c3;
						}
					}
				}
				else {
					// 0 остаётся 0.
					oc->link3->maxTsosed = 0;// oc->maxTsosed;
				}
			}
			else {
				oc->link3->maxTsosed = 1;
			}
			oc->link3->maxSsosed = 1;



			if (bSituationX) {
				if (oc->linkE != NULL) {
					if (is_null(oc->linkE)) {
						// 1 остаётся 1.
						oc->link3->maxEsosed = 1;// oc->maxEsosed;
					}
					else if (is_null1(oc->linkE)) {
						if (bonly_dir_Y) {
							oc->link3->maxEsosed = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link3->maxEsosed = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if ((bonly_dir_Y)) {
							if (bonly_dir_Y) {
								// дробим только по оси Oy.
								oc->link3->maxEsosed = c3 + c7;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// Может быть 2, 4, 5, 8
							//oc->link3->maxEsosed = 4;
							oc->link3->maxEsosed = c3;
						}
					}
				}
				else {
					// 0 остаётся 0.
					oc->link3->maxEsosed = 0;// oc->maxEsosed;
				}
			}
			else {
				oc->link3->maxEsosed = 1;
			}


			if (oc->linkW != NULL) {
				if (bSituationZ && (!bSituationX) && (!bSituationY)) {
					if (is_null(oc->linkW)) {
						// 1 остаётся 1.
						oc->link3->maxWsosed = 1;// oc->maxBsosed;
					}
					else if (is_null1(oc->linkW)) {
						// двойная прилегает к четверной.
						oc->link3->maxWsosed = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link3->maxWsosed = c2 + c6;
					}
				}
				else {
					if (is_null(oc->linkW)) {
						// 1 остаётся 1.
						oc->link3->maxWsosed = 1;// oc->maxWsosed;
					}
					else if (is_null1(oc->linkW)) {
						if (bonly_dir_Y) {
							oc->link3->maxWsosed = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link3->maxWsosed = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//oc->link3->maxWsosed = 4;
						if (bonly_dir_Y) {
							oc->link3->maxWsosed = c2 + c6;
						}
						else {
							oc->link3->maxWsosed = c2;
						}
					}
				}
			}
			else {
				// 0 остаётся 0.
				oc->link3->maxWsosed = 0;// oc->maxWsosed;
			}

			if (oc->linkN != NULL) {
				if (is_null(oc->linkN)) {
					// 1 остаётся 1.
					oc->link3->maxNsosed = 1;// oc->maxNsosed;
				}
				else if (is_null1(oc->linkN)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link3->maxNsosed = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link3->maxNsosed = 4;
					oc->link3->maxNsosed = c0;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link3->maxNsosed = 0;// oc->maxNsosed;
			}
			if (oc->linkB != NULL) {
				if (bSituationX && (!bSituationY) && (!bSituationZ)) {
					if (is_null(oc->linkB)) {
						// 1 остаётся 1.
						oc->link3->maxBsosed = 1;// oc->maxBsosed;
					}
					else if (is_null1(oc->linkB)) {
						// двойная прилегает к четверной.
						oc->link3->maxBsosed = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link3->maxBsosed = c7 + c6;
					}
				}
				else if (is_null(oc->linkB)) {
					// 1 остаётся 1.
					oc->link3->maxBsosed = 1;// oc->maxBsosed;
				}
				else if (is_null1(oc->linkB)) {
					if (bonly_dir_Y) {
						oc->link3->maxBsosed = 2;
					}
					else {
						// две четверные стороны прилегают друг к дружке.
						oc->link3->maxBsosed = 1;
					}
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					if (bonly_dir_Y) {
						oc->link3->maxBsosed = c7 + c6;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						//oc->link3->maxBsosed = 4;
						oc->link3->maxBsosed = c7;
					}
				}
			}
			else {
				// 0 остаётся 0.
				oc->link3->maxBsosed = 0;// oc->maxBsosed;
			}

			/*
			// А вот у соседей B, N, W количество соседей стало уже 4.
			// чтобы к ним обратится нужна ссылка на эти ячейки.
			// для этого нужна ссылка вврх на шести соседей oc ячейки .
			if (oc->linkB != NULL) {
			oc->linkB->maxTsosed += 4 - 1;
			}
			if (oc->linkN != NULL) {
			oc->linkN->maxSsosed += 4 - 1;
			}
			if (oc->linkW != NULL) {
			oc->linkW->maxEsosed += 4 - 1;
			}
			*/
			my_ALICE_STACK[top_ALICE_STACK].link = oc->link3;
			top_ALICE_STACK++;
		}
		else {
			oc->link3 = NULL;
		}

		integer minx4 = minx;
		integer maxx4 = avgx;
		integer miny4 = miny;
		integer maxy4 = avgy;
		integer minz4 = avgz;
		integer maxz4 = maxz;
		doublereal rminx4 = xpos[minx];
		doublereal rmaxx4 = xpos[avgx];
		doublereal rminy4 = ypos[miny];
		doublereal rmaxy4 = ypos[avgy];
		doublereal rminz4 = zpos[avgz];
		doublereal rmaxz4 = zpos[maxz];
		if (b4) {
			//droblenie(xpos, ypos, zpos,
			//	inx, iny, inz, oc->link4,
			//	minx4, maxx4, miny4, maxy4, minz4, maxz4, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx4;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx4;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny4;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy4;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz4;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz4;

			oc->link4 = new octTree;
			if (oc->link4 == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for oc->link4 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			oc->link4->parent = oc;
			oc->link4->ilevel = oc->ilevel + 1;
			oc->link4->brootSituationX = bSituationX;
			oc->link4->brootSituationY = bSituationY;
			oc->link4->brootSituationZ = bSituationZ;
			oc->link4->root = 4;
			oc->link4->minx = minx4;
			oc->link4->maxx = maxx4;
			oc->link4->miny = miny4;
			oc->link4->maxy = maxy4;
			oc->link4->minz = minz4;
			oc->link4->maxz = maxz4;
			oc->link4->p0.x = rminx4;
			oc->link4->p0.y = rminy4;
			oc->link4->p0.z = rminz4;
			oc->link4->p1.x = rmaxx4;
			oc->link4->p1.y = rminy4;
			oc->link4->p1.z = rminz4;
			oc->link4->p2.x = rmaxx4;
			oc->link4->p2.y = rmaxy4;
			oc->link4->p2.z = rminz4;
			oc->link4->p3.x = rminx4;
			oc->link4->p3.y = rmaxy4;
			oc->link4->p3.z = rminz4;
			oc->link4->p4.x = rminx4;
			oc->link4->p4.y = rminy4;
			oc->link4->p4.z = rmaxz4;
			oc->link4->p5.x = rmaxx4;
			oc->link4->p5.y = rminy4;
			oc->link4->p5.z = rmaxz4;
			oc->link4->p6.x = rmaxx4;
			oc->link4->p6.y = rmaxy4;
			oc->link4->p6.z = rmaxz4;
			oc->link4->p7.x = rminx4;
			oc->link4->p7.y = rmaxy4;
			oc->link4->p7.z = rmaxz4;
			oc->link4->link0 = NULL;
			oc->link4->link1 = NULL;
			oc->link4->link2 = NULL;
			oc->link4->link3 = NULL;
			oc->link4->link4 = NULL;
			oc->link4->link5 = NULL;
			oc->link4->link6 = NULL;
			oc->link4->link7 = NULL;
			// пока соседей просто нету.
			oc->link4->linkW = NULL;
			oc->link4->linkE = NULL;
			oc->link4->linkS = NULL;
			oc->link4->linkN = NULL;
			oc->link4->linkB = NULL;
			oc->link4->linkT = NULL;
			oc->link4->b4W = false;
			oc->link4->b4E = false;
			oc->link4->b4S = false;
			oc->link4->b4N = false;
			oc->link4->b4B = false;
			oc->link4->b4T = false;
			oc->link4->linkW0 = NULL;
			oc->link4->linkW3 = NULL;
			oc->link4->linkW4 = NULL;
			oc->link4->linkW7 = NULL;
			oc->link4->linkE1 = NULL;
			oc->link4->linkE2 = NULL;
			oc->link4->linkE5 = NULL;
			oc->link4->linkE6 = NULL;
			oc->link4->linkS0 = NULL;
			oc->link4->linkS1 = NULL;
			oc->link4->linkS4 = NULL;
			oc->link4->linkS5 = NULL;
			oc->link4->linkN2 = NULL;
			oc->link4->linkN3 = NULL;
			oc->link4->linkN6 = NULL;
			oc->link4->linkN7 = NULL;
			oc->link4->linkB0 = NULL;
			oc->link4->linkB1 = NULL;
			oc->link4->linkB2 = NULL;
			oc->link4->linkB3 = NULL;
			oc->link4->linkT4 = NULL;
			oc->link4->linkT5 = NULL;
			oc->link4->linkT6 = NULL;
			oc->link4->linkT7 = NULL;
			oc->link4->dlist = true;
			oc->link4->b_the_geometric_fragmentation = true;
			oc->link4->maxBsosed = 10000000;
			oc->link4->maxTsosed = 10000000;
			oc->link4->maxSsosed = 10000000;
			oc->link4->maxNsosed = 10000000;
			oc->link4->maxWsosed = 10000000;
			oc->link4->maxEsosed = 10000000;
			oc->link4->maxBsosed = 1;

			if (bSituationY) {
				if (oc->linkN != NULL) {
					if (is_null(oc->linkN)) {
						// 1 остаётся 1.
						oc->link4->maxNsosed = 1;// oc->maxNsosed;
					}
					else if (is_null1(oc->linkN)) {
						if (bonly_dir_Z) {
							oc->link4->maxNsosed = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link4->maxNsosed = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if ((bonly_dir_Z)) {
							if (bonly_dir_Z) {
								// дробим только по оси Oy.
								oc->link4->maxNsosed = c4 + c5;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// Здесь может быть 2, 4, 5, 8
							//oc->link4->maxNsosed = 4;
							oc->link4->maxNsosed = c4;
						}
					}
				}
				else {
					// 0 остаётся 0.
					oc->link4->maxNsosed = 0;// oc->maxNsosed;
				}
			}
			else {
				oc->link4->maxNsosed = 1;
			}
			if (bSituationX) {
				if (oc->linkE != NULL) {
					if (is_null(oc->linkE)) {
						// 1 остаётся 1.
						oc->link4->maxEsosed = 1;// oc->maxEsosed;
					}
					else if (is_null1(oc->linkE)) {
						if (bonly_dir_Z) {
							oc->link4->maxEsosed = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link4->maxEsosed = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if ((bonly_dir_Z)) {
							if (bonly_dir_Z) {
								// дробим только по оси Oy.
								oc->link4->maxEsosed = c4 + c7;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							//oc->link4->maxEsosed = 4;
							oc->link4->maxEsosed = c4;
						}
					}
				}
				else {
					// 0 остаётся 0.
					oc->link4->maxEsosed = 0;// oc->maxEsosed;
				}
			}
			else {
				oc->link4->maxEsosed = 1;
			}

			if (oc->linkW != NULL) {
				if (bSituationY && (!bSituationX) && (!bSituationZ)) {
					if (is_null(oc->linkW)) {
						// 1 остаётся 1.
						oc->link4->maxWsosed = 1;// oc->maxBsosed;
					}
					else if (is_null1(oc->linkW)) {
						// двойная прилегает к четверной.
						oc->link4->maxWsosed = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link4->maxWsosed = c5 + c6;
					}
				}
				else {
					if (is_null(oc->linkW)) {
						// 1 остаётся 1.
						oc->link4->maxWsosed = 1;// oc->maxWsosed;
					}
					else if (is_null1(oc->linkW)) {
						if (bonly_dir_Z) {
							oc->link4->maxWsosed = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link4->maxWsosed = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//oc->link4->maxWsosed = 4;
						if (bonly_dir_Z) {
							oc->link4->maxWsosed = c5 + c6;
						}
						else {
							oc->link4->maxWsosed = c5;
						}
					}
				}
			}
			else {
				// 0 остаётся 0.
				oc->link4->maxWsosed = 0;// oc->maxWsosed;
			}

			if (oc->linkS != NULL) {
				if (bSituationX && (!bSituationY) && (!bSituationZ)) {
					if (is_null(oc->linkS)) {
						// 1 остаётся 1.
						oc->link4->maxSsosed = 1;// oc->maxBsosed;
					}
					else if (is_null1(oc->linkS)) {
						// двойная прилегает к четверной.
						oc->link4->maxSsosed = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link4->maxSsosed = c7 + c6;
					}
				}
				else {
					if (is_null(oc->linkS)) {
						// 1 остаётся 1.
						oc->link4->maxSsosed = 1;// oc->maxSsosed;
					}
					else if (is_null1(oc->linkS)) {
						if (bonly_dir_Z) {
							oc->link4->maxSsosed = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link4->maxSsosed = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//oc->link4->maxSsosed = 4;
						if (bonly_dir_Z) {
							oc->link4->maxSsosed = c7 + c6;
						}
						else {
							oc->link4->maxSsosed = c7;
						}
					}
				}
			}
			else {
				// 0 остаётся 0.
				oc->link4->maxSsosed = 0;// oc->maxSsosed;
			}
			if (oc->linkT != NULL) {
				if (is_null(oc->linkT)) {
					// 1 остаётся 1.
					oc->link4->maxTsosed = 1;// oc->maxTsosed;
				}
				else if (is_null1(oc->linkT)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link4->maxTsosed = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link4->maxTsosed = 4;
					oc->link4->maxTsosed = c0;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link4->maxTsosed = 0;// oc->maxTsosed;
			}



			/*
			// А вот у соседей B, SSIDE, W количество соседей стало уже 4.
			// чтобы к ним обратится нужна ссылка на эти ячейки.
			// для этого нужна ссылка вврх на шести соседей oc ячейки .
			if (oc->linkT != NULL) {
			oc->linkT->maxBsosed += 4 - 1;
			}
			if (oc->linkS != NULL) {
			oc->linkS->maxNsosed += 4 - 1;
			}
			if (oc->linkW != NULL) {
			oc->linkW->maxEsosed += 4 - 1;
			}
			*/
			my_ALICE_STACK[top_ALICE_STACK].link = oc->link4;
			top_ALICE_STACK++;
		}
		else {
			oc->link4 = NULL;
		}
		integer minx5 = avgx;
		integer maxx5 = maxx;
		integer miny5 = miny;
		integer maxy5 = avgy;
		integer minz5 = avgz;
		integer maxz5 = maxz;
		doublereal rminx5 = xpos[avgx];
		doublereal rmaxx5 = xpos[maxx];
		doublereal rminy5 = ypos[miny];
		doublereal rmaxy5 = ypos[avgy];
		doublereal rminz5 = zpos[avgz];
		doublereal rmaxz5 = zpos[maxz];
		if (b5) {
			//droblenie(xpos, ypos, zpos,
			//inx, iny, inz, oc->link5,
			//minx5, maxx5, miny5, maxy5, minz5, maxz5, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx5;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx5;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny5;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy5;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz5;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz5;

			oc->link5 = new octTree;
			if (oc->link5 == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for oc->link5 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			oc->link5->parent = oc;
			oc->link5->ilevel = oc->ilevel + 1;
			oc->link5->brootSituationX = bSituationX;
			oc->link5->brootSituationY = bSituationY;
			oc->link5->brootSituationZ = bSituationZ;
			oc->link5->root = 5;
			oc->link5->minx = minx5;
			oc->link5->maxx = maxx5;
			oc->link5->miny = miny5;
			oc->link5->maxy = maxy5;
			oc->link5->minz = minz5;
			oc->link5->maxz = maxz5;
			oc->link5->p0.x = rminx5;
			oc->link5->p0.y = rminy5;
			oc->link5->p0.z = rminz5;
			oc->link5->p1.x = rmaxx5;
			oc->link5->p1.y = rminy5;
			oc->link5->p1.z = rminz5;
			oc->link5->p2.x = rmaxx5;
			oc->link5->p2.y = rmaxy5;
			oc->link5->p2.z = rminz5;
			oc->link5->p3.x = rminx5;
			oc->link5->p3.y = rmaxy5;
			oc->link5->p3.z = rminz5;
			oc->link5->p4.x = rminx5;
			oc->link5->p4.y = rminy5;
			oc->link5->p4.z = rmaxz5;
			oc->link5->p5.x = rmaxx5;
			oc->link5->p5.y = rminy5;
			oc->link5->p5.z = rmaxz5;
			oc->link5->p6.x = rmaxx5;
			oc->link5->p6.y = rmaxy5;
			oc->link5->p6.z = rmaxz5;
			oc->link5->p7.x = rminx5;
			oc->link5->p7.y = rmaxy5;
			oc->link5->p7.z = rmaxz5;
			oc->link5->link0 = NULL;
			oc->link5->link1 = NULL;
			oc->link5->link2 = NULL;
			oc->link5->link3 = NULL;
			oc->link5->link4 = NULL;
			oc->link5->link5 = NULL;
			oc->link5->link6 = NULL;
			oc->link5->link7 = NULL;
			// пока соседей просто нету.
			oc->link5->linkW = NULL;
			oc->link5->linkE = NULL;
			oc->link5->linkS = NULL;
			oc->link5->linkN = NULL;
			oc->link5->linkB = NULL;
			oc->link5->linkT = NULL;
			oc->link5->b4W = false;
			oc->link5->b4E = false;
			oc->link5->b4S = false;
			oc->link5->b4N = false;
			oc->link5->b4B = false;
			oc->link5->b4T = false;
			oc->link5->linkW0 = NULL;
			oc->link5->linkW3 = NULL;
			oc->link5->linkW4 = NULL;
			oc->link5->linkW7 = NULL;
			oc->link5->linkE1 = NULL;
			oc->link5->linkE2 = NULL;
			oc->link5->linkE5 = NULL;
			oc->link5->linkE6 = NULL;
			oc->link5->linkS0 = NULL;
			oc->link5->linkS1 = NULL;
			oc->link5->linkS4 = NULL;
			oc->link5->linkS5 = NULL;
			oc->link5->linkN2 = NULL;
			oc->link5->linkN3 = NULL;
			oc->link5->linkN6 = NULL;
			oc->link5->linkN7 = NULL;
			oc->link5->linkB0 = NULL;
			oc->link5->linkB1 = NULL;
			oc->link5->linkB2 = NULL;
			oc->link5->linkB3 = NULL;
			oc->link5->linkT4 = NULL;
			oc->link5->linkT5 = NULL;
			oc->link5->linkT6 = NULL;
			oc->link5->linkT7 = NULL;
			oc->link5->dlist = true;
			oc->link5->b_the_geometric_fragmentation = true;
			oc->link5->maxBsosed = 10000000;
			oc->link5->maxTsosed = 10000000;
			oc->link5->maxSsosed = 10000000;
			oc->link5->maxNsosed = 10000000;
			oc->link5->maxWsosed = 10000000;
			oc->link5->maxEsosed = 10000000;
			oc->link5->maxBsosed = 1;

			if (bSituationY) {
				if (oc->linkN != NULL) {
					if (is_null(oc->linkN)) {
						// 1 остаётся 1.
						oc->link5->maxNsosed = 1;// oc->maxNsosed;
					}
					else if (is_null1(oc->linkN)) {
						// две четверные стороны прилегают друг к дружке.
						oc->link5->maxNsosed = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//oc->link5->maxNsosed = 4;
						oc->link5->maxNsosed = c5;
					}
				}
				else {
					// 0 остаётся 0.
					oc->link5->maxNsosed = 0;// oc->maxNsosed;
				}
			}
			else {
				oc->link5->maxNsosed = 1;
			}
			oc->link5->maxWsosed = 1;


			if (oc->linkE != NULL) {
				if (is_null(oc->linkE)) {
					// 1 остаётся 1.
					oc->link5->maxEsosed = 1;// oc->maxEsosed;
				}
				else if (is_null1(oc->linkE)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link5->maxEsosed = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link5->maxEsosed = 4;
					oc->link5->maxEsosed = c4;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link5->maxEsosed = 0;// oc->maxEsosed;
			}
			if (oc->linkS != NULL) {
				if (is_null(oc->linkS)) {
					// 1 остаётся 1.
					oc->link5->maxSsosed = 1;// oc->maxSsosed;
				}
				else if (is_null1(oc->linkS)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link5->maxSsosed = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link5->maxSsosed = 4;
					oc->link5->maxSsosed = c6;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link5->maxSsosed = 0;// oc->maxSsosed;
			}
			if (oc->linkT != NULL) {
				if (is_null(oc->linkT)) {
					// 1 остаётся 1.
					oc->link5->maxTsosed = 1; // oc->maxTsosed;
				}
				else if (is_null1(oc->linkT)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link5->maxTsosed = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link5->maxTsosed = 4;
					oc->link5->maxTsosed = c1;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link5->maxTsosed = 0;// oc->maxTsosed;
			}
			/*
			// А вот у соседей TSIDE, SSIDE, E количество соседей стало уже 4.
			// чтобы к ним обратится нужна ссылка на эти ячейки.
			// для этого нужна ссылка вврх на шести соседей oc ячейки .
			if (oc->linkT != NULL) {
			oc->linkB->maxBsosed += 4 - 1;
			}
			if (oc->linkS != NULL) {
			oc->linkS->maxNsosed += 4 - 1;
			}
			if (oc->linkE != NULL) {
			oc->linkE->maxWsosed += 4 - 1;
			}
			*/
			my_ALICE_STACK[top_ALICE_STACK].link = oc->link5;
			top_ALICE_STACK++;
		}
		else {
			oc->link5 = NULL;
		}
		integer minx6 = avgx;
		integer maxx6 = maxx;
		integer miny6 = avgy;
		integer maxy6 = maxy;
		integer minz6 = avgz;
		integer maxz6 = maxz;
		doublereal rminx6 = xpos[avgx];
		doublereal rmaxx6 = xpos[maxx];
		doublereal rminy6 = ypos[avgy];
		doublereal rmaxy6 = ypos[maxy];
		doublereal rminz6 = zpos[avgz];
		doublereal rmaxz6 = zpos[maxz];
		if (b6) {
			//droblenie(xpos, ypos, zpos,
			//inx, iny, inz, oc->link6,
			//minx6, maxx6, miny6, maxy6, minz6, maxz6, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx6;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx6;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny6;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy6;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz6;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz6;

			oc->link6 = new octTree;
			if (oc->link6 == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for oc->link6 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			oc->link6->parent = oc;
			oc->link6->ilevel = oc->ilevel + 1;
			oc->link6->brootSituationX = bSituationX;
			oc->link6->brootSituationY = bSituationY;
			oc->link6->brootSituationZ = bSituationZ;
			oc->link6->root = 6;
			oc->link6->minx = minx6;
			oc->link6->maxx = maxx6;
			oc->link6->miny = miny6;
			oc->link6->maxy = maxy6;
			oc->link6->minz = minz6;
			oc->link6->maxz = maxz6;
			oc->link6->p0.x = rminx6;
			oc->link6->p0.y = rminy6;
			oc->link6->p0.z = rminz6;
			oc->link6->p1.x = rmaxx6;
			oc->link6->p1.y = rminy6;
			oc->link6->p1.z = rminz6;
			oc->link6->p2.x = rmaxx6;
			oc->link6->p2.y = rmaxy6;
			oc->link6->p2.z = rminz6;
			oc->link6->p3.x = rminx6;
			oc->link6->p3.y = rmaxy6;
			oc->link6->p3.z = rminz6;
			oc->link6->p4.x = rminx6;
			oc->link6->p4.y = rminy6;
			oc->link6->p4.z = rmaxz6;
			oc->link6->p5.x = rmaxx6;
			oc->link6->p5.y = rminy6;
			oc->link6->p5.z = rmaxz6;
			oc->link6->p6.x = rmaxx6;
			oc->link6->p6.y = rmaxy6;
			oc->link6->p6.z = rmaxz6;
			oc->link6->p7.x = rminx6;
			oc->link6->p7.y = rmaxy6;
			oc->link6->p7.z = rmaxz6;
			oc->link6->link0 = NULL;
			oc->link6->link1 = NULL;
			oc->link6->link2 = NULL;
			oc->link6->link3 = NULL;
			oc->link6->link4 = NULL;
			oc->link6->link5 = NULL;
			oc->link6->link6 = NULL;
			oc->link6->link7 = NULL;
			// пока соседей просто нету.
			oc->link6->linkW = NULL;
			oc->link6->linkE = NULL;
			oc->link6->linkS = NULL;
			oc->link6->linkN = NULL;
			oc->link6->linkB = NULL;
			oc->link6->linkT = NULL;
			oc->link6->b4W = false;
			oc->link6->b4E = false;
			oc->link6->b4S = false;
			oc->link6->b4N = false;
			oc->link6->b4B = false;
			oc->link6->b4T = false;
			oc->link6->linkW0 = NULL;
			oc->link6->linkW3 = NULL;
			oc->link6->linkW4 = NULL;
			oc->link6->linkW7 = NULL;
			oc->link6->linkE1 = NULL;
			oc->link6->linkE2 = NULL;
			oc->link6->linkE5 = NULL;
			oc->link6->linkE6 = NULL;
			oc->link6->linkS0 = NULL;
			oc->link6->linkS1 = NULL;
			oc->link6->linkS4 = NULL;
			oc->link6->linkS5 = NULL;
			oc->link6->linkN2 = NULL;
			oc->link6->linkN3 = NULL;
			oc->link6->linkN6 = NULL;
			oc->link6->linkN7 = NULL;
			oc->link6->linkB0 = NULL;
			oc->link6->linkB1 = NULL;
			oc->link6->linkB2 = NULL;
			oc->link6->linkB3 = NULL;
			oc->link6->linkT4 = NULL;
			oc->link6->linkT5 = NULL;
			oc->link6->linkT6 = NULL;
			oc->link6->linkT7 = NULL;
			oc->link6->dlist = true;
			oc->link6->b_the_geometric_fragmentation = true;
			oc->link6->maxBsosed = 10000000;
			oc->link6->maxTsosed = 10000000;
			oc->link6->maxSsosed = 10000000;
			oc->link6->maxNsosed = 10000000;
			oc->link6->maxWsosed = 10000000;
			oc->link6->maxEsosed = 10000000;

			oc->link6->maxBsosed = 1;
			oc->link6->maxSsosed = 1;
			oc->link6->maxWsosed = 1;


			if (oc->linkE != NULL) {
				if (is_null(oc->linkE)) {
					// 1 остаётся 1.
					oc->link6->maxEsosed = 1;// oc->maxEsosed;
				}
				else if (is_null1(oc->linkE)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link6->maxEsosed = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link6->maxEsosed = 4;
					oc->link6->maxEsosed = c7;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link6->maxEsosed = 0;// oc->maxEsosed;
			}
			if (oc->linkN != NULL) {
				if (is_null(oc->linkN)) {
					// 1 остаётся 1.
					oc->link6->maxNsosed = oc->maxNsosed;
				}
				else if (is_null1(oc->linkN)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link6->maxNsosed = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link6->maxNsosed = 4;
					oc->link6->maxNsosed = c5;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link6->maxNsosed = 0;// oc->maxNsosed;
			}
			if (oc->linkT != NULL) {
				if (is_null(oc->linkT)) {
					// 1 остаётся 1.
					oc->link6->maxTsosed = 1;// oc->maxTsosed;
				}
				else if (is_null1(oc->linkT)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link6->maxTsosed = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link6->maxTsosed = 4;
					oc->link6->maxTsosed = c2;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link6->maxTsosed = 0;// oc->maxTsosed;
			}
			/*
			// А вот у соседей TSIDE, N, E количество соседей стало уже 4.
			// чтобы к ним обратится нужна ссылка на эти ячейки.
			// для этого нужна ссылка вврх на шести соседей oc ячейки .
			if (oc->linkT != NULL) {
			oc->linkT->maxBsosed += 4 - 1;
			}
			if (oc->linkN != NULL) {
			oc->linkN->maxSsosed += 4 - 1;
			}
			if (oc->linkE != NULL) {
			oc->linkE->maxWsosed += 4 - 1;
			}
			*/
			my_ALICE_STACK[top_ALICE_STACK].link = oc->link6;
			top_ALICE_STACK++;
		}
		else {
			oc->link6 = NULL;
		}
		integer minx7 = minx;
		integer maxx7 = avgx;
		integer miny7 = avgy;
		integer maxy7 = maxy;
		integer minz7 = avgz;
		integer maxz7 = maxz;
		doublereal rminx7 = xpos[minx];
		doublereal rmaxx7 = xpos[avgx];
		doublereal rminy7 = ypos[avgy];
		doublereal rmaxy7 = ypos[maxy];
		doublereal rminz7 = zpos[avgz];
		doublereal rmaxz7 = zpos[maxz];
		if (b7) {
			//droblenie(xpos, ypos, zpos,
			//inx, iny, inz, oc->link7,
			//minx7, maxx7, miny7, maxy7, minz7, maxz7, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx7;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx7;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny7;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy7;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz7;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz7;

			oc->link7 = new octTree;
			if (oc->link7 == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for oc->link7 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			oc->link7->parent = oc;
			oc->link7->ilevel = oc->ilevel + 1;
			oc->link7->brootSituationX = bSituationX;
			oc->link7->brootSituationY = bSituationY;
			oc->link7->brootSituationZ = bSituationZ;
			oc->link7->root = 7;
			oc->link7->minx = minx7;
			oc->link7->maxx = maxx7;
			oc->link7->miny = miny7;
			oc->link7->maxy = maxy7;
			oc->link7->minz = minz7;
			oc->link7->maxz = maxz7;

			oc->link7->p0.x = rminx7;
			oc->link7->p0.y = rminy7;
			oc->link7->p0.z = rminz7;
			oc->link7->p1.x = rmaxx7;
			oc->link7->p1.y = rminy7;
			oc->link7->p1.z = rminz7;
			oc->link7->p2.x = rmaxx7;
			oc->link7->p2.y = rmaxy7;
			oc->link7->p2.z = rminz7;
			oc->link7->p3.x = rminx7;
			oc->link7->p3.y = rmaxy7;
			oc->link7->p3.z = rminz7;

			oc->link7->p4.x = rminx7;
			oc->link7->p4.y = rminy7;
			oc->link7->p4.z = rmaxz7;
			oc->link7->p5.x = rmaxx7;
			oc->link7->p5.y = rminy7;
			oc->link7->p5.z = rmaxz7;
			oc->link7->p6.x = rmaxx7;
			oc->link7->p6.y = rmaxy7;
			oc->link7->p6.z = rmaxz7;
			oc->link7->p7.x = rminx7;
			oc->link7->p7.y = rmaxy7;
			oc->link7->p7.z = rmaxz7;
			oc->link7->link0 = NULL;
			oc->link7->link1 = NULL;
			oc->link7->link2 = NULL;
			oc->link7->link3 = NULL;
			oc->link7->link4 = NULL;
			oc->link7->link5 = NULL;
			oc->link7->link6 = NULL;
			oc->link7->link7 = NULL;
			// пока соседей просто нету.
			oc->link7->linkW = NULL;
			oc->link7->linkE = NULL;
			oc->link7->linkS = NULL;
			oc->link7->linkN = NULL;
			oc->link7->linkB = NULL;
			oc->link7->linkT = NULL;
			oc->link7->b4W = false;
			oc->link7->b4E = false;
			oc->link7->b4S = false;
			oc->link7->b4N = false;
			oc->link7->b4B = false;
			oc->link7->b4T = false;
			oc->link7->linkW0 = NULL;
			oc->link7->linkW3 = NULL;
			oc->link7->linkW4 = NULL;
			oc->link7->linkW7 = NULL;
			oc->link7->linkE1 = NULL;
			oc->link7->linkE2 = NULL;
			oc->link7->linkE5 = NULL;
			oc->link7->linkE6 = NULL;
			oc->link7->linkS0 = NULL;
			oc->link7->linkS1 = NULL;
			oc->link7->linkS4 = NULL;
			oc->link7->linkS5 = NULL;
			oc->link7->linkN2 = NULL;
			oc->link7->linkN3 = NULL;
			oc->link7->linkN6 = NULL;
			oc->link7->linkN7 = NULL;
			oc->link7->linkB0 = NULL;
			oc->link7->linkB1 = NULL;
			oc->link7->linkB2 = NULL;
			oc->link7->linkB3 = NULL;
			oc->link7->linkT4 = NULL;
			oc->link7->linkT5 = NULL;
			oc->link7->linkT6 = NULL;
			oc->link7->linkT7 = NULL;
			oc->link7->dlist = true;
			oc->link7->b_the_geometric_fragmentation = true;
			oc->link7->maxBsosed = 10000000;
			oc->link7->maxTsosed = 10000000;
			oc->link7->maxSsosed = 10000000;
			oc->link7->maxNsosed = 10000000;
			oc->link7->maxWsosed = 10000000;
			oc->link7->maxEsosed = 10000000;

			oc->link7->maxBsosed = 1;
			oc->link7->maxSsosed = 1;
			if (bSituationX) {
				if (oc->linkE != NULL) {
					if (is_null(oc->linkE)) {
						// 1 остаётся 1.
						oc->link7->maxEsosed = 1;// oc->maxEsosed;
					}
					else if (is_null1(oc->linkE)) {
						// две четверные стороны прилегают друг к дружке.
						oc->link7->maxEsosed = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//oc->link7->maxEsosed = 4;
						oc->link7->maxEsosed = c7;
					}
				}
				else {
					// 0 остаётся 0.
					oc->link7->maxEsosed = 0;// oc->maxEsosed;
				}
			}
			else {
				oc->link7->maxEsosed = 1;
			}

			if (oc->linkW != NULL) {
				if (is_null(oc->linkW)) {
					// 1 остаётся 1.
					oc->link7->maxWsosed = 1;// oc->maxWsosed;
				}
				else if (is_null1(oc->linkW)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link7->maxWsosed = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link7->maxWsosed = 4;
					oc->link7->maxWsosed = c6;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link7->maxWsosed = 0;// oc->maxWsosed;
			}

			if (oc->linkN != NULL) {
				if (is_null(oc->linkN)) {
					// 1 остаётся 1.
					oc->link7->maxNsosed = 1;// oc->maxNsosed;
				}
				else if (is_null1(oc->linkN)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link7->maxNsosed = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link7->maxNsosed = 4;
					oc->link7->maxNsosed = c4;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link7->maxNsosed = 0;// oc->maxNsosed;
			}
			if (oc->linkT != NULL) {
				if (is_null(oc->linkT)) {
					// 1 остаётся 1.
					oc->link7->maxTsosed = 1;// oc->maxTsosed;
				}
				else if (is_null1(oc->linkT)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link7->maxTsosed = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link7->maxTsosed = 4;
					oc->link7->maxTsosed = c3;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link7->maxTsosed = 0;// oc->maxTsosed;
			}

			/*
			// А вот у соседей TSIDE, N, W количество соседей стало уже 4.
			// чтобы к ним обратится нужна ссылка на эти ячейки.
			// для этого нужна ссылка вврх на шести соседей oc ячейки .
			if (oc->linkT != NULL) {
			oc->linkT->maxBsosed += 4 - 1;
			}
			if (oc->linkN != NULL) {
			oc->linkN->maxSsosed += 4 - 1;
			}
			if (oc->linkW != NULL) {
			oc->linkW->maxEsosed += 4 - 1;
			}
			*/
			my_ALICE_STACK[top_ALICE_STACK].link = oc->link7;
			top_ALICE_STACK++;
		}
		else {
			oc->link7 = NULL;
		}


		// Здесь  предусмотрен случай четырёх соседей по face грани ячейки.
		if (oc->link0 != NULL) {
			if (bSituationZ) {
				if (oc->b4T) {
					oc->link0->linkT = oc->linkT4;
				}
				else {
					oc->link0->linkT = oc->linkT;
				}
			}
			else {
				oc->link0->linkT = oc->link4;
			}
			// Y 0,1,4,5
			if (bSituationY) {
				if (oc->b4N) {
					oc->link0->linkN = oc->linkN3;
				}
				else {
					oc->link0->linkN = oc->linkN;
				}
			}
			else {
				oc->link0->linkN = oc->link3;
			}
			// X 0,3,4,7
			if (bSituationX) {
				if (oc->b4E) {
					oc->link0->linkE = oc->linkE1;
				}
				else {
					oc->link0->linkE = oc->linkE;
				}
			}
			else {
				oc->link0->linkE = oc->link1;
			}

			if (oc->b4B) {
				oc->link0->linkB = oc->linkB0;
			}
			else {
				oc->link0->linkB = oc->linkB;
			}
			if (oc->b4W) {
				oc->link0->linkW = oc->linkW0;
			}
			else {
				oc->link0->linkW = oc->linkW;
			}
			if (oc->b4S) {
				oc->link0->linkS = oc->linkS0;
			}
			else {
				oc->link0->linkS = oc->linkS;
			}
		}
		if (oc->link1 != NULL) {
			if (bSituationZ) {
				if (oc->b4T) {
					oc->link1->linkT = oc->linkT5;
				}
				else {
					oc->link1->linkT = oc->linkT;
				}
			}
			else {
				oc->link1->linkT = oc->link5;
			}
			if (bSituationY) {
				if (oc->b4N) {
					oc->link1->linkN = oc->linkN2;
				}
				else {
					oc->link1->linkN = oc->linkN;
				}
			}
			else {
				oc->link1->linkN = oc->link2;
			}
			oc->link1->linkW = oc->link0;

			if (oc->b4B) {
				oc->link1->linkB = oc->linkB1;
			}
			else {
				oc->link1->linkB = oc->linkB;
			}
			if (oc->b4E) {
				oc->link1->linkE = oc->linkE1;
			}
			else {
				oc->link1->linkE = oc->linkE;
			}
			if (oc->b4S) {
				oc->link1->linkS = oc->linkS1;
			}
			else {
				oc->link1->linkS = oc->linkS;
			}
		}
		if (oc->link2 != NULL) {
			if (bSituationZ) {
				if (oc->b4T) {
					oc->link2->linkT = oc->linkT6;
				}
				else {
					oc->link2->linkT = oc->linkT;
				}
			}
			else {
				oc->link2->linkT = oc->link6;
			}
			oc->link2->linkS = oc->link1;
			oc->link2->linkW = oc->link3;
			if (oc->b4B) {
				oc->link2->linkB = oc->linkB2;
			}
			else {
				oc->link2->linkB = oc->linkB;
			}
			if (oc->b4E) {
				oc->link2->linkE = oc->linkE2;
			}
			else {
				oc->link2->linkE = oc->linkE;
			}
			if (oc->b4N) {
				oc->link2->linkN = oc->linkN2;
			}
			else {
				oc->link2->linkN = oc->linkN;
			}
		}
		if (oc->link3 != NULL) {
			if (bSituationZ) {
				if (oc->b4T) {
					oc->link3->linkT = oc->linkT7;
				}
				else {
					oc->link3->linkT = oc->linkT;
				}
			}
			else {
				oc->link3->linkT = oc->link7;
			}
			oc->link3->linkS = oc->link0;
			if (bSituationX) {
				if (oc->b4E) {
					oc->link3->linkE = oc->linkE2;
				}
				else {
					oc->link3->linkE = oc->linkE;
				}
			}
			else {
				oc->link3->linkE = oc->link2;
			}

			if (oc->b4B) {
				oc->link3->linkB = oc->linkB3;
			}
			else {
				oc->link3->linkB = oc->linkB;
			}
			if (oc->b4W) {
				oc->link3->linkW = oc->linkW3;
			}
			else {
				oc->link3->linkW = oc->linkW;
			}
			if (oc->b4N) {
				oc->link3->linkN = oc->linkN3;
			}
			else {
				oc->link3->linkN = oc->linkN;
			}
		}
		if (oc->link4 != NULL) {
			oc->link4->linkB = oc->link0;
			if (bSituationY) {
				if (oc->b4N) {
					oc->link4->linkN = oc->linkN7;
				}
				else {
					oc->link4->linkN = oc->linkN;
				}
			}
			else {
				oc->link4->linkN = oc->link7;
			}
			if (bSituationX) {
				if (oc->b4E) {
					oc->link4->linkE = oc->linkE5;
				}
				else {
					oc->link4->linkE = oc->linkE;
				}
			}
			else {
				oc->link4->linkE = oc->link5;
			}

			if (oc->b4T) {
				oc->link4->linkT = oc->linkT4;
			}
			else {
				oc->link4->linkT = oc->linkT;
			}
			if (oc->b4W) {
				oc->link4->linkW = oc->linkW4;
			}
			else {
				oc->link4->linkW = oc->linkW;
			}
			if (oc->b4S) {
				oc->link4->linkS = oc->linkS4;
			}
			else {
				oc->link4->linkS = oc->linkS;
			}
		}
		if (oc->link5 != NULL) {
			oc->link5->linkB = oc->link1;
			if (bSituationY) {
				if (oc->b4N) {
					oc->link5->linkN = oc->linkN6;
				}
				else {
					oc->link5->linkN = oc->linkN;
				}
			}
			else {
				oc->link5->linkN = oc->link6;
			}
			oc->link5->linkW = oc->link4;
			if (oc->b4T) {
				oc->link5->linkT = oc->linkT5;
			}
			else {
				oc->link5->linkT = oc->linkT;
			}
			if (oc->b4E) {
				oc->link5->linkE = oc->linkE5;
			}
			else {
				oc->link5->linkE = oc->linkE;
			}
			if (oc->b4S) {
				oc->link5->linkS = oc->linkS5;
			}
			else {
				oc->link5->linkS = oc->linkS;
			}
		}
		if (oc->link6 != NULL) {
			oc->link6->linkB = oc->link2;
			oc->link6->linkS = oc->link5;
			oc->link6->linkW = oc->link7;
			if (oc->b4T) {
				oc->link6->linkT = oc->linkT6;
			}
			else {
				oc->link6->linkT = oc->linkT;
			}
			if (oc->b4E) {
				oc->link6->linkE = oc->linkE6;
			}
			else {
				oc->link6->linkE = oc->linkE;
			}
			if (oc->b4N) {
				oc->link6->linkN = oc->linkN6;
			}
			else {
				oc->link6->linkN = oc->linkN;
			}
		}
		if (oc->link7 != NULL) {
			oc->link7->linkB = oc->link3;
			oc->link7->linkS = oc->link4;
			if (bSituationX) {
				if (oc->b4E) {
					oc->link7->linkE = oc->linkE6;
				}
				else {
					oc->link7->linkE = oc->linkE;
				}
			}
			else {
				oc->link7->linkE = oc->link6;
			}

			if (oc->b4T) {
				oc->link7->linkT = oc->linkT7;
			}
			else {
				oc->link7->linkT = oc->linkT;
			}
			if (oc->b4W) {
				oc->link7->linkW = oc->linkW7;
			}
			else {
				oc->link7->linkW = oc->linkW;
			}
			if (oc->b4N) {
				oc->link7->linkN = oc->linkN7;
			}
			else {
				oc->link7->linkN = oc->linkN;
			}
		}


		if (bSituationZ) {
			// Вырождение по Z
			if (oc->linkB != NULL) {
				if (is_null(oc->linkB)) {
					//oc->linkB->maxTsosed += 4 - 1;
					patch_sosed_count2(oc->linkB->maxTsosed);
				}
				if (is_null1(oc->linkB)) {
					// он представляет собой ячейку делённую на 8 частей.
					oc->linkB->link4->maxTsosed = 1; // 
					oc->linkB->link5->maxTsosed = 1;
					oc->linkB->link6->maxTsosed = 1;
					oc->linkB->link7->maxTsosed = 1;
				}
			}
			if (oc->linkT != NULL) {
				if (is_null(oc->linkT)) {
					//oc->linkT->maxBsosed += 4 - 1;
					patch_sosed_count2(oc->linkT->maxBsosed);
				}
				if (is_null1(oc->linkT)) {
					// он представляет собой ячейку делённую на 8 частей.
					oc->linkT->link0->maxBsosed = 1; // 
					oc->linkT->link1->maxBsosed = 1;
					oc->linkT->link2->maxBsosed = 1;
					oc->linkT->link3->maxBsosed = 1;
				}
			}
		}
		else {
			// Полноценное деление на 8 частей.
			if (b0 || b1 || b2 || b3) {
				if (oc->linkB != NULL) {
					if (is_null(oc->linkB)) {
						//oc->linkB->maxTsosed += 4 - 1;
						patch_sosed_count(oc->linkB->maxTsosed, oc->linkB, TSIDE);
					}
					if (is_null1(oc->linkB)) {
						// он представляет собой ячейку делённую на 8 частей.
						oc->linkB->link4->maxTsosed = 1; // 
						oc->linkB->link5->maxTsosed = 1;
						oc->linkB->link6->maxTsosed = 1;
						oc->linkB->link7->maxTsosed = 1;
					}
				}
			}
			if (b4 || b5 || b6 || b7) {
				if (oc->linkT != NULL) {
					if (is_null(oc->linkT)) {
						//oc->linkT->maxBsosed += 4 - 1;
						patch_sosed_count(oc->linkT->maxBsosed, oc->linkT, BSIDE);
					}
					if (is_null1(oc->linkT)) {
						// он представляет собой ячейку делённую на 8 частей.
						oc->linkT->link0->maxBsosed = 1; // 
						oc->linkT->link1->maxBsosed = 1;
						oc->linkT->link2->maxBsosed = 1;
						oc->linkT->link3->maxBsosed = 1;
					}
				}
			}
		}


		if (bSituationY) {
			if (oc->linkN != NULL) {
				if (is_null(oc->linkN)) {
					//oc->linkN->maxSsosed += 4 - 1;
					patch_sosed_count2(oc->linkN->maxSsosed);
				}
				else if (is_null1(oc->linkN)) {
					// он представляет собой ячейку делённую на 8 частей.
					oc->linkN->link0->maxSsosed = 1; // 
					oc->linkN->link1->maxSsosed = 1;
					oc->linkN->link4->maxSsosed = 1;
					oc->linkN->link5->maxSsosed = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null2(oc->linkN, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					if (oc->linkN != NULL) {
						if (oc->linkN->link0 != NULL) {
							oc->linkN->link0->maxSsosed = 1; // 
						}
						if (oc->linkN->link1 != NULL) {
							oc->linkN->link1->maxSsosed = 1;
						}
						if (oc->linkN->link4 != NULL) {
							oc->linkN->link4->maxSsosed = 1;
						}
						if (oc->linkN->link5 != NULL) {
							oc->linkN->link5->maxSsosed = 1;
						}
					}
				}
			}
			if (oc->linkS != NULL) {
				if (is_null(oc->linkS)) {
					//oc->linkS->maxNsosed += 4 - 1;
					patch_sosed_count2(oc->linkS->maxNsosed);
				}
				else if (is_null1(oc->linkS)) {
					// он представляет собой ячейку делённую на 8 частей.
					oc->linkS->link2->maxNsosed = 1; // 
					oc->linkS->link3->maxNsosed = 1;
					oc->linkS->link6->maxNsosed = 1;
					oc->linkS->link7->maxNsosed = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null2(oc->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					if (oc->linkS != NULL) {
						if (oc->linkS->link2 != NULL) {
							oc->linkS->link2->maxNsosed = 1; //
						}
						if (oc->linkS->link3 != NULL) {
							oc->linkS->link3->maxNsosed = 1;
						}
						if (oc->linkS->link6 != NULL) {
							oc->linkS->link6->maxNsosed = 1;
						}
						if (oc->linkS->link7 != NULL) {
							oc->linkS->link7->maxNsosed = 1;
						}
					}
				}
			}
		}
		else {
			// полноценное дробление на 8.
			if (b2 || b3 || b6 || b7) {
				if (oc->linkN != NULL) {
					if (is_null(oc->linkN)) {
						//oc->linkN->maxSsosed += 4 - 1;
						patch_sosed_count(oc->linkN->maxSsosed, oc->linkN, SSIDE);
					}
				}
				else if (is_null1(oc->linkN)) {
					// он представляет собой ячейку делённую на 8 частей.
					oc->linkN->link0->maxSsosed = 1; // 
					oc->linkN->link1->maxSsosed = 1;
					oc->linkN->link4->maxSsosed = 1;
					oc->linkN->link5->maxSsosed = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null2(oc->linkN, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					if (oc->linkN != NULL) {
						if (oc->linkN->link0 != NULL) {
							oc->linkN->link0->maxSsosed = 1; // 
						}
						if (oc->linkN->link1 != NULL) {
							oc->linkN->link1->maxSsosed = 1;
						}
						if (oc->linkN->link4 != NULL) {
							oc->linkN->link4->maxSsosed = 1;
						}
						if (oc->linkN->link5 != NULL) {
							oc->linkN->link5->maxSsosed = 1;
						}
					}
				}
			}
			if (b0 || b1 || b4 || b5) {
				if (oc->linkS != NULL) {
					if (is_null(oc->linkS)) {
						//oc->linkS->maxNsosed += 4 - 1;
						patch_sosed_count(oc->linkS->maxNsosed, oc->linkS, NSIDE);
					}
					else if (is_null1(oc->linkS)) {
						// он представляет собой ячейку делённую на 8 частей.
						oc->linkS->link2->maxNsosed = 1; // 
						oc->linkS->link3->maxNsosed = 1;
						oc->linkS->link6->maxNsosed = 1;
						oc->linkS->link7->maxNsosed = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null2(oc->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if (oc->linkS != NULL) {
							if (oc->linkS->link2 != NULL) {
								oc->linkS->link2->maxNsosed = 1; //
							}
							if (oc->linkS->link3 != NULL) {
								oc->linkS->link3->maxNsosed = 1;
							}
							if (oc->linkS->link6 != NULL) {
								oc->linkS->link6->maxNsosed = 1;
							}
							if (oc->linkS->link7 != NULL) {
								oc->linkS->link7->maxNsosed = 1;
							}
						}
					}
				}
			}
		}

		if (bSituationX) {
			if (oc->linkW != NULL) {
				if (is_null(oc->linkW)) {
					//oc->linkW->maxEsosed += 4 - 1;
					patch_sosed_count2(oc->linkW->maxEsosed);
				}
				if (is_null1(oc->linkW)) {
					// он представляет собой ячейку делённую на 8 частей.
					oc->linkW->link1->maxEsosed = 1; // 
					oc->linkW->link2->maxEsosed = 1;
					oc->linkW->link5->maxEsosed = 1;
					oc->linkW->link6->maxEsosed = 1;
				}
			}
			if (oc->linkE != NULL) {
				if (is_null(oc->linkE)) {
					//oc->linkE->maxWsosed += 4 - 1;
					patch_sosed_count2(oc->linkE->maxWsosed);
				}
				if (is_null1(oc->linkE)) {
					// он представляет собой ячейку делённую на 8 частей.
					oc->linkE->link0->maxWsosed = 1; // 
					oc->linkE->link3->maxWsosed = 1;
					oc->linkE->link4->maxWsosed = 1;
					oc->linkE->link7->maxWsosed = 1;
				}
			}
		}
		else {
			// полноценное дробление на 8.
			if (b0 || b3 || b4 || b7) {
				if (oc->linkW != NULL) {
					if (is_null(oc->linkW)) {
						//oc->linkW->maxEsosed += 4 - 1;
						patch_sosed_count(oc->linkW->maxEsosed, oc->linkW, ESIDE);
					}
					if (is_null1(oc->linkW)) {
						// он представляет собой ячейку делённую на 8 частей.
						oc->linkW->link1->maxEsosed = 1; // 
						oc->linkW->link2->maxEsosed = 1;
						oc->linkW->link5->maxEsosed = 1;
						oc->linkW->link6->maxEsosed = 1;
					}
				}
			}
			if (b1 || b2 || b5 || b6) {
				if (oc->linkE != NULL) {
					if (is_null(oc->linkE)) {
						//oc->linkE->maxWsosed += 4 - 1;
						patch_sosed_count(oc->linkE->maxWsosed, oc->linkE, WSIDE);
					}
					if (is_null1(oc->linkE)) {
						// он представляет собой ячейку делённую на 8 частей.
						oc->linkE->link0->maxWsosed = 1; // 
						oc->linkE->link3->maxWsosed = 1;
						oc->linkE->link4->maxWsosed = 1;
						oc->linkE->link7->maxWsosed = 1;
					}
				}
			}
		}

	}

} // droblenie_internal

doublereal raspectratio_for_alice(doublereal a, doublereal b, doublereal c) {
	if ((a >= b) && (a >= c)) {
		if (b >= c) return a / c;
		else return a / b;
	}
	else if ((b >= a) && (b >= c)) {
		if (a >= c) return b / c;
		else return b / a;
	}
	else if ((c >= a) && (c >= b)) {
		if (a >= b) return c / b;
		else return c / a;
	}
}

// Модификация правила дробления в этой функции открывает широчайшие настройки 
// генерации сетки т.к. можно добиться самого различного поведения сеточного генератора не трогая его ядро
// а модифицируя лишь эту функцию.
// 28.02.2017 Цилиндры не работоспособны.
integer droblenie(doublereal* xpos, doublereal* ypos, doublereal* zpos,
	integer inx, integer iny, integer inz, octTree* &oc,
	integer minx, integer maxx, integer miny, integer maxy, integer minz, integer maxz,
	BLOCK* &b, integer lb, integer lw, WALL* &w, SOURCE* &s, integer ls, doublereal epsToolx, doublereal epsTooly, doublereal epsToolz) {
	
	// Дробим во всех координатных направлениях.
	bool bdrobimX = true;
	bool bdrobimY = true;
	bool bdrobimZ = true;

	bool bold_stable_version = true;

	
	//oc = new octTree;
	/*
	my_ALICE_STACK[top_ALICE_STACK - 1].minx = minx;
	my_ALICE_STACK[top_ALICE_STACK - 1].maxx = maxx;
	my_ALICE_STACK[top_ALICE_STACK - 1].miny = miny;
	my_ALICE_STACK[top_ALICE_STACK - 1].maxy = maxy;
	my_ALICE_STACK[top_ALICE_STACK - 1].minz = minz;
	my_ALICE_STACK[top_ALICE_STACK - 1].maxz = maxz;
	*/
	oc->p0.x = xpos[minx];
	oc->p0.y = ypos[miny];
	oc->p0.z = zpos[minz];
	oc->p1.x = xpos[maxx];
	oc->p1.y = ypos[miny];
	oc->p1.z = zpos[minz];
	oc->p2.x = xpos[maxx];
	oc->p2.y = ypos[maxy];
	oc->p2.z = zpos[minz];
	oc->p3.x = xpos[minx];
	oc->p3.y = ypos[maxy];
	oc->p3.z = zpos[minz];
	oc->p4.x = xpos[minx];
	oc->p4.y = ypos[miny];
	oc->p4.z = zpos[maxz];
	oc->p5.x = xpos[maxx];
	oc->p5.y = ypos[miny];
	oc->p5.z = zpos[maxz];
	oc->p6.x = xpos[maxx];
	oc->p6.y = ypos[maxy];
	oc->p6.z = zpos[maxz];
	oc->p7.x = xpos[minx];
	oc->p7.y = ypos[maxy];
	oc->p7.z = zpos[maxz];
	oc->dlist = true;
	//doublereal eps = 1.0e-23;

	const bool btgf_mesh_generator = true;

	bool bsimpledefine = true;
	for (integer i1 = 0; i1 < lb; i1++) {
		if (b[i1].g.itypegeom != 0) {
			// есть цилиндры.
			bsimpledefine = false;
		}
	}

	if (btgf_mesh_generator) {
		// Нам нужна максимально разреженная сетка.

		// 6 августа 2017 начало.
		// Нельзя допускать слишком больших клеток в АлИС сетке,
		// т.е. нельзя превышать размер самой начальной супер грубой сетки.
		// Пусть кабинет имеет размеры LCx, LCy, LCz. Самая большая сторона для определённости LCx.
		// Начальная супер грубая сетка это 20клеток по LCx стороне как самой большой и еще 10 клеток по остальным сторонам.
		if (0) {
			doublereal LCx = fabs(xpos[inx] - xpos[0]);
			doublereal LCy = fabs(ypos[iny] - ypos[0]);
			doublereal LCz = fabs(zpos[inz] - zpos[0]);
			if (raspectratio_for_alice(fabs(xpos[maxx] - xpos[minx]), fabs(ypos[maxy] - ypos[miny]), fabs(zpos[maxz] - zpos[minz])) < 30.0) {
				if ((LCx >= LCy) && (LCx >= LCz)) {
					doublereal multy = 1.0 / (10.0 + 10.0*LCy / LCx);
					doublereal multz = 1.0 / (10.0 + 10.0*LCz / LCx);
					if ((fabs(xpos[maxx] - xpos[minx]) > 0.05*LCx) || (fabs(ypos[maxy] - ypos[miny]) > multy*LCy) || (fabs(zpos[maxz] - zpos[minz]) > multz*LCz)) {
						// Слишком большая клетка
						oc->dlist = false; // будем дробить
						goto DROBIM_NOW;
					}
				}
				else if ((LCy >= LCx) && (LCy >= LCz)) {
					doublereal multx = 1.0 / (10.0 + 10.0*LCx / LCy);
					doublereal multz = 1.0 / (10.0 + 10.0*LCz / LCy);
					if ((fabs(ypos[maxy] - ypos[miny]) > 0.05*LCy) || (fabs(xpos[maxx] - xpos[minx]) > multx*LCx) || (fabs(zpos[maxz] - zpos[minz]) > multz*LCz)) {
						// Слишком большая клетка
						oc->dlist = false; // будем дробить
						goto DROBIM_NOW;
					}
				}
				else if ((LCz >= LCx) && (LCz >= LCy)) {
					doublereal multx = 1.0 / (10.0 + 10.0*LCx / LCz);
					doublereal multy = 1.0 / (10.0 + 10.0*LCy / LCz);
					if ((fabs(zpos[maxz] - zpos[minz]) > 0.05*LCz) || (fabs(ypos[maxy] - ypos[miny]) > multy*LCy) || (fabs(xpos[maxx] - xpos[minx]) > multx*LCx)) {
						// Слишком большая клетка
						oc->dlist = false; // будем дробить
						goto DROBIM_NOW;
					}
				}
			}
		}
		// 6 августа 2017 конец.

		// проверяем есть ли дробление
		// на блоках.
		if (1) {
			// Новый алгоритм сканирующих отрезков в части блоков, работающий для любых форм 
			// блоков : прямоугольная призма, цилиндр, полигон. Использует хеш таблицу
			// hash_for_droblenie_xyz[i][j][k]. 17 august 2017.
			// Если внутри ячейки дробления встретилась ситуация смены блоков (граница блоков) то данная 
			// ячейка дробится.
			// Это чрезвычайно простой и эффективный код, в частности за счёт использования заранеее 
			// табулированной хеш таблицы hash_for_droblenie_xyz[i][j][k].

			if (bold_stable_version) {
				int ib83 = hash_for_droblenie_xyz[minx][miny][minz];
				for (integer i = minx; i < maxx; i++) {
					for (integer j = miny; j < maxy; j++) {
						for (integer k = minz; k < maxz; k++) {
							if (ib83 != hash_for_droblenie_xyz[i][j][k]) {
								oc->dlist = false; // будем дробить
								goto DROBIM_NOW;
							}
						}
					}
				}


				bdrobimX = true;
				bdrobimY = true;
				bdrobimZ = true;
			}
			else {
				// Добавляем избирательности при дроблении.

				// 3.01.2017
				// Моя цель - небывалая экономичность АЛИС сетки.
				// Экономичности присуща геометрическая (визуальная) эстетическая привлекательность.
				// Сетка должна выглядеть мелкой только там где это действительно необходимо.
				// Эконоичность - расщепление на три признака дробления. По одному на каждую ось координат.

				bdrobimX = false;
				bdrobimY = false;
				bdrobimZ = false;

				// Мы расщепляем информацию о дроблении на три независимых координатных направляния для лучшей управляемости процесса дробления,
				// с целью достижения его более высокой экономичности.
				int ib83 = hash_for_droblenie_xyz[minx][miny][minz];
				for (integer i = minx; i < maxx; i++) {
					if (!bdrobimZ) {
						for (integer j = miny; j < maxy; j++) {
							if (!bdrobimZ) {
								ib83 = hash_for_droblenie_xyz[i][j][minz];
								for (integer k = minz + 1; k < maxz; k++) {
									if (ib83 != hash_for_droblenie_xyz[i][j][k]) {
										oc->dlist = false; // будем дробить
										bdrobimZ = true; // Надо дробить по направлению оси Oz.
										break;
										//goto DROBIM_NOW;
									}
								}
							}
						}
					}
				}


				ib83 = hash_for_droblenie_xyz[minx][miny][minz];
				for (integer k = minz; k < maxz; k++) {
					if (!bdrobimX) {
						for (integer j = miny; j < maxy; j++) {
							if (!bdrobimX) {
								ib83 = hash_for_droblenie_xyz[minx][j][k];
								for (integer i = minx + 1; i < maxx; i++) {
									if (ib83 != hash_for_droblenie_xyz[i][j][k]) {
										oc->dlist = false; // будем дробить
										bdrobimX = true; // Надо дробить по направлению оси Ox.
										break;
										//goto DROBIM_NOW;
									}
								}
							}
						}
					}
				}

				ib83 = hash_for_droblenie_xyz[minx][miny][minz];
				for (integer k = minz; k < maxz; k++) {
					if (!bdrobimY) {
						for (integer i = minx; i < maxx; i++) {
							if (!bdrobimY) {
								ib83 = hash_for_droblenie_xyz[i][miny][k];
								for (integer j = miny+1; j < maxy; j++) {
									if (ib83 != hash_for_droblenie_xyz[i][j][k]) {
										oc->dlist = false; // будем дробить
										bdrobimY = true; // Надо дробить по направлению оси Oy.
										break;
										//goto DROBIM_NOW;
									}
								}
							}
						}
					}
				}

				if (bdrobimX || bdrobimY || bdrobimZ) {
					goto DROBIM_NOW;
				}
				//bdrobimX = true;
				//bdrobimY = true;
				//bdrobimZ = true;
			}
		}
		else {
			if (1 && bsimpledefine) {
				// Универсальный код для всех сканирующих направлений.
				for (integer i1 = 0; i1 < lb; i1++) {
					if (b[i1].g.itypegeom == 0) {
						// Prism
						/*
						if ( (((xpos[minx] <= b[i1].g.xS)&&(xpos[maxx] >= b[i1].g.xS)) || ((xpos[minx] <= b[i1].g.xE) && (xpos[maxx] >= b[i1].g.xE)) )&& (((ypos[miny] <= b[i1].g.yS) && (ypos[maxy] >= b[i1].g.yS)) || ((ypos[miny] <= b[i1].g.yE) && (ypos[maxy] >= b[i1].g.yE))) && (((zpos[minz] <= b[i1].g.zS) && (zpos[maxz] >= b[i1].g.zS)) || ((zpos[minz] <= b[i1].g.zE) && (zpos[maxz] >= b[i1].g.zE)))) {
							oc->dlist = false; // будем дробить
							goto DROBIM_NOW;
						}
						*/
						doublereal eps_tolerance = 1.0e-25;
						// Oz
						if ((((xpos[maxx] - eps_tolerance > b[i1].g.xS)) && ((xpos[minx] + eps_tolerance < b[i1].g.xE))) && (((ypos[maxy] - eps_tolerance > b[i1].g.yS)) && ((ypos[miny] + eps_tolerance < b[i1].g.yE))) && (((zpos[minz + 1] <= b[i1].g.zS) && (zpos[maxz - 1] >= b[i1].g.zS)) || ((zpos[minz + 1] <= b[i1].g.zE) && (zpos[maxz - 1] >= b[i1].g.zE)))) {
							oc->dlist = false; // будем дробить
							goto DROBIM_NOW;
						}
						// Ox
						if ((((zpos[maxz] - eps_tolerance > b[i1].g.zS)) && ((zpos[minz] + eps_tolerance < b[i1].g.zE))) && (((ypos[maxy] - eps_tolerance > b[i1].g.yS)) && ((ypos[miny] + eps_tolerance < b[i1].g.yE))) && (((xpos[minx + 1] <= b[i1].g.xS) && (xpos[maxx - 1] >= b[i1].g.xS)) || ((xpos[minx + 1] <= b[i1].g.xE) && (xpos[maxx - 1] >= b[i1].g.xE)))) {
							oc->dlist = false; // будем дробить
							goto DROBIM_NOW;
						}
						// Oy
						if ((((zpos[maxz] - eps_tolerance > b[i1].g.zS)) && ((zpos[minz] + eps_tolerance < b[i1].g.zE))) && (((xpos[maxx] - eps_tolerance > b[i1].g.xS)) && ((xpos[minx] + eps_tolerance < b[i1].g.xE))) && (((ypos[miny + 1] <= b[i1].g.yS) && (ypos[maxy - 1] >= b[i1].g.yS)) || ((ypos[miny + 1] <= b[i1].g.yE) && (ypos[maxy - 1] >= b[i1].g.yE)))) {
							oc->dlist = false; // будем дробить
							goto DROBIM_NOW;
						}
					}
				}
			}
			else {

				if (1) {
					// BT
					for (integer i = minx; i < maxx; i++) {
						for (integer j = miny; j < maxy; j++) {
							for (integer k = minz + 1; k < maxz; k++) {
								doublereal xc = 0.5*(xpos[i] + xpos[i + 1]);
								doublereal yc = 0.5*(ypos[j] + ypos[j + 1]);
								doublereal zc = zpos[k];
								for (integer i1 = 0; i1 < lb; i1++) {
									if (b[i1].g.itypegeom == 0) {
										// Prism
										if ((xc > b[i1].g.xS) && (xc < b[i1].g.xE) && (yc > b[i1].g.yS) && (yc < b[i1].g.yE) && ((fabs(b[i1].g.zS - zc) < epsToolz) || (fabs(b[i1].g.zE - zc) < epsToolz))) {
											oc->dlist = false; // будем дробить
											goto DROBIM_NOW;
										}
									}
									if (b[i1].g.itypegeom == 1) {
										// Cylinder
										switch (b[i1].g.iPlane) {
										case XY:
											if (b[i1].g.R_in_cyl < 1.0e-20) {
												if ((sqrt((xc - b[i1].g.xC)*(xc - b[i1].g.xC) + (yc - b[i1].g.yC)*(yc - b[i1].g.yC)) < b[i1].g.R_out_cyl) && ((fabs(b[i1].g.zC - zc) < epsToolz) || (fabs(b[i1].g.zC + b[i1].g.Hcyl - zc) < epsToolz))) {
													oc->dlist = false; // будем дробить
													goto DROBIM_NOW;
												}
											}
											else {
												if ((sqrt((xc - b[i1].g.xC)*(xc - b[i1].g.xC) + (yc - b[i1].g.yC)*(yc - b[i1].g.yC)) < b[i1].g.R_out_cyl) && (sqrt((xc - b[i1].g.xC)*(xc - b[i1].g.xC) + (yc - b[i1].g.yC)*(yc - b[i1].g.yC)) > b[i1].g.R_in_cyl) && ((fabs(b[i1].g.zC - zc) < epsToolz) || (fabs(b[i1].g.zC + b[i1].g.Hcyl - zc) < epsToolz))) {
													oc->dlist = false; // будем дробить
													goto DROBIM_NOW;
												}
											}
											break;
										case XZ:
											if (b[i1].g.R_in_cyl < 1.0e-20) {
												// без внутреннего радиуса.
												if ((yc > b[i1].g.yC) && (yc < b[i1].g.yC + b[i1].g.Hcyl)) {
													if ((xc > b[i1].g.xC - b[i1].g.R_out_cyl) && (xc < b[i1].g.xC + b[i1].g.R_out_cyl)) {
														doublereal hloc = sqrt(b[i1].g.R_out_cyl*b[i1].g.R_out_cyl - (b[i1].g.xC - xc)*(b[i1].g.xC - xc));
														if ((fabs(zc - (b[i1].g.zC + hloc)) < epsToolz) || (fabs(zc + (b[i1].g.zC + hloc)) < epsToolz)) {
															oc->dlist = false; // будем дробить
															goto DROBIM_NOW;
														}
													}
												}
											}
											else {
												// С внутренним радиусом.

											}
											break;
										case YZ:
											if (b[i1].g.R_in_cyl < 1.0e-20) {
												// без внутреннего радиуса.
												if ((xc > b[i1].g.xC) && (xc < b[i1].g.xC + b[i1].g.Hcyl)) {
													if ((yc > b[i1].g.yC - b[i1].g.R_out_cyl) && (yc < b[i1].g.yC + b[i1].g.R_out_cyl)) {
														doublereal hloc = sqrt(b[i1].g.R_out_cyl*b[i1].g.R_out_cyl - (b[i1].g.yC - yc)*(b[i1].g.yC - yc));
														if ((fabs(zc - (b[i1].g.zC + hloc)) < epsToolz) || (fabs(zc + (b[i1].g.zC + hloc)) < epsToolz)) {
															oc->dlist = false; // будем дробить
															goto DROBIM_NOW;
														}
													}
												}
											}
											else {
												// С внутренним радиусом.

											}
											break;
										}
									}
								}
							}
						}
					}
				}

				// WE
				for (integer i = minx + 1; i < maxx; i++) {
					for (integer j = miny; j < maxy; j++) {
						for (integer k = minz; k < maxz; k++) {
							doublereal xc = xpos[i];
							doublereal yc = 0.5*(ypos[j] + ypos[j + 1]);
							doublereal zc = 0.5*(zpos[k] + zpos[k + 1]);
							for (integer i1 = 0; i1 < lb; i1++) {
								if (b[i1].g.itypegeom == 0) {
									// Prism
									if ((zc > b[i1].g.zS) && (zc < b[i1].g.zE) && (yc > b[i1].g.yS) && (yc < b[i1].g.yE) && ((fabs(b[i1].g.xS - xc) < epsToolx) || (fabs(b[i1].g.xE - xc) < epsToolx))) {
										oc->dlist = false; // будем дробить
										goto DROBIM_NOW;
									}
								}
								if (b[i1].g.itypegeom == 1) {
									// Cylinder
									switch (b[i1].g.iPlane) {
									case XY:
										if (b[i1].g.R_in_cyl < 1.0e-20) {
											// без внутреннего радиуса.
											if ((zc > b[i1].g.zC) && (zc < b[i1].g.zC + b[i1].g.Hcyl)) {
												if ((yc > b[i1].g.yC - b[i1].g.R_out_cyl) && (yc < b[i1].g.yC + b[i1].g.R_out_cyl)) {
													doublereal hloc = sqrt(b[i1].g.R_out_cyl*b[i1].g.R_out_cyl - (b[i1].g.yC - yc)*(b[i1].g.yC - yc));
													if ((fabs(xc - (b[i1].g.xC + hloc)) < epsToolz) || (fabs(xc + (b[i1].g.xC + hloc)) < epsToolz)) {
														oc->dlist = false; // будем дробить
														goto DROBIM_NOW;
													}
												}
											}
										}
										else {
											// С внутренним радиусом.

										}
										break;
									case XZ:
										if (b[i1].g.R_in_cyl < 1.0e-20) {
											// без внутреннего радиуса.
											if ((yc > b[i1].g.yC) && (yc < b[i1].g.yC + b[i1].g.Hcyl)) {
												if ((zc > b[i1].g.zC - b[i1].g.R_out_cyl) && (zc < b[i1].g.zC + b[i1].g.R_out_cyl)) {
													doublereal hloc = sqrt(b[i1].g.R_out_cyl*b[i1].g.R_out_cyl - (b[i1].g.zC - zc)*(b[i1].g.zC - zc));
													if ((fabs(xc - (b[i1].g.xC + hloc)) < epsToolz) || (fabs(xc + (b[i1].g.xC + hloc)) < epsToolz)) {
														oc->dlist = false; // будем дробить
														goto DROBIM_NOW;
													}
												}
											}
										}
										else {
											// С внутренним радиусом.

										}
										break;
									case YZ:
										if (b[i1].g.R_in_cyl < 1.0e-20) {
											if ((sqrt((zc - b[i1].g.zC)*(zc - b[i1].g.zC) + (yc - b[i1].g.yC)*(yc - b[i1].g.yC)) < b[i1].g.R_out_cyl) && ((fabs(b[i1].g.xC - xc) < epsToolz) || (fabs(b[i1].g.xC + b[i1].g.Hcyl - xc) < epsToolz))) {
												oc->dlist = false; // будем дробить
												goto DROBIM_NOW;
											}
										}
										else {
											if ((sqrt((zc - b[i1].g.zC)*(zc - b[i1].g.zC) + (yc - b[i1].g.yC)*(yc - b[i1].g.yC)) < b[i1].g.R_out_cyl) && (sqrt((zc - b[i1].g.zC)*(zc - b[i1].g.zC) + (yc - b[i1].g.yC)*(yc - b[i1].g.yC)) > b[i1].g.R_in_cyl) && ((fabs(b[i1].g.xC - xc) < epsToolz) || (fabs(b[i1].g.xC + b[i1].g.Hcyl - xc) < epsToolz))) {
												oc->dlist = false; // будем дробить
												goto DROBIM_NOW;
											}
										}
										break;
									}
								}
							}
						}
					}
				}
				// SN
				for (integer i = minx; i < maxx; i++) {
					for (integer j = miny + 1; j < maxy; j++) {
						for (integer k = minz; k < maxz; k++) {
							doublereal xc = 0.5*(xpos[i] + xpos[i + 1]);
							doublereal yc = ypos[j];
							doublereal zc = 0.5*(zpos[k] + zpos[k + 1]);
							for (integer i1 = 0; i1 < lb; i1++) {
								if (b[i1].g.itypegeom == 0) {
									// Prism
									if ((zc > b[i1].g.zS) && (zc < b[i1].g.zE) && (xc > b[i1].g.xS) && (xc < b[i1].g.xE) && ((fabs(b[i1].g.yS - yc) < epsTooly) || (fabs(b[i1].g.yE - yc) < epsTooly))) {
										oc->dlist = false; // будем дробить
										goto DROBIM_NOW;
									}
								}
								if (b[i1].g.itypegeom == 1) {
									// Cylinder
									switch (b[i1].g.iPlane) {
									case XY:

										break;
									case XZ:
										if (b[i1].g.R_in_cyl < 1.0e-20) {
											if ((sqrt((xc - b[i1].g.xC)*(xc - b[i1].g.xC) + (zc - b[i1].g.zC)*(zc - b[i1].g.zC)) < b[i1].g.R_out_cyl) && ((fabs(b[i1].g.yC - yc) < epsToolz) || (fabs(b[i1].g.yC + b[i1].g.Hcyl - yc) < epsToolz))) {
												oc->dlist = false; // будем дробить
												goto DROBIM_NOW;
											}
										}
										else {
											if ((sqrt((xc - b[i1].g.xC)*(xc - b[i1].g.xC) + (zc - b[i1].g.zC)*(zc - b[i1].g.zC)) < b[i1].g.R_out_cyl) && (sqrt((xc - b[i1].g.xC)*(xc - b[i1].g.xC) + (zc - b[i1].g.zC)*(zc - b[i1].g.zC)) > b[i1].g.R_in_cyl) && ((fabs(b[i1].g.yC - yc) < epsToolz) || (fabs(b[i1].g.yC + b[i1].g.Hcyl - yc) < epsToolz))) {
												oc->dlist = false; // будем дробить
												goto DROBIM_NOW;
											}
										}

										break;
									case YZ:
										break;
									}
								}
							}
						}
					}
				}
			}
		}
	}
	else {
		// проверяем есть ли дробление
		// на блоках.
		// BT
		for (integer i = minx; i < maxx; i++) {
			for (integer j = miny; j < maxy; j++) {
				for (integer k = minz; k <= maxz; k++) {
					doublereal xc = 0.5*(xpos[i] + xpos[i + 1]);
					doublereal yc = 0.5*(ypos[j] + ypos[j + 1]);
					doublereal zc = zpos[k];
					for (integer i1 = 0; i1 < lb; i1++) {
						if ((xc >= b[i1].g.xS - epsToolx) && (xc <= b[i1].g.xE + epsToolx) && (yc >= b[i1].g.yS - epsTooly) && (yc <= b[i1].g.yE + epsTooly) && ((fabs(b[i1].g.zS - zc) < epsToolz) || (fabs(b[i1].g.zE - zc) < epsToolz))) {
							oc->dlist = false; // будем дробить
							goto DROBIM_NOW;
						}
					}
				}
			}
		}
		// WE
		for (integer i = minx; i <= maxx; i++) {
			for (integer j = miny; j < maxy; j++) {
				for (integer k = minz; k < maxz; k++) {
					doublereal xc = xpos[i];
					doublereal yc = 0.5*(ypos[j] + ypos[j + 1]);
					doublereal zc = 0.5*(zpos[k] + zpos[k + 1]);
					for (integer i1 = 0; i1 < lb; i1++) {
						if ((zc >= b[i1].g.zS - epsToolz) && (zc <= b[i1].g.zE + epsToolz) && (yc >= b[i1].g.yS - epsTooly) && (yc <= b[i1].g.yE + epsTooly) && ((fabs(b[i1].g.xS - xc) < epsToolx) || (fabs(b[i1].g.xE - xc) < epsToolx))) {
							oc->dlist = false; // будем дробить
							goto DROBIM_NOW;
						}
					}
				}
			}
		}
		// SN
		for (integer i = minx; i < maxx; i++) {
			for (integer j = miny; j <= maxy; j++) {
				for (integer k = minz; k < maxz; k++) {
					doublereal xc = 0.5*(xpos[i] + xpos[i + 1]);
					doublereal yc = ypos[j];
					doublereal zc = 0.5*(zpos[k] + zpos[k + 1]);
					for (integer i1 = 0; i1 < lb; i1++) {
						if ((zc >= b[i1].g.zS - epsToolz) && (zc <= b[i1].g.zE + epsToolz) && (xc >= b[i1].g.xS - epsToolx) && (xc <= b[i1].g.xE + epsToolx) && ((fabs(b[i1].g.yS - yc) < epsTooly) || (fabs(b[i1].g.yE - yc) < epsTooly))) {
							oc->dlist = false; // будем дробить
							goto DROBIM_NOW;
						}
					}
				}
			}
		}
	}


	if (!btgf_mesh_generator) {
		

		// проверяем есть ли дробление
		// на стенках.
		// BT
		for (integer i = minx; i < maxx; i++) {
			for (integer j = miny; j < maxy; j++) {
				//for (integer k = minz + 1; k < maxz; k++) {
				for (integer k = minz; k <= maxz; k++) {
					doublereal xc = 0.5*(xpos[i] + xpos[i + 1]);
					doublereal yc = 0.5*(ypos[j] + ypos[j + 1]);
					doublereal zc = zpos[k];
					for (integer i1 = 0; i1 < lw; i1++) {
						if ((xc>w[i1].g.xS - epsToolx) && (xc<w[i1].g.xE + epsToolx) && (yc>w[i1].g.yS - epsTooly) && (yc < w[i1].g.yE + epsTooly) && ((fabs(w[i1].g.zS - zc) < epsToolz) || (fabs(w[i1].g.zE - zc) < epsToolz))) {
							oc->dlist = false; // будем дробить
							goto DROBIM_NOW;
						}
					}
				}
			}
		}
		// WE
		//for (integer i = minx + 1; i < maxx; i++) {
		for (integer i = minx; i <= maxx; i++) {
			for (integer j = miny; j < maxy; j++) {
				for (integer k = minz; k < maxz; k++) {
					doublereal xc = xpos[i];
					doublereal yc = 0.5*(ypos[j] + ypos[j + 1]);
					doublereal zc = 0.5*(zpos[k] + zpos[k + 1]);
					for (integer i1 = 0; i1 < lw; i1++) {
						if ((zc>w[i1].g.zS - epsToolz) && (zc<w[i1].g.zE + epsToolz) && (yc>w[i1].g.yS - epsTooly) && (yc < w[i1].g.yE + epsTooly) && ((fabs(w[i1].g.xS - xc) < epsToolx) || (fabs(w[i1].g.xE - xc) < epsToolx))) {
							oc->dlist = false; // будем дробить
							goto DROBIM_NOW;
						}
					}
				}
			}
		}
		// SN
		for (integer i = minx; i < maxx; i++) {
			//for (integer j = miny + 1; j < maxy; j++) {
			for (integer j = miny; j <= maxy; j++) {
				for (integer k = minz; k < maxz; k++) {
					doublereal xc = 0.5*(xpos[i] + xpos[i + 1]);
					doublereal yc = ypos[j];
					doublereal zc = 0.5*(zpos[k] + zpos[k + 1]);
					for (integer i1 = 0; i1 < lw; i1++) {
						if ((zc>w[i1].g.zS - epsToolz) && (zc<w[i1].g.zE + epsToolz) && (xc>w[i1].g.xS - epsToolx) && (xc < w[i1].g.xE + epsToolx) && ((fabs(w[i1].g.yS - yc) < epsTooly) || (fabs(w[i1].g.yE - yc) < epsTooly))) {
							oc->dlist = false; // будем дробить
							goto DROBIM_NOW;
						}
					}
				}
			}
		}
	}
	else {
		// В tgf серии задач стенка есть нижняя граница кабинета, дно МД40 корпуса и 
		// там не нужна очень подробная расчётная сетка.
		// Мы предполагаем, что других стенок пользователь не использует.
	}

	if (bsimpledefine) {
		// Универсальный код для всех сканирующих направлений.
		for (integer i1 = 0; i1 < ls; i1++) {
			
			// Source
			if (bold_stable_version) {
				bdrobimX = true;
				bdrobimY = true;
				bdrobimZ = true;

				doublereal eps_tolerance = 1.0e-25;
				// Oz
				if ((((xpos[maxx] - eps_tolerance > s[i1].g.xS)) && ((xpos[minx] + eps_tolerance < s[i1].g.xE))) && (((ypos[maxy] - eps_tolerance > s[i1].g.yS)) && ((ypos[miny] + eps_tolerance < s[i1].g.yE))) && (((zpos[minz] <= s[i1].g.zS) && (zpos[maxz] >= s[i1].g.zS)) || ((zpos[minz] <= s[i1].g.zE) && (zpos[maxz] >= s[i1].g.zE)))) {
					oc->dlist = false; // будем дробить
					goto DROBIM_NOW;
				}
				// Ox
				if ((((zpos[maxz] - eps_tolerance > s[i1].g.zS)) && ((zpos[minz] + eps_tolerance < s[i1].g.zE))) && (((ypos[maxy] - eps_tolerance > s[i1].g.yS)) && ((ypos[miny] + eps_tolerance < s[i1].g.yE))) && (((xpos[minx] <= s[i1].g.xS) && (xpos[maxx] >= s[i1].g.xS)) || ((xpos[minx] <= s[i1].g.xE) && (xpos[maxx] >= s[i1].g.xE)))) {
					oc->dlist = false; // будем дробить
					goto DROBIM_NOW;
				}
				// Oy
				if ((((zpos[maxz] - eps_tolerance > s[i1].g.zS)) && ((zpos[minz] + eps_tolerance < s[i1].g.zE))) && (((xpos[maxx] - eps_tolerance > s[i1].g.xS)) && ((xpos[minx] + eps_tolerance < s[i1].g.xE))) && (((ypos[miny] <= s[i1].g.yS) && (ypos[maxy] >= s[i1].g.yS)) || ((ypos[miny] <= s[i1].g.yE) && (ypos[maxy] >= s[i1].g.yE)))) {
					oc->dlist = false; // будем дробить
					goto DROBIM_NOW;
				}


			}
			else {
				doublereal eps_tolerance = 1.0e-25;
				// Oz
				if ((((xpos[maxx] - eps_tolerance > s[i1].g.xS)) && ((xpos[minx] + eps_tolerance < s[i1].g.xE))) && (((ypos[maxy] - eps_tolerance > s[i1].g.yS)) && ((ypos[miny] + eps_tolerance < s[i1].g.yE))) && (((zpos[minz] <= s[i1].g.zS) && (zpos[maxz] >= s[i1].g.zS)) || ((zpos[minz] <= s[i1].g.zE) && (zpos[maxz] >= s[i1].g.zE)))) {
					oc->dlist = false; // будем дробить
					bdrobimX = true;
					break;
					//goto DROBIM_NOW;
				}
				// Ox
				if ((((zpos[maxz] - eps_tolerance > s[i1].g.zS)) && ((zpos[minz] + eps_tolerance < s[i1].g.zE))) && (((ypos[maxy] - eps_tolerance > s[i1].g.yS)) && ((ypos[miny] + eps_tolerance < s[i1].g.yE))) && (((xpos[minx] <= s[i1].g.xS) && (xpos[maxx] >= s[i1].g.xS)) || ((xpos[minx] <= s[i1].g.xE) && (xpos[maxx] >= s[i1].g.xE)))) {
					oc->dlist = false; // будем дробить
					bdrobimY = true;
					break;
					//goto DROBIM_NOW;
				}
				// Oy
				if ((((zpos[maxz] - eps_tolerance > s[i1].g.zS)) && ((zpos[minz] + eps_tolerance < s[i1].g.zE))) && (((xpos[maxx] - eps_tolerance > s[i1].g.xS)) && ((xpos[minx] + eps_tolerance < s[i1].g.xE))) && (((ypos[miny] <= s[i1].g.yS) && (ypos[maxy] >= s[i1].g.yS)) || ((ypos[miny] <= s[i1].g.yE) && (ypos[maxy] >= s[i1].g.yE)))) {
					oc->dlist = false; // будем дробить
					bdrobimZ = true;
					break;
					//goto DROBIM_NOW;
				}

				if (bdrobimX || bdrobimY || bdrobimZ) {
					goto DROBIM_NOW;
				}

			}
			
		}
	}
	else {

		if (bold_stable_version) {
			bdrobimX = true;
			bdrobimY = true;
			bdrobimZ = true;

			// проверяем есть ли дробление
			// на источниках тепла.
			// BT
			for (integer i = minx; i < maxx; i++) {
				for (integer j = miny; j < maxy; j++) {
					//for (integer k = minz + 1; k < maxz; k++) {
					for (integer k = minz; k <= maxz; k++) {
						doublereal xc = 0.5*(xpos[i] + xpos[i + 1]);
						doublereal yc = 0.5*(ypos[j] + ypos[j + 1]);
						doublereal zc = zpos[k];
						for (integer i1 = 0; i1 < ls; i1++) {
							if ((xc > s[i1].g.xS - epsToolx) && (xc < s[i1].g.xE + epsToolx) && (yc > s[i1].g.yS - epsTooly) && (yc < s[i1].g.yE + epsTooly) && ((fabs(s[i1].g.zS - zc) < epsToolz) || (fabs(s[i1].g.zE - zc) < epsToolz))) {
								oc->dlist = false; // будем дробить
								goto DROBIM_NOW;
							}
						}
					}
				}
			}
			// WE
			//for (integer i = minx + 1; i < maxx; i++) {
			for (integer i = minx; i <= maxx; i++) {
				for (integer j = miny; j < maxy; j++) {
					for (integer k = minz; k < maxz; k++) {
						doublereal xc = xpos[i];
						doublereal yc = 0.5*(ypos[j] + ypos[j + 1]);
						doublereal zc = 0.5*(zpos[k] + zpos[k + 1]);
						for (integer i1 = 0; i1 < ls; i1++) {
							if ((zc > s[i1].g.zS - epsToolz) && (zc < s[i1].g.zE + epsToolz) && (yc > s[i1].g.yS - epsTooly) && (yc < s[i1].g.yE + epsTooly) && ((fabs(s[i1].g.xS - xc) < epsToolx) || (fabs(s[i1].g.xE - xc) < epsToolx))) {
								oc->dlist = false; // будем дробить
								goto DROBIM_NOW;
							}
						}
					}
				}
			}
			// SN
			for (integer i = minx; i < maxx; i++) {
				//for (integer j = miny + 1; j < maxy; j++) {
				for (integer j = miny; j <= maxy; j++) {
					for (integer k = minz; k < maxz; k++) {
						doublereal xc = 0.5*(xpos[i] + xpos[i + 1]);
						doublereal yc = ypos[j];
						doublereal zc = 0.5*(zpos[k] + zpos[k + 1]);
						for (integer i1 = 0; i1 < ls; i1++) {
							if ((zc > s[i1].g.zS - epsToolz) && (zc < s[i1].g.zE + epsToolz) && (xc > s[i1].g.xS - epsToolx) && (xc < s[i1].g.xE + epsToolx) && ((fabs(s[i1].g.yS - yc) < epsTooly) || (fabs(s[i1].g.yE - yc) < epsTooly))) {
								oc->dlist = false; // будем дробить
								goto DROBIM_NOW;
							}
						}
					}
				}
			}
		}
		else {

			// проверяем есть ли дробление
			// на источниках тепла.
			// BT
			for (integer i = minx; i < maxx; i++) {
				for (integer j = miny; j < maxy; j++) {
					//for (integer k = minz + 1; k < maxz; k++) {
					for (integer k = minz; k <= maxz; k++) {
						doublereal xc = 0.5*(xpos[i] + xpos[i + 1]);
						doublereal yc = 0.5*(ypos[j] + ypos[j + 1]);
						doublereal zc = zpos[k];
						for (integer i1 = 0; i1 < ls; i1++) {
							if ((xc > s[i1].g.xS - epsToolx) && (xc < s[i1].g.xE + epsToolx) && (yc > s[i1].g.yS - epsTooly) && (yc < s[i1].g.yE + epsTooly) && ((fabs(s[i1].g.zS - zc) < epsToolz) || (fabs(s[i1].g.zE - zc) < epsToolz))) {
								oc->dlist = false; // будем дробить
								bdrobimZ = true;
								//goto DROBIM_NOW;
								break;
							}
						}
					}
				}
			}
			// WE
			//for (integer i = minx + 1; i < maxx; i++) {
			for (integer i = minx; i <= maxx; i++) {
				for (integer j = miny; j < maxy; j++) {
					for (integer k = minz; k < maxz; k++) {
						doublereal xc = xpos[i];
						doublereal yc = 0.5*(ypos[j] + ypos[j + 1]);
						doublereal zc = 0.5*(zpos[k] + zpos[k + 1]);
						for (integer i1 = 0; i1 < ls; i1++) {
							if ((zc > s[i1].g.zS - epsToolz) && (zc < s[i1].g.zE + epsToolz) && (yc > s[i1].g.yS - epsTooly) && (yc < s[i1].g.yE + epsTooly) && ((fabs(s[i1].g.xS - xc) < epsToolx) || (fabs(s[i1].g.xE - xc) < epsToolx))) {
								oc->dlist = false; // будем дробить
								bdrobimX = true;
								//goto DROBIM_NOW;
								break;
							}
						}
					}
				}
			}
			// SN
			for (integer i = minx; i < maxx; i++) {
				//for (integer j = miny + 1; j < maxy; j++) {
				for (integer j = miny; j <= maxy; j++) {
					for (integer k = minz; k < maxz; k++) {
						doublereal xc = 0.5*(xpos[i] + xpos[i + 1]);
						doublereal yc = ypos[j];
						doublereal zc = 0.5*(zpos[k] + zpos[k + 1]);
						for (integer i1 = 0; i1 < ls; i1++) {
							if ((zc > s[i1].g.zS - epsToolz) && (zc < s[i1].g.zE + epsToolz) && (xc > s[i1].g.xS - epsToolx) && (xc < s[i1].g.xE + epsToolx) && ((fabs(s[i1].g.yS - yc) < epsTooly) || (fabs(s[i1].g.yE - yc) < epsTooly))) {
								oc->dlist = false; // будем дробить
								bdrobimY = true;
								//goto DROBIM_NOW;
								break;
							}
						}
					}
				}
			}

			if (bdrobimX || bdrobimY || bdrobimZ) {
				goto DROBIM_NOW;
			}

		}
	}
	
DROBIM_NOW:

	integer  iret = 0;

	if (bVerySimpleGeometryforALICE&&oc->dlist) {
		// 21.01.2018.
		// Исключительная ситуация: расчётная область состоит из кубика по размерам Cabinet и не содержит внутри внутренних перегородок.
		// Мы принимаем решение дробить такую ситуацию до достижения структурированной сетки.
		// Структурированная сетка чвляется частным случаем АЛИС сетки.

		if ((minx == maxx - 1) && (miny == maxy - 1) && (minz == maxz - 1)) {
			// Достигнут уровень первоначальной расчётной сетки.


			//getchar();
			// лист.
			// minx, maxx, miny, maxy, minz, maxz
			// Количество соседей по видимому правильно посчитано прежде.
			oc->p0.x = xpos[minx];
			oc->p0.y = ypos[miny];
			oc->p0.z = zpos[minz];
			oc->p1.x = xpos[maxx];
			oc->p1.y = ypos[miny];
			oc->p1.z = zpos[minz];
			oc->p2.x = xpos[maxx];
			oc->p2.y = ypos[maxy];
			oc->p2.z = zpos[minz];
			oc->p3.x = xpos[minx];
			oc->p3.y = ypos[maxy];
			oc->p3.z = zpos[minz];
			oc->p4.x = xpos[minx];
			oc->p4.y = ypos[miny];
			oc->p4.z = zpos[maxz];
			oc->p5.x = xpos[maxx];
			oc->p5.y = ypos[miny];
			oc->p5.z = zpos[maxz];
			oc->p6.x = xpos[maxx];
			oc->p6.y = ypos[maxy];
			oc->p6.z = zpos[maxz];
			oc->p7.x = xpos[minx];
			oc->p7.y = ypos[maxy];
			oc->p7.z = zpos[maxz];
			oc->link0 = NULL;
			oc->link1 = NULL;
			oc->link2 = NULL;
			oc->link3 = NULL;
			oc->link4 = NULL;
			oc->link5 = NULL;
			oc->link6 = NULL;
			oc->link7 = NULL;
			//oc->b_the_geometric_fragmentation = false;
			// Исправлено 31.08.2016
			// Он обязательно лист, но лист который геометрически не дробится на части.
			// этот лист должен дробится при балансировке !!!
			oc->dlist = true;


		}
		else {

			oc->dlist = false;
			bdrobimX = true;
			bdrobimY = true;
			bdrobimZ = true;

			// Данное дробление вызвано чисто геометрической причиной и это
			// никак не дробление балансировки.
			const bool b_crushing_when_balancing_now = false;
			droblenie_internal(oc, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret, b_crushing_when_balancing_now, bdrobimX, bdrobimY, bdrobimZ);
		}
	}
	else {

		bVerySimpleGeometryforALICE = false;

		if (!oc->dlist) {
			// Данное дробление вызвано чисто геометрической причиной и это
			// никак не дробление балансировки.
			const bool b_crushing_when_balancing_now = false;
			droblenie_internal(oc, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret, b_crushing_when_balancing_now, bdrobimX, bdrobimY, bdrobimZ);
		}
		else {
			// Эта ячейка уже была создана до этого момента (память уже была выделена),
			// поэтому мы просто не трогаем эту ячейку в плане соседства в данном месте кода.

			/*
			//printf("list popal\n");
			integer i_X, i_Y, i_Z;
			if (oc->brootSituationX) {
				i_X = 1;
			}
			else {
				i_X = 0;
			}
			if (oc->brootSituationY) {
				i_Y = 1;
			}
			else {
				i_Y = 0;
			}
			if (oc->brootSituationZ) {
				i_Z = 1;
			}
			else {
				i_Z = 0;
			}
			integer i_X1, i_Y1, i_Z1;

			if (oc->parent->minx + 1 == oc->parent->maxx) {
				i_X1 = 1;
			}
			else {
				i_X1 = 0;
			}
			if (oc->parent->miny + 1 == oc->parent->maxx) {
				i_Y1 = 1;
			}
			else {
				i_Y1 = 0;
			}
			if (oc->parent->minz + 1 == oc->parent->maxz) {
				i_Z1 = 1;
			}
			else {
				i_Z1 = 0;
			}
			*/
#if doubleintprecision == 1
			//printf("root=%lld ilevel=%lld\n",oc->root,oc->ilevel);
			//printf("E=%lld W=%lld N=%lld S=%lld T=%lld B=%lld\n", oc->maxEsosed, oc->maxWsosed, oc->maxNsosed, oc->maxSsosed, oc->maxTsosed, oc->maxBsosed);
			//printf("X=%lld Y=%lld Z=%lld %lld %lld %lld \n", i_X, i_Y, i_Z, i_X1, i_Y1, i_Z1);
#else
			//printf("root=%d ilevel=%d\n",oc->root,oc->ilevel);
			//printf("E=%d W=%d N=%d S=%d T=%d B=%d\n", oc->maxEsosed, oc->maxWsosed, oc->maxNsosed, oc->maxSsosed, oc->maxTsosed, oc->maxBsosed);
			//printf("X=%d Y=%d Z=%d %d %d %d \n", i_X, i_Y, i_Z, i_X1, i_Y1, i_Z1);
#endif
		//getchar();
		// лист.
		// minx, maxx, miny, maxy, minz, maxz
		// Количество соседей по видимому правильно посчитано прежде.
			oc->p0.x = xpos[minx];
			oc->p0.y = ypos[miny];
			oc->p0.z = zpos[minz];
			oc->p1.x = xpos[maxx];
			oc->p1.y = ypos[miny];
			oc->p1.z = zpos[minz];
			oc->p2.x = xpos[maxx];
			oc->p2.y = ypos[maxy];
			oc->p2.z = zpos[minz];
			oc->p3.x = xpos[minx];
			oc->p3.y = ypos[maxy];
			oc->p3.z = zpos[minz];
			oc->p4.x = xpos[minx];
			oc->p4.y = ypos[miny];
			oc->p4.z = zpos[maxz];
			oc->p5.x = xpos[maxx];
			oc->p5.y = ypos[miny];
			oc->p5.z = zpos[maxz];
			oc->p6.x = xpos[maxx];
			oc->p6.y = ypos[maxy];
			oc->p6.z = zpos[maxz];
			oc->p7.x = xpos[minx];
			oc->p7.y = ypos[maxy];
			oc->p7.z = zpos[maxz];
			oc->link0 = NULL;
			oc->link1 = NULL;
			oc->link2 = NULL;
			oc->link3 = NULL;
			oc->link4 = NULL;
			oc->link5 = NULL;
			oc->link6 = NULL;
			oc->link7 = NULL;
			//oc->b_the_geometric_fragmentation = false;
			// Исправлено 31.08.2016
			// Он обязательно лист, но лист который геометрически не дробится на части.
			// этот лист должен дробится при балансировке !!!
			oc->dlist = true;


		}
	}
	return iret;
}


// Подсчёт вторичных соседей в случае четырёх первичных соседей.
void Emultisosed_patch(octTree* &octree1) {
	// 4 соседа.
	integer icsos = 0;
	if (octree1->linkE1 != NULL) {
		if (is_null(octree1->linkE1)) {
			icsos++;
		}
		else if (is_null1(octree1->linkE1)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkE1, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c3 + c4 + c7;
		}
	}
	if (octree1->linkE2 != NULL) {
		if (is_null(octree1->linkE2)) {
			icsos++;
		}
		else if (is_null1(octree1->linkE2)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkE2, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c3 + c4 + c7;
		}
	}
	if (octree1->linkE5 != NULL) {
		if (is_null(octree1->linkE5)) {
			icsos++;
		}
		else if (is_null1(octree1->linkE5)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkE5, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c3 + c4 + c7;
		}
	}
	if (octree1->linkE6 != NULL) {
		if (is_null(octree1->linkE6)) {
			icsos++;
		}
		else if (is_null1(octree1->linkE6)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkE6, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c3 + c4 + c7;
		}
	}
	octree1->maxEsosed = icsos;
} // Emultisosed_patch

// Подсчёт вторичных соседей в случае четырёх первичных соседей.
void Wmultisosed_patch(octTree* &octree1) {
	// 4 соседа.
	integer icsos = 0;
	if (octree1->linkW0 != NULL) {
		if (is_null(octree1->linkW0)) {
			icsos++;
		}
		else if (is_null1(octree1->linkW0)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkW0, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c1 + c2 + c5 + c6;
		}
	}
	if (octree1->linkW3 != NULL) {
		if (is_null(octree1->linkW3)) {
			icsos++;
		}
		else if (is_null1(octree1->linkW3)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkW3, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c1 + c2 + c5 + c6;
		}
	}
	if (octree1->linkW4 != NULL) {
		if (is_null(octree1->linkW4)) {
			icsos++;
		}
		else if (is_null1(octree1->linkW4)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkW4, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c1 + c2 + c5 + c6;
		}
	}
	if (octree1->linkW7 != NULL) {
		if (is_null(octree1->linkW7)) {
			icsos++;
		}
		else if (is_null1(octree1->linkW7)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkW7, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c1 + c2 + c5 + c6;
		}
	}
	octree1->maxWsosed = icsos;
} // Wmultisosed_patch

// Подсчёт вторичных соседей в случае четырёх первичных соседей.
void Nmultisosed_patch(octTree* &octree1) {
	// 4 соседа.
	integer icsos = 0;
	if (octree1->linkN2 != NULL) {
		if (is_null(octree1->linkN2)) {
			icsos++;
		}
		else if (is_null1(octree1->linkN2)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkN2, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c1 + c4 + c5;
		}
	}
	if (octree1->linkN3 != NULL) {
		if (is_null(octree1->linkN3)) {
			icsos++;
		}
		else if (is_null1(octree1->linkN3)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkN3, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c1 + c4 + c5;
		}
	}
	if (octree1->linkN6 != NULL) {
		if (is_null(octree1->linkN6)) {
			icsos++;
		}
		else if (is_null1(octree1->linkN6)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkN6, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c1 + c4 + c5;
		}
	}
	if (octree1->linkN7 != NULL) {
		if (is_null(octree1->linkN7)) {
			icsos++;
		}
		else if (is_null1(octree1->linkN7)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkN7, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c1 + c4 + c5;
		}
	}

	integer i_X = 0;
	integer i_Y = 0;
	integer i_Z = 0;
	if (octree1->brootSituationX) i_X = 1;
	if (octree1->brootSituationY) i_Y = 1;
	if (octree1->brootSituationZ) i_Z = 1;
#if doubleintprecision == 1
	//printf("WARNING !!! incomming Nmultisosed_patch %lld X=%lld Y=%lld Z=%lld\n",icsos,i_X,i_Y,i_Z);
#else
	//printf("WARNING !!! incomming Nmultisosed_patch %d X=%d Y=%d Z=%d\n",icsos,i_X,i_Y,i_Z);
#endif
	//getchar();
	octree1->maxNsosed = icsos;

} //  Nmultisosed_patch

// Подсчёт вторичных соседей в случае четырёх первичных соседей.
void Smultisosed_patch(octTree* &octree1) {
	// 4 соседа.
	integer icsos = 0;
	if (octree1->linkS0 != NULL) {
		if (is_null(octree1->linkS0)) {
			icsos++;
		}
		else if (is_null1(octree1->linkS0)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkS0, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c2 + c3 + c6 + c7;
		}
	}
	if (octree1->linkS1 != NULL) {
		if (is_null(octree1->linkS1)) {
			icsos++;
		}
		else if (is_null1(octree1->linkS1)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkS1, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c2 + c3 + c6 + c7;
		}
	}
	if (octree1->linkS4 != NULL) {
		if (is_null(octree1->linkS4)) {
			icsos++;
		}
		else if (is_null1(octree1->linkS4)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkS4, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c2 + c3 + c6 + c7;
		}
	}
	if (octree1->linkS5 != NULL) {
		if (is_null(octree1->linkS5)) {
			icsos++;
		}
		else if (is_null1(octree1->linkS5)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkS5, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c2 + c3 + c6 + c7;
		}
	}
	octree1->maxSsosed = icsos;

} //  Smultisosed_patch


// Подсчёт вторичных соседей в случае четырёх первичных соседей.
void Bmultisosed_patch(octTree* &octree1) {
	// 4 соседа.
	integer icsos = 0;
	if (octree1->linkB0 != NULL) {
		if (is_null(octree1->linkB0)) {
			icsos++;
		}
		else if (is_null1(octree1->linkB0)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkB0, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c4 + c5 + c6 + c7;
		}
	}
	if (octree1->linkB1 != NULL) {
		if (is_null(octree1->linkB1)) {
			icsos++;
		}
		else if (is_null1(octree1->linkB1)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkB1, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c4 + c5 + c6 + c7;
		}
	}
	if (octree1->linkB2 != NULL) {
		if (is_null(octree1->linkB2)) {
			icsos++;
		}
		else if (is_null1(octree1->linkB2)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkB2, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c4 + c5 + c6 + c7;
		}
	}
	if (octree1->linkB3 != NULL) {
		if (is_null(octree1->linkB3)) {
			icsos++;
		}
		else if (is_null1(octree1->linkB3)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkB3, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c4 + c5 + c6 + c7;
		}
	}
	octree1->maxBsosed = icsos;
} // Bmultisosed_patch

// Подсчёт вторичных соседей в случае четырёх первичных соседей.
void Tmultisosed_patch(octTree* &octree1) {
	// 4 соседа.
	integer icsos = 0;
	if (octree1->linkT4 != NULL) {
		if (is_null(octree1->linkT4)) {
			icsos++;
		}
		else if (is_null1(octree1->linkT4)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkT4, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c1 + c2 + c3;
		}
	}
	if (octree1->linkT5 != NULL) {
		if (is_null(octree1->linkT5)) {
			icsos++;
		}
		else if (is_null1(octree1->linkT5)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkT5, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c1 + c2 + c3;
		}
	}
	if (octree1->linkT6 != NULL) {
		if (is_null(octree1->linkT6)) {
			icsos++;
		}
		else if (is_null1(octree1->linkT6)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkT6, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c1 + c2 + c3;
		}
	}
	if (octree1->linkT7 != NULL) {
		if (is_null(octree1->linkT7)) {
			icsos++;
		}
		else if (is_null1(octree1->linkT7)) {
			icsos += 4;
		}
		else {
			integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkT7, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c1 + c2 + c3;
		}
	}
	octree1->maxTsosed = icsos;

} //Tmultisosed_patch


void log_cs(octTree* &octree1) {
	printf("logcs incomming brootSituationX");
	getchar();
	// octree1 это лист. Situation это ситуация в octree1->parent.
	bool bSituationX = octree1->brootSituationX;
	bool bSituationY = octree1->brootSituationY;
	bool bSituationZ = octree1->brootSituationZ;
	bool bonly_dir_X = false;
	bool bonly_dir_Y = false;
	bool bonly_dir_Z = false;
	if (bSituationX && (bSituationY) && (!bSituationZ)) {
		bonly_dir_Z = true;
	}
	if (bSituationX && (bSituationZ) && (!bSituationY)) {
		bonly_dir_Y = true;
	}
	if (bSituationY && (bSituationZ) && (!bSituationX)) {
		bonly_dir_X = true;
	}

	// работаем с octree1
	switch (octree1->root) {
	case 0:

		if (octree1->b4T) { // + 2.09.2016 12.30
			Tmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkT != NULL) {
				//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
				if (octree1->ilevel != octree1->linkT->ilevel) {
					// На разных уровнях.
					if (bSituationZ) {
						// Вырождение по OZ.

						if (octree1->linkT != NULL) {
							if (is_null(octree1->linkT)) {
								// 1 остаётся 1.
								printf("T root 0 is_null _1");
								octree1->maxTsosed = 1;
							}
							else if (is_null1(octree1->linkT)) {

								if ((bonly_dir_X) || (bonly_dir_Y)) {
									printf("T root 0 is_null1 dirX || dirY _2 ");
									octree1->maxTsosed = 2;
								}
								else {
									// две четверные стороны прилегают друг к дружке.
									printf("T root 0 is_null1 _1");
									octree1->maxTsosed = 1;
								}
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								if ((bonly_dir_X) || (bonly_dir_Y)) {
									if (bonly_dir_X) {
										// дробим только по оси Ох.
										printf("TSIDE root 0 is_null3 _c0+c3");
										octree1->maxTsosed = c0 + c3;
									}
									if (bonly_dir_Y) {
										// дробим только по оси Oy.
										printf("TSIDE root 0 is_null3 _c0+c1");
										octree1->maxTsosed = c0 + c1;
									}
								}
								else {
									//octree1->maxTsosed = 4;
									printf("TSIDE root 0 is_null3 _c0");
									octree1->maxTsosed = c0;
								}
							}
						}
						else {
							// 0 остаётся 0.
							printf("TSIDE root 0 NULL 0");
							octree1->maxTsosed = 0;
						}

					}
					else {
						// это была внутренняя ячейка.
						printf("TSIDE root 0 not bSituation Z.");
						octree1->maxTsosed = 1;

					}
				}
				else if (octree1->ilevel == octree1->linkT->ilevel) {
					// На одном уровне.
					if (octree1->linkT != NULL) {
						if (is_null(octree1->linkT)) {
							// 1 остаётся 1.
							printf("TSIDE root 0 root na odnom urovne is_null _1");
							octree1->maxTsosed = 1;
						}
						else if (is_null1(octree1->linkT)) {
							printf("TSIDE root 0 root na odnom urovne is_null1 _4");
							octree1->maxTsosed = 4;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);

							//octree1->maxTsosed = 4;
							printf("TSIDE root 0 na odnom urovne is_null3 _c0+c1+c2+c3");
							octree1->maxTsosed = c0 + c1 + c2 + c3;
						}
					}
					else {
						// 0 остаётся 0.
						printf("TSIDE root 0 NULL _0");
						octree1->maxTsosed = 0;
					}
				}
			}
			else {
				// 0 остаётся 0.
				printf("TSIDE root 0 NULL _0");
				octree1->maxTsosed = 0;
			}
		}

		// root==0	
		if (octree1->b4N) {// + 2.09.2016 12.30
			Nmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkN != NULL) {
				//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
				if (octree1->ilevel != octree1->linkN->ilevel) {
					// На разных уровнях.
					if (bSituationY) {

						if (octree1->linkN != NULL) {
							if (is_null(octree1->linkN)) {
								// 1 остаётся 1.
								printf("N root 0 is_null _1");
								octree1->maxNsosed = 1;
							}
							else if (is_null1(octree1->linkN)) {
								if ((bonly_dir_X) || (bonly_dir_Z)) {
									printf("N root 0 dirX or dir Z is_null1 _2");
									octree1->maxNsosed = 2;
								}
								else {
									// две четверные стороны прилегают друг к дружке.
									printf("N root 0  is_null1 _1");
									octree1->maxNsosed = 1;
								}
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								if ((bonly_dir_X) || (bonly_dir_Z)) {
									if (bonly_dir_X) {
										printf("NSIDE root 0  dir X is_null3 _c0+c4");
										octree1->maxNsosed = c0 + c4;
									}
									if (bonly_dir_Z) {
										printf("NSIDE root 0  dir Z is_null3 _c0+c1");
										octree1->maxNsosed = c0 + c1;
									}
								}
								else {
									// других вариантов быть не может, здесь только 4.
									//octree1->maxNsosed = 4;
									// 4_2
									printf("N root 0 is_null3 _c0\n");
#if doubleintprecision == 1
									printf("octree1->ilevel=%lld octree1->linkN->ilevel=%lld c0=%lld\n", octree1->ilevel, octree1->linkN->ilevel, c0);
#else
									printf("octree1->ilevel=%d octree1->linkN->ilevel=%d c0=%d\n", octree1->ilevel, octree1->linkN->ilevel, c0);
#endif
										octree1->maxNsosed = c0;
								}
							}
						}
						else {
							// 0 остаётся 0.
							printf("NULL 0");
							octree1->maxNsosed = 0;
						}

					}
					else {
						printf("not bSituation Y");
						octree1->maxNsosed = 1;
					}

				}
				else if (octree1->ilevel == octree1->linkN->ilevel) {
					// На одном уровне.

					if (octree1->linkN != NULL) {
						if (is_null(octree1->linkN)) {
							// 1 остаётся 1.
							printf("N root 0 na odnom urovne is_null _1");
							octree1->maxNsosed = 1;
						}
						else if (is_null1(octree1->linkN)) {
							printf("N root 0 na odnom urovne is_null1 _4");
							// две четверные стороны прилегают друг к дружке.
							octree1->maxNsosed = 4;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							printf("N root 0 na odnom urovne is_null3 _c0+c1+c4+c5");
							// других вариантов быть не может, здесь только 4.
							//octree1->maxNsosed = 4;
							octree1->maxNsosed = c0 + c1 + c4 + c5;

						}
					}
					else {
						printf("NSIDE root 0 NULL na odnom urovne\n");
						// 0 остаётся 0.
						octree1->maxNsosed = 0;
					}

				}
			}
			else {
				// 0 остаётся 0.
				printf("N root 0 NULL na odnom urovne\n");
				octree1->maxNsosed = 0;
			}
		}


		if (octree1->b4E) {
			// 4 соседа.
			Emultisosed_patch(octree1);
		}
		else {
			if (octree1->linkE != NULL) {
				//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
				if (octree1->ilevel != octree1->linkE->ilevel) {
					// На разных уровнях.
					if (bSituationX) {


						if (octree1->linkE != NULL) {
							if (is_null(octree1->linkE)) {
								// 1 остаётся 1.
								octree1->maxEsosed = 1;
							}
							else if (is_null1(octree1->linkE)) {
								if ((bonly_dir_Z) || (bonly_dir_Y)) {
									octree1->maxEsosed = 2;
								}
								else {
									// две четверные стороны прилегают друг к дружке.
									octree1->maxEsosed = 1;
								}
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								if ((bonly_dir_Y) || (bonly_dir_Z)) {
									if (bonly_dir_Y) {
										// дробим только по оси Oy.
										octree1->maxEsosed = c0 + c4;
									}
									if (bonly_dir_Z) {
										// дробим только по оси Oz.
										octree1->maxEsosed = c0 + c3;
									}
								}
								else {
									// других вариантов быть не может, здесь только 4.
									//octree1->maxEsosed = 4;
									octree1->maxEsosed = c0;
								}
							}
						}
						else {
							// 0 остаётся 0.
							octree1->maxEsosed = 0;
						}

					}
					else {
						octree1->maxEsosed = 1;
					}
				}
				else if (octree1->ilevel == octree1->linkE->ilevel) {
					// На одном уровне.
					if (octree1->linkE != NULL) {
						if (is_null(octree1->linkE)) {
							// 1 остаётся 1.
							octree1->maxEsosed = 1;
						}
						else if (is_null1(octree1->linkE)) {
							// две четверные стороны прилегают друг к дружке.
							octree1->maxEsosed = 4;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);

							// других вариантов быть не может, здесь только 4.
							//octree1->maxEsosed = 4;
							octree1->maxEsosed = c0 + c3 + c4 + c7;

						}
					}
					else {
						// 0 остаётся 0.
						octree1->maxEsosed = 0;
					}
				}
			}
			else {
				// NULL 
				// 0 остаётся 0.
				octree1->maxEsosed = 0;
			}
		}

		if (octree1->b4W) {
			// 4 соседа.
			Wmultisosed_patch(octree1);
		}
		else {
			// Должно быть уменьшение при дроблении:
			if (octree1->linkW != NULL) {
				//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
				if (octree1->ilevel != octree1->linkW->ilevel) {
					// На разных уровнях.

					if (bSituationY && (!bSituationX) && (!bSituationZ)) {
						if (is_null(octree1->linkW)) {
							// 1 остаётся 1.
							octree1->maxWsosed = 1;
						}
						else if (is_null1(octree1->linkW)) {
							// двойная прилегает к четверной.
							octree1->maxWsosed = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxWsosed = c1 + c2;
						}
					}
					else if (bSituationZ && (!bSituationX) && (!bSituationY)) {
						if (is_null(octree1->linkW)) {
							// 1 остаётся 1.
							octree1->maxWsosed = 1;
						}
						else if (is_null1(octree1->linkW)) {
							// двойная прилегает к четверной.
							octree1->maxWsosed = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxWsosed = c1 + c5;
						}
					}
					else {
						if (is_null(octree1->linkW)) {
							// 1 остаётся 1.
							octree1->maxWsosed = 1;
						}
						else if (is_null1(octree1->linkW)) {
							if (bonly_dir_Y){
								octree1->maxWsosed = 2;
							}
							else if (bonly_dir_Z) {
								octree1->maxWsosed = 2;
							}
							else {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxWsosed = 1;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							// других вариантов быть не может, здесь только 4.
							//octree1->maxWsosed = 4;
							if (bonly_dir_Y) {
								octree1->maxWsosed = c1 + c5;
							}
							else if (bonly_dir_Z) {
								octree1->maxWsosed = c1 + c2;
							}
							else {
								octree1->maxWsosed = c1;
							}

						}
					}
				}
				else if (octree1->ilevel == octree1->linkW->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkW)) {
						// 1 остаётся 1.
						octree1->maxWsosed = 1;
					}
					else if (is_null1(octree1->linkW)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxWsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxWsosed = 4;
						octree1->maxWsosed = c1 + c2 + c5 + c6;

					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxWsosed = 0;
			}
		}


		if (octree1->b4S) {
			// 4 соседа.
			Smultisosed_patch(octree1);
		}
		else {
			if (octree1->linkS != NULL) {
				//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
				if (octree1->ilevel != octree1->linkS->ilevel) {
					// На разных уровнях.


					if (bSituationX && (!bSituationY) && (!bSituationZ)) {
						if (is_null(octree1->linkS)) {
							// 1 остаётся 1.
							octree1->maxSsosed = 1;
						}
						else if (is_null1(octree1->linkS)) {
							// двойная прилегает к четверной.
							octree1->maxSsosed = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxSsosed = c3 + c2;
						}
					}
					else if (bSituationZ && (!bSituationX) && (!bSituationY)) {
						if (is_null(octree1->linkS)) {
							// 1 остаётся 1.
							octree1->maxSsosed = 1;
						}
						else if (is_null1(octree1->linkS)) {
							// двойная прилегает к четверной.
							octree1->maxSsosed = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxSsosed = c3 + c7;
						}
					}
					else {
						if (is_null(octree1->linkS)) {
							// 1 остаётся 1.
							octree1->maxSsosed = 1;
						}
						else if (is_null1(octree1->linkS)) {
							if (bonly_dir_Z) {
								octree1->maxSsosed = 2;
							}
							else if (bonly_dir_X) {
								octree1->maxSsosed = 2;
							}
							else {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxSsosed = 1;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							// других вариантов быть не может, здесь только 4.
							if (bonly_dir_Z) {
								octree1->maxSsosed = c3 + c2;
							}
							else if (bonly_dir_X) {
								octree1->maxSsosed = c3 + c7;
							}
							else {
								//octree1->maxSsosed = 4;
								octree1->maxSsosed = c3;
							}
						}
					}
				}
				else if (octree1->ilevel == octree1->linkS->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkS)) {
						// 1 остаётся 1.
						octree1->maxSsosed = 1;
					}
					else if (is_null1(octree1->linkS)) {
						// Один контачит с четырьмя.
						octree1->maxSsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.

						//octree1->maxSsosed = 4;
						octree1->maxSsosed = c3 + c2 + c6 + c7;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxSsosed = 0;
			}
		}

		if (octree1->b4B) {
			// 4 соседа.
			Bmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkB != NULL) {
				//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
				if (octree1->ilevel != octree1->linkB->ilevel) {
					// На разных уровнях.


					if (bSituationY && (!bSituationX) && (!bSituationZ)) {
						if (is_null(octree1->linkB)) {
							// 1 остаётся 1.
							octree1->maxBsosed = 1;
						}
						else if (is_null1(octree1->linkB)) {
							// двойная прилегает к четверной.
							octree1->maxBsosed = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxBsosed = c4 + c7;
						}
					}
					else if (bSituationX && (!bSituationY) && (!bSituationZ)) {
						if (is_null(octree1->linkB)) {
							// 1 остаётся 1.
							octree1->maxBsosed = 1;
						}
						else if (is_null1(octree1->linkB)) {
							// двойная прилегает к четверной.
							octree1->maxBsosed = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxBsosed = c4 + c5;
						}
					}
					else {
						if (is_null(octree1->linkB)) {
							// 1 остаётся 1.
							octree1->maxBsosed = 1;
						}
						else if (is_null1(octree1->linkB)) {
							if (bonly_dir_Y) {
								octree1->maxBsosed = 2;
							}
							else if (bonly_dir_X) {
								octree1->maxBsosed = 2;
							}
							else {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxBsosed = 1;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							if (bonly_dir_Y) {
								octree1->maxBsosed = c4 + c5;
							}
							else if (bonly_dir_X) {
								octree1->maxBsosed = c4 + c7;
							}
							else {
								// других вариантов быть не может, здесь только 4.
								//octree1->maxBsosed = 4;
								octree1->maxBsosed = c4;
							}
						}
					}
				}
				else if (octree1->ilevel == octree1->linkB->ilevel) {
					if (is_null(octree1->linkB)) {
						// 1 остаётся 1.
						octree1->maxBsosed = 1;
					}
					else if (is_null1(octree1->linkB)) {
						// однушка прилегает к четырём четвертинкам.
						octree1->maxBsosed = 4;

					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						//octree1->maxBsosed = 4;
						octree1->maxBsosed = c4 + c5 + c6 + c7;

					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxBsosed = 0;
			}
		}
		break;
	case 1:

		if (octree1->b4T) { // +
			// 4 соседа.
			Tmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkT != NULL) {
				//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
				if (octree1->ilevel != octree1->linkT->ilevel) {
					// На разных уровнях.

					if (bSituationZ) {


						// Вырождение по OZ.
						if (octree1->linkT != NULL) {
							if (is_null(octree1->linkT)) {
								// 1 остаётся 1.
								octree1->maxTsosed = 1;
							}
							else if (is_null1(octree1->linkT)) {
								if (bonly_dir_X) {
									octree1->maxTsosed = 2;
								}
								else {
									// две четверные стороны прилегают друг к дружке.
									octree1->maxTsosed = 1;
								}
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								if ((bonly_dir_X)) {
									if (bonly_dir_X) {
										// дробим только по оси Oy.
										octree1->maxTsosed = c1 + c2;
									}
								}
								else {
									// других вариантов быть не может, здесь только 4.
									// может быть  2, 4, 5, 8
									//octree1->maxTsosed = 4;
									octree1->maxTsosed = c1;
								}
							}
						}
						else {
							// 0 остаётся 0.
							octree1->maxTsosed = 0;
						}
					}
					else {
						octree1->maxTsosed = 1;
					}
				}
				else if (octree1->ilevel == octree1->linkT->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTsosed = 1;
					}
					else if (is_null1(octree1->linkT)) {
						// однушка прилегает к четвертушке.
						octree1->maxTsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						// может быть  2, 4, 5, 8
						//octree1->maxTsosed = 4;
						octree1->maxTsosed = c1 + c0 + c2 + c3;

					}
				}
			}
			else {
				// NULL
				// 0 остаётся 0.
				octree1->maxTsosed = 0;
			}
		}

		if (octree1->b4N) { // + 2.sept.2016 13.59
			// 4 соседа.
			Nmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkN != NULL) {
				//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
				if (octree1->ilevel != octree1->linkN->ilevel) {
					// На разных уровнях.
					if (bSituationY) {


						if (octree1->linkN != NULL) {
							if (is_null(octree1->linkN)) {
								// 1 остаётся 1.
								octree1->maxNsosed = 1;
							}
							else if (is_null1(octree1->linkN)) {
								if (bonly_dir_X) {
									octree1->maxNsosed = 2;
								}
								else {
									// две четверные стороны прилегают друг к дружке.
									octree1->maxNsosed = 1;
								}
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								if ((bonly_dir_X)) {
									if (bonly_dir_X) {
										// дробим только по оси Oy.
										octree1->maxNsosed = c1 + c5;
									}
								}
								else {
									// других вариантов быть не может, здесь только 4.
									//octree1->maxNsosed = 4;
									octree1->maxNsosed = c1;
								}
							}
						}
						else {
							// 0 остаётся 0.
							octree1->maxNsosed = 0;
						}

					}
					else {
						octree1->maxNsosed = 1;
					}
				}
				else if (octree1->ilevel == octree1->linkN->ilevel) {
					// На одном уровне.

					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNsosed = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxNsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						//octree1->maxNsosed = 4;
						octree1->maxNsosed = c1 + c0 + c4 + c5;

					}
				}
			}
			else {
				// NULL.
				// 0 остаётся 0.
				octree1->maxNsosed = 0;
			}
		}

		if (octree1->b4W) { // + 2.sept.2016 13.30
			Wmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkW != NULL) {
				//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
				if (octree1->ilevel != octree1->linkW->ilevel) {
					// на разных уровнях.
					octree1->maxWsosed = 1;
				}
				else if (octree1->ilevel == octree1->linkW->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkW)) {
						// 1 остается 1
						octree1->maxWsosed = 1;
					}
					else if (is_null1(octree1->linkW)) {
						// однушка прилегает к четвертушке.
						octree1->maxWsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxWsosed = c1 + c2 + c5 + c6;
					}
				}
			}
			else {
				// NULL 0 остаётся нулём.
				octree1->maxWsosed = 0;
			}
		}



		if (octree1->b4E) {// +
			// 4 соседа.
			Emultisosed_patch(octree1);
		}
		else {
			// Должно быть уменьшение при дроблении:
			if (octree1->linkE != NULL) {
				//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
				if (octree1->ilevel != octree1->linkE->ilevel) {
					// На разных уровнях.

					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEsosed = 1;
					}
					else if (is_null1(octree1->linkE)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxEsosed = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxEsosed = c0;
					}
				}
				else if (octree1->ilevel == octree1->linkE->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEsosed = 1;
					}
					else if (is_null1(octree1->linkE)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxEsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxEsosed = c0 + c3 + c4 + c7;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxEsosed = 0;
			}
		}


		if (octree1->b4S) {// +
			// 4 соседа.
			Smultisosed_patch(octree1);
		}
		else {
			if (octree1->linkS != NULL) {
				//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
				if (octree1->ilevel != octree1->linkS->ilevel) {
					// На разных уровнях.


					if (bSituationZ && (!bSituationX) && (!bSituationY)) {
						if (is_null(octree1->linkS)) {
							// 1 остаётся 1.
							octree1->maxSsosed = 1;
						}
						else if (is_null1(octree1->linkS)) {
							// двойная прилегает к четверной.
							octree1->maxSsosed = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxSsosed = c2 + c6;
						}
					}
					else {
						if (is_null(octree1->linkS)) {
							// 1 остаётся 1.
							octree1->maxSsosed = 1;
						}
						else if (is_null1(octree1->linkS)) {
							if (bonly_dir_X) {
								octree1->maxSsosed = 2;
							}
							else {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxSsosed = 1;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							if (bonly_dir_X) {
								octree1->maxSsosed = c2 + c6;
							}
							else {
								// других вариантов быть не может, здесь только 4.
								//octree1->maxSsosed = 4;
								octree1->maxSsosed = c2;
							}
						}
					}
				}
				else if (octree1->ilevel == octree1->linkS->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkS)) {
						// 1 остаётся 1.
						octree1->maxSsosed = 1;
					}
					else if (is_null1(octree1->linkS)) {
						// однушка прилегает к четвертушке.
						octree1->maxSsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						//octree1->maxSsosed = 4;
						octree1->maxSsosed = c2 + c3 + c6 + c7;

					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxSsosed = 0;
			}
		}

		if (octree1->b4B) {// +
			// 4 соседа.
			Bmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkB != NULL) {
				//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
				if (octree1->ilevel != octree1->linkB->ilevel) {
					// На разных уровнях.


					if (bSituationY && (!bSituationX) && (!bSituationZ)) {
						if (is_null(octree1->linkB)) {
							// 1 остаётся 1.
							octree1->maxBsosed = 1;
						}
						else if (is_null1(octree1->linkB)) {
							// двойная прилегает к четверной.
							octree1->maxBsosed = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxBsosed = c5 + c6;
						}
					}
					else {
						if (is_null(octree1->linkB)) {
							// 1 остаётся 1.
							octree1->maxBsosed = 1;
						}
						else if (is_null1(octree1->linkB)) {
							if (bonly_dir_X) {
								octree1->maxBsosed = 2;
							}
							else {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxBsosed = 1;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							if (bonly_dir_X) {
								octree1->maxBsosed = c5 + c6;
							}
							else {
								// других вариантов быть не может, здесь только 4.
								//octree1->maxBsosed = 4;
								octree1->maxBsosed = c5;
							}
						}
					}
				}
				else if (octree1->ilevel == octree1->linkB->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkB)) {
						// 1 остаётся 1.
						octree1->maxBsosed = 1;
					}
					else if (is_null1(octree1->linkB)) {
						// однушка прилегает к четветушке.
						octree1->maxBsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						//octree1->maxBsosed = 4;
						octree1->maxBsosed = c5 + c4 + c6 + c7;

					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxBsosed = 0;
			}
		}
		break;
	case 2:


		if (octree1->b4T) { // +
			// 4 соседа.
			Tmultisosed_patch(octree1);
		}
		else {

			if (octree1->linkT != NULL) {
				//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
				if (octree1->ilevel != octree1->linkT->ilevel) {
					// На разных уровнях.


					if (bSituationZ) {
						// Вырождение по OZ.


						if (octree1->linkT != NULL) {
							if (is_null(octree1->linkT)) {
								// 1 остаётся 1.
								octree1->maxTsosed = 1;
							}
							else if (is_null1(octree1->linkT)) {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxTsosed = 1;
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								// других вариантов быть не может, здесь только 4.
								//octree1->maxTsosed = 4;
								octree1->maxTsosed = c2;
							}
						}
						else {
							// 0 остаётся 0.
							octree1->maxTsosed = 0;
						}

					}
					else {
						octree1->maxTsosed = 1;
					}
				}
				else if (octree1->ilevel == octree1->linkT->ilevel) {
					// На одном уровне.

					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTsosed = 1;
					}
					else if (is_null1(octree1->linkT)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxTsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxTsosed = 4;
						octree1->maxTsosed = c2 + c0 + c1 + c3;
					}
				}

			}
			else {
				// NULL
				// 0 остаётся 0.
				octree1->maxTsosed = 0;
			}
		}



		if (octree1->b4S) { // + 2.sept.2016 13.30
			Smultisosed_patch(octree1);
		}
		else {
			if (octree1->linkS != NULL) {
				//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
				if (octree1->ilevel != octree1->linkS->ilevel) {
					// на разных уровнях.
					octree1->maxSsosed = 1;
				}
				else if (octree1->ilevel == octree1->linkS->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkS)) {
						// 1 остается 1
						octree1->maxSsosed = 1;
					}
					else if (is_null1(octree1->linkS)) {
						// однушка прилегает к четвертушке.
						octree1->maxSsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxSsosed = c6 + c7 + c2 + c3;
					}
				}
			}
			else {
				// NULL 0 остаётся нулём.
				octree1->maxSsosed = 0;
			}
		}


		if (octree1->b4W) { // + 2.sept.2016 13.30
			Wmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkW != NULL) {
				//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
				if (octree1->ilevel != octree1->linkW->ilevel) {
					// на разных уровнях.
					octree1->maxWsosed = 1;
				}
				else if (octree1->ilevel == octree1->linkW->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkW)) {
						// 1 остается 1
						octree1->maxWsosed = 1;
					}
					else if (is_null1(octree1->linkW)) {
						// однушка прилегает к четвертушке.
						octree1->maxWsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxWsosed = c1 + c2 + c5 + c6;
					}
				}
			}
			else {
				// NULL 0 остаётся нулём.
				octree1->maxWsosed = 0;
			}
		}


		if (octree1->b4E) { // + 2.sept.2016 14:27
			// 4 соседа.
			Emultisosed_patch(octree1);
		}
		else {
			// Должно быть уменьшение при дроблении:
			if (octree1->linkE != NULL) {
				//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
				if (octree1->ilevel != octree1->linkE->ilevel) {
					// На разных уровнях.

					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEsosed = 1;
					}
					else if (is_null1(octree1->linkE)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxEsosed = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxEsosed = c3;
					}
				}
				else if (octree1->ilevel == octree1->linkE->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEsosed = 1;
					}
					else if (is_null1(octree1->linkE)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxEsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxEsosed = c3 + c0 + c4 + c7;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxEsosed = 0;
			}
		}


		if (octree1->b4N) {// + 
			// 4 соседа.
			Nmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkN != NULL) {
				//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
				if (octree1->ilevel != octree1->linkN->ilevel) {
					// На разных уровнях.

					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNsosed = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxNsosed = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						//octree1->maxNsosed = 4;
						octree1->maxNsosed = c1;
					}
				}
				else if (octree1->ilevel == octree1->linkN->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNsosed = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxNsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						//octree1->maxNsosed = 4;
						octree1->maxNsosed = c1 + c0 + c4 + c5;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxNsosed = 0;
			}
		}


		if (octree1->b4B) {
			// 4 соседа.
			Bmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkB != NULL) {
				//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
				if (octree1->ilevel != octree1->linkB->ilevel) {

					if (is_null(octree1->linkB)) {
						// 1 остаётся 1.
						octree1->maxBsosed = 1;
					}
					else if (is_null1(octree1->linkB)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxBsosed = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxBsosed = 4;
						octree1->maxBsosed = c6;
					}
				}
				else if (octree1->ilevel == octree1->linkB->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkB)) {
						// 1 остаётся 1.
						octree1->maxBsosed = 1;
					}
					else if (is_null1(octree1->linkB)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxBsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxBsosed = 4;
						octree1->maxBsosed = c6 + c5 + c7 + c4;
					}

				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxBsosed = 0;
			}
		}


		break;
	case 3:

		if (octree1->b4T) {  // + 2.september 2016 17:47
			Tmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkT != NULL) {
				//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
				if (octree1->ilevel != octree1->linkT->ilevel) {
					// На разных уровнях.


					if (bSituationZ) {
						// Вырождение по OZ.

						if (octree1->linkT != NULL) {
							if (is_null(octree1->linkT)) {
								// 1 остаётся 1.
								octree1->maxTsosed = 1;
							}
							else if (is_null1(octree1->linkT)) {
								if (bonly_dir_Y) {
									octree1->maxTsosed = 2;
								}
								else {
									// две четверные стороны прилегают друг к дружке.
									octree1->maxTsosed = 1;
								}
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								if ((bonly_dir_Y)) {
									if (bonly_dir_Y) {
										// дробим только по оси Oy.
										octree1->maxTsosed = c3 + c2;
									}
								}
								else {
									// других вариантов быть не может, здесь только 4.
									// может быть 2, 4, 5, 8.
									//octree1->maxTsosed = 4;
									octree1->maxTsosed = c3;
								}
							}
						}
						else {
							// 0 остаётся 0.
							octree1->maxTsosed = 0;
						}

					}
					else {
						octree1->maxTsosed = 1;
					}
				}
				else if (octree1->ilevel == octree1->linkT->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTsosed = 1;
					}
					else if (is_null1(octree1->linkT)) {

						// Целая прилегает к четырём четвертинкам.
						octree1->maxTsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8.
						//octree1->maxTsosed = 4;
						octree1->maxTsosed = c3 + c0 + c1 + c2;
					}
				}
			}
			else {
				// NULL:
				// 0 остаётся 0.
				octree1->maxTsosed = 0;
			}
		}


		if (octree1->b4S) { // + 2.sept.2016 13.30
			Smultisosed_patch(octree1);
		}
		else {
			if (octree1->linkS != NULL) {
				//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
				if (octree1->ilevel != octree1->linkS->ilevel) {
					// на разных уровнях.
					octree1->maxSsosed = 1;
				}
				else if (octree1->ilevel == octree1->linkS->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkS)) {
						// 1 остается 1
						octree1->maxSsosed = 1;
					}
					else if (is_null1(octree1->linkS)) {
						// однушка прилегает к четвертушке.
						octree1->maxSsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkS, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxSsosed = c2 + c3 + c6 + c7;
					}
				}
			}
			else {
				// NULL 0 остаётся нулём.
				octree1->maxSsosed = 0;
			}
		}


		if (octree1->b4E) { // + 2.september.2016 17:41
			Emultisosed_patch(octree1);
		}
		else {
			if (octree1->linkE != NULL) {
				//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
				if (octree1->ilevel != octree1->linkE->ilevel) {
					// На разных уровнях.

					if (bSituationX) {


						if (octree1->linkE != NULL) {
							if (is_null(octree1->linkE)) {
								// 1 остаётся 1.
								octree1->maxEsosed = 1;
							}
							else if (is_null1(octree1->linkE)) {
								if (bonly_dir_Y) {
									octree1->maxEsosed = 2;
								}
								else {
									// две четверные стороны прилегают друг к дружке.
									octree1->maxEsosed = 1;
								}
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								if ((bonly_dir_Y)) {
									if (bonly_dir_Y) {
										// дробим только по оси Oy.
										octree1->maxEsosed = c3 + c7;
									}
								}
								else {
									// других вариантов быть не может, здесь только 4.
									// Может быть 2, 4, 5, 8
									//octree1->maxEsosed = 4;
									octree1->maxEsosed = c3;
								}
							}
						}
						else {
							// 0 остаётся 0.
							octree1->maxEsosed = 0;
						}

					}
					else {
						octree1->maxEsosed = 1;
					}
				}
				else if (octree1->ilevel == octree1->linkE->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEsosed = 1;
					}
					else if (is_null1(octree1->linkE)) {

						// однушка примыкает к четырем четвертинкам.
						octree1->maxEsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						// Может быть 2, 4, 5, 8
						//octree1->maxEsosed = 4;
						octree1->maxEsosed = c3 + c0 + c4 + c7;
					}
				}
			}
			else {
				// NULL;
				// 0 остаётся 0.
				octree1->maxEsosed = 0;
			}
		}

		if (octree1->b4W) { // + 2.sept.2016 17:24
			Wmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkW != NULL) {
				//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
				if (octree1->ilevel != octree1->linkW->ilevel) {
					// На разных уровнях.


					if (bSituationZ && (!bSituationX) && (!bSituationY)) {
						if (is_null(octree1->linkW)) {
							// 1 остаётся 1.
							octree1->maxWsosed = 1;
						}
						else if (is_null1(octree1->linkW)) {
							// двойная прилегает к четверной.
							octree1->maxWsosed = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxWsosed = c2 + c6;
						}
					}
					else {
						if (is_null(octree1->linkW)) {
							// 1 остаётся 1.
							octree1->maxWsosed = 1;
						}
						else if (is_null1(octree1->linkW)) {
							if (bonly_dir_Y) {
								octree1->maxWsosed = 2;
							}
							else {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxWsosed = 1;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							// других вариантов быть не может, здесь только 4.
							//octree1->maxWsosed = 4;
							if (bonly_dir_Y) {
								octree1->maxWsosed = c2 + c6;
							}
							else {
								octree1->maxWsosed = c2;
							}
						}
					}
				}
				else if (octree1->ilevel == octree1->linkW->ilevel) {
					// На одинаковых уровнях.
					if (is_null(octree1->linkW)) {
						// 1 остаётся 1.
						octree1->maxWsosed = 1;
					}
					else if (is_null1(octree1->linkW)) {
						// однушка примыкает к четырём четвертинкам.
						octree1->maxWsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxWsosed = 4;

						octree1->maxWsosed = c2 + c1 + c5 + c6;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxWsosed = 0;
			}
		}

		if (octree1->b4N) { // +
			Nmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkN != NULL) {
				//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
				if (octree1->ilevel != octree1->linkN->ilevel) {
					// На разных уровнях.


					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNsosed = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxNsosed = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxNsosed = 4;
						octree1->maxNsosed = c0;
					}
				}
				else if (octree1->ilevel == octree1->linkN->ilevel) {
					// На одинаковых уровнях.
					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNsosed = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// однушка примыкает к четвертинке.
						octree1->maxNsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxNsosed = 4;
						octree1->maxNsosed = c0 + c1 + c4 + c5;
					}

				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxNsosed = 0;
			}
		}

		if (octree1->b4B) { // +
			Bmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkB != NULL) {
				//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
				if (octree1->ilevel != octree1->linkB->ilevel) {
					// На разных уровнях.
					if (bSituationX && (!bSituationY) && (!bSituationZ)) {
						if (is_null(octree1->linkB)) {
							// 1 остаётся 1.
							octree1->maxBsosed = 1;
						}
						else if (is_null1(octree1->linkB)) {
							// двойная прилегает к четверной.
							octree1->maxBsosed = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxBsosed = c7 + c6;
						}
					}
					else {
						if (is_null(octree1->linkB)) {
							// 1 остаётся 1.
							octree1->maxBsosed = 1;
						}
						else if (is_null1(octree1->linkB)) {
							if (bonly_dir_Y) {
								octree1->maxBsosed = 2;
							}
							else {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxBsosed = 1;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							if (bonly_dir_Y) {
								octree1->maxBsosed = c7 + c6;
							}
							else {
								// других вариантов быть не может, здесь только 4.
								//octree1->maxBsosed = 4;
								octree1->maxBsosed = c7;
							}
						}
					}
				}
				else if (octree1->ilevel == octree1->linkB->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkB)) {
						// 1 остаётся 1.
						octree1->maxBsosed = 1;
					}
					else if (is_null1(octree1->linkB)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxBsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						//octree1->maxBsosed = 4;
						octree1->maxBsosed = c7 + c6 + c5 + c4;

					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxBsosed = 0;
			}
		}

		break;
	case 4:

		if (octree1->b4N) { // + 2.september.2016 17:10
			Nmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkN != NULL) {
				//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
				if (octree1->ilevel != octree1->linkN->ilevel) {
					// На разных уровнях.


					if (bSituationY) {

						if (octree1->linkN != NULL) {
							if (is_null(octree1->linkN)) {
								// 1 остаётся 1.
								octree1->maxNsosed = 1;
							}
							else if (is_null1(octree1->linkN)) {
								if (bonly_dir_Z) {
									octree1->maxNsosed = 2;
								}
								else {
									// две четверные стороны прилегают друг к дружке.
									octree1->maxNsosed = 1;
								}
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								if ((bonly_dir_Z)) {
									if (bonly_dir_Z) {
										// дробим только по оси Oy.
										octree1->maxNsosed = c4 + c5;
									}
								}
								else {
									// других вариантов быть не может, здесь только 4.
									// Здесь может быть 2, 4, 5, 8
									//octree1->maxNsosed = 4;
									octree1->maxNsosed = c4;
								}
							}
						}
						else {
							// 0 остаётся 0.
							octree1->maxNsosed = 0;
						}

					}
					else {
						octree1->maxNsosed = 1;
					}
				}
				else if (octree1->ilevel == octree1->linkN->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNsosed = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// однушка примыкает к четырём четвертинкам.
						octree1->maxNsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						// Здесь может быть 2, 4, 5, 8
						//octree1->maxNsosed = 4;
						octree1->maxNsosed = c4 + c0 + c1 + c5;

					}
				}
				/*else {
				#if doubleintprecision == 1
					printf("FATAL ERROR! octree1->ilevel=%lld octree1->linkN->ilevel=%lld\n", octree1->ilevel, octree1->linkN->ilevel);
					printf("octree1->maxNsosed=%lld\n", octree1->maxNsosed);
				#else
					printf("FATAL ERROR! octree1->ilevel=%d octree1->linkN->ilevel=%d\n", octree1->ilevel, octree1->linkN->ilevel);
					printf("octree1->maxNsosed=%d\n", octree1->maxNsosed);
				#endif
				
				getchar();
				}*/
			}
			else {
				// NULL
				// 0 остаётся 0.
				octree1->maxNsosed = 0;
			}
		}

		if (octree1->b4E) { // + 2 sept 2016 16:49
			Emultisosed_patch(octree1);
		}
		else {
			if (octree1->linkE != NULL) {
				//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
				if (octree1->ilevel != octree1->linkE->ilevel) {
					// На разных уровнях.

					if (bSituationX) {

						if (octree1->linkE != NULL) {
							if (is_null(octree1->linkE)) {
								// 1 остаётся 1.
								octree1->maxEsosed = 1;
							}
							else if (is_null1(octree1->linkE)) {
								if (bonly_dir_Z) {
									octree1->maxEsosed = 2;
								}
								else {
									// две четверные стороны прилегают друг к дружке.
									octree1->maxEsosed = 1;
								}
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								if ((bonly_dir_Z)) {
									if (bonly_dir_Z) {
										// дробим только по оси Oy.
										octree1->maxEsosed = c4 + c7;
									}
								}
								else {
									// других вариантов быть не может, здесь только 4.
									//octree1->maxEsosed = 4;
									octree1->maxEsosed = c4;
								}
							}
						}
						else {
							// 0 остаётся 0.
							octree1->maxEsosed = 0;
						}
					}
					else {
						octree1->maxEsosed = 1;
					}
				}
				else if (octree1->ilevel == octree1->linkE->ilevel) {
					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEsosed = 1;
					}
					else if (is_null1(octree1->linkE)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxEsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxEsosed = c4 + c0 + c3 + c7;
					}
				}
			}
			else {
				// NULL
				// 0 остаётся 0.
				octree1->maxEsosed = 0;
			}
		}


		if (octree1->b4W) { // +
			Wmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkW != NULL) {
				//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
				if (octree1->ilevel != octree1->linkW->ilevel) {
					// На разных уровнях.

					if (bSituationY && (!bSituationX) && (!bSituationZ)) {
						if (is_null(octree1->linkW)) {
							// 1 остаётся 1.
							octree1->maxWsosed = 1;
						}
						else if (is_null1(octree1->linkW)) {
							// двойная прилегает к четверной.
							octree1->maxWsosed = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxWsosed = c5 + c6;
						}
					}
					else {
						if (is_null(octree1->linkW)) {
							// 1 остаётся 1.
							octree1->maxWsosed = 1;
						}
						else if (is_null1(octree1->linkW)) {
							if (bonly_dir_Z) {
								octree1->maxWsosed = 2;
							}
							else {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxWsosed = 1;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							// других вариантов быть не может, здесь только 4.
							//octree1->maxWsosed = 4;
							if (bonly_dir_Z) {
								octree1->maxWsosed = c5 + c6;
							}
							else {
								octree1->maxWsosed = c5;
							}
						}
					}
				}
				else if (octree1->ilevel == octree1->linkW->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkW)) {
						// 1 остаётся 1.
						octree1->maxWsosed = 1;
					}
					else if (is_null1(octree1->linkW)) {
						// однушка примыкает к четвертинкам.
						octree1->maxWsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxWsosed = 4;

						octree1->maxWsosed = c5 + c1 + c2 + c6;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxWsosed = 0;
			}
		}

		if (octree1->b4S) { // + 2.september. 2016 16:59
			Smultisosed_patch(octree1);
		}
		else {
			if (octree1->linkS != NULL) {
				//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
				if (octree1->ilevel != octree1->linkS->ilevel) {
					// На разных уровнях.


					if (bSituationX && (!bSituationY) && (!bSituationZ)) {
						if (is_null(octree1->linkS)) {
							// 1 остаётся 1.
							octree1->maxSsosed = 1;
						}
						else if (is_null1(octree1->linkS)) {
							// двойная прилегает к четверной.
							octree1->maxSsosed = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxSsosed = c7 + c6;
						}
					}
					else {
						if (is_null(octree1->linkS)) {
							// 1 остаётся 1.
							octree1->maxSsosed = 1;
						}
						else if (is_null1(octree1->linkS)) {
							if (bonly_dir_Z) {
								octree1->maxSsosed = 2;
							}
							else {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxSsosed = 1;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							// других вариантов быть не может, здесь только 4.
							//octree1->maxSsosed = 4;
							if (bonly_dir_Z) {
								octree1->maxSsosed = c7 + c6;
							}
							else {
								octree1->maxSsosed = c7;
							}
						}
					}
				}
				else if (octree1->ilevel == octree1->linkS->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkS)) {
						// 1 остаётся 1.
						octree1->maxSsosed = 1;
					}
					else if (is_null1(octree1->linkS)) {
						// однушка примыкает к четырем четвертинкам.
						octree1->maxSsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxSsosed = 4;

						octree1->maxSsosed = c7 + c2 + c3 + c6;

					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxSsosed = 0;
			}
		}


		if (octree1->b4T) { // +
			Tmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkT != NULL) {
				//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
				if (octree1->ilevel != octree1->linkT->ilevel) {
					// На разных уровнях.

					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTsosed = 1;
					}
					else if (is_null1(octree1->linkT)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxTsosed = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxTsosed = 4;
						octree1->maxTsosed = c0;
					}
				}
				else if (octree1->ilevel == octree1->linkT->ilevel) {
					// На одинаковых уровнях.
					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTsosed = 1;
					}
					else if (is_null1(octree1->linkT)) {
						// однушка примыкает к четырём четвертинкам.
						octree1->maxTsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxTsosed = 4;
						octree1->maxTsosed = c0 + c1 + c2 + c3;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxTsosed = 0;
			}
		}

		if (octree1->b4B) { // + 2.sept.2016 13.30
			Bmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkB != NULL) {
				//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
				if (octree1->ilevel != octree1->linkB->ilevel) {
					// на разных уровнях.
					octree1->maxBsosed = 1;
				}
				else if (octree1->ilevel == octree1->linkB->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkB)) {
						// 1 остается 1
						octree1->maxBsosed = 1;
					}
					else if (is_null1(octree1->linkB)) {
						// однушка прилегает к четвертушке.
						octree1->maxBsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkB, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxBsosed = c4 + c5 + c6 + c7;
					}
				}
			}
			else {
				// NULL 0 остаётся нулём.
				octree1->maxBsosed = 0;
			}
		}

		break;
	case 5:

		if (octree1->b4B) { // + 2.sept.2016 13.30
			Bmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkB != NULL) {
				//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
				if (octree1->ilevel != octree1->linkB->ilevel) {
					// на разных уровнях.
					octree1->maxBsosed = 1;
				}
				else if (octree1->ilevel == octree1->linkB->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkB)) {
						// 1 остается 1
						octree1->maxBsosed = 1;
					}
					else if (is_null1(octree1->linkB)) {
						// однушка прилегает к четвертушке.
						octree1->maxBsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkB, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxBsosed = c4 + c5 + c6 + c7;
					}
				}
			}
			else {
				// NULL 0 остаётся нулём.
				octree1->maxBsosed = 0;
			}
		}


		if (octree1->b4N) {// + 2.sept.2016 16:18
			Nmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkN != NULL) {
				//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
				if (octree1->ilevel != octree1->linkN->ilevel) {
					// На разных уровнях.

					if (bSituationY) {
						if (is_null(octree1->linkN)) {
							// 1 остаётся 1.
							octree1->maxNsosed = 1;
						}
						else if (is_null1(octree1->linkN)) {
							// две четверные стороны прилегают друг к дружке.
							octree1->maxNsosed = 1;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							// других вариантов быть не может, здесь только 4.
							//octree1->maxNsosed = 4;
							octree1->maxNsosed = c5;
						}
					}
					else {
						octree1->maxNsosed = 1;
					}
				}
				else if (octree1->ilevel == octree1->linkN->ilevel) {
					// На одинаковых уровнях.
					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNsosed = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// одна ячейка прилегает к четверной.
						octree1->maxNsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxNsosed = 4;
						octree1->maxNsosed = c5 + c0 + c1 + c4;
					}

				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxNsosed = 0;
			}
		}




		if (octree1->b4W) { // + 2.sept.2016 13.30
			Wmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkW != NULL) {
				//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
				if (octree1->ilevel != octree1->linkW->ilevel) {
					// на разных уровнях.
					octree1->maxWsosed = 1;
				}
				else if (octree1->ilevel == octree1->linkW->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkW)) {
						// 1 остается 1
						octree1->maxWsosed = 1;
					}
					else if (is_null1(octree1->linkW)) {
						// однушка прилегает к четвертушке.
						octree1->maxWsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxWsosed = c1 + c2 + c5 + c6;
					}
				}
			}
			else {
				// NULL 0 остаётся нулём.
				octree1->maxWsosed = 0;
			}
		}



		if (octree1->b4E) { // +
			Emultisosed_patch(octree1);
		}
		else {
			if (octree1->linkE != NULL) {
				//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
				if (octree1->ilevel != octree1->linkE->ilevel) {
					// На разных уровнях.

					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEsosed = 1;
					}
					else if (is_null1(octree1->linkE)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxEsosed = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxEsosed = c4;
					}
				}
				else if (octree1->ilevel == octree1->linkE->ilevel) {
					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEsosed = 1;
					}
					else if (is_null1(octree1->linkE)) {
						// одинарная ячейка прилегает к четверной.
						octree1->maxEsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxEsosed = c4 + c0 + c3 + c7;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxEsosed = 0;
			}
		}

		if (octree1->b4S) { // +
			Smultisosed_patch(octree1);
		}
		else {
			if (octree1->linkS != NULL) {
				//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
				if (octree1->ilevel != octree1->linkS->ilevel) {
					// На разных уровнях.
					if (is_null(octree1->linkS)) {
						// 1 остаётся 1.
						octree1->maxSsosed = 1;
					}
					else if (is_null1(octree1->linkS)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxSsosed = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxSsosed = 4;
						octree1->maxSsosed = c6;
					}
				}
				else if (octree1->ilevel == octree1->linkS->ilevel) {
					// На одинаковых уровнях.
					if (is_null(octree1->linkS)) {
						// 1 остаётся 1.
						octree1->maxSsosed = 1;
					}
					else if (is_null1(octree1->linkS)) {
						// однва ячейка прилегает к четыврём.
						octree1->maxSsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxSsosed = 4;
						octree1->maxSsosed = c6 + c2 + c3 + c7;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxSsosed = 0;
			}
		}

		if (octree1->b4T) { // + 2 september 2016 16:14
			Tmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkT != NULL) {
				//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
				if (octree1->ilevel != octree1->linkT->ilevel) {
					// На разных уровнях.


					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTsosed = 1; // octree1->maxTsosed;
					}
					else if (is_null1(octree1->linkT)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxTsosed = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxTsosed = 4;
						octree1->maxTsosed = c1;
					}
				}
				else if (octree1->ilevel == octree1->linkT->ilevel) {
					// На одинаковых уровнях.
					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTsosed = 1; // octree1->maxTsosed;
					}
					else if (is_null1(octree1->linkT)) {
						// одинарная ячейка прилегает к четверной.
						octree1->maxTsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxTsosed = 4;
						octree1->maxTsosed = c1 + c0 + c2 + c3;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxTsosed = 0;
			}
		}

		break;
	case 6:

		if (octree1->b4B) { // + 2.sept.2016 13.30
			Bmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkB != NULL) {
				//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
				if (octree1->ilevel != octree1->linkB->ilevel) {
					// на разных уровнях.
					octree1->maxBsosed = 1;
				}
				else if (octree1->ilevel == octree1->linkB->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkB)) {
						// 1 остается 1
						octree1->maxBsosed = 1;
					}
					else if (is_null1(octree1->linkB)) {
						// однушка прилегает к четвертушке.
						octree1->maxBsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkB, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxBsosed = c4 + c5 + c6 + c7;
					}
				}
			}
			else {
				// NULL 0 остаётся нулём.
				octree1->maxBsosed = 0;
			}
		}


		if (octree1->b4S) { // + 2.sept.2016 13.30
			Smultisosed_patch(octree1);
		}
		else {
			if (octree1->linkS != NULL) {
				//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
				if (octree1->ilevel != octree1->linkS->ilevel) {
					// на разных уровнях.
					octree1->maxSsosed = 1;
				}
				else if (octree1->ilevel == octree1->linkS->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkS)) {
						// 1 остается 1
						octree1->maxSsosed = 1;
					}
					else if (is_null1(octree1->linkS)) {
						// однушка прилегает к четвертушке.
						octree1->maxSsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkS, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxSsosed = c2 + c3 + c6 + c7;
					}
				}
			}
			else {
				// NULL 0 остаётся нулём.
				octree1->maxSsosed = 0;
			}
		}


		if (octree1->b4W) { // + 2.sept.2016 13.30
			Wmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkW != NULL) {
				//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
				if (octree1->ilevel != octree1->linkW->ilevel) {
					// на разных уровнях.
					octree1->maxWsosed = 1;
				}
				else if (octree1->ilevel == octree1->linkW->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkW)) {
						// 1 остается 1
						octree1->maxWsosed = 1;
					}
					else if (is_null1(octree1->linkW)) {
						// однушка прилегает к четвертушке.
						octree1->maxWsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxWsosed = c1 + c2 + c5 + c6;
					}
				}
			}
			else {
				// NULL 0 остаётся нулём.
				octree1->maxWsosed = 0;
			}
		}


		if (octree1->b4E) { // +
			Emultisosed_patch(octree1);
		}
		else {
			if (octree1->linkE != NULL) {
				//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
				if (octree1->ilevel != octree1->linkE->ilevel) {
					// На разных уровнях.

					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEsosed = 1;
					}
					else if (is_null1(octree1->linkE)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxEsosed = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxEsosed = c7;
					}
				}
				else if (octree1->ilevel == octree1->linkE->ilevel) {
					// На одном уровнене.
					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEsosed = 1;
					}
					else if (is_null1(octree1->linkE)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxEsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxEsosed = c7 + c0 + c3 + c4;
					}

				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxEsosed = 0;
			}
		}

		if (octree1->b4N) {  // +
			Nmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkN != NULL) {
				//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
				if (octree1->ilevel != octree1->linkN->ilevel) {
					// На разных уровнях.

					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNsosed = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxNsosed = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxNsosed = 4;
						octree1->maxNsosed = c5;
					}
				}
				else if (octree1->ilevel == octree1->linkN->ilevel) {
					// На одном уровне.

					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNsosed = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxNsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxNsosed = 4;
						octree1->maxNsosed = c5 + c0 + c1 + c4;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxNsosed = 0;
			}
		}

		if (octree1->b4T) { // + 2 sept 2016 15:33
			Tmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkT != NULL) {
				//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
				if (octree1->ilevel != octree1->linkT->ilevel) {
					// На разных уровнях.

					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTsosed = 1;
					}
					else if (is_null1(octree1->linkT)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxTsosed = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxTsosed = 4;
						octree1->maxTsosed = c2;
					}
				}
				else if (octree1->ilevel == octree1->linkT->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTsosed = 1;
					}
					else if (is_null1(octree1->linkT)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxTsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxTsosed = 4;
						octree1->maxTsosed = c2 + c0 + c1 + c3;
					}

				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxTsosed = 0;
			}
		}
		break;
	case 7:


		if (octree1->b4B) { // + 2.sept.2016 13.30
			Bmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkB != NULL) {
				//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
				if (octree1->ilevel != octree1->linkB->ilevel) {
					// на разных уровнях.
					octree1->maxBsosed = 1;
				}
				else if (octree1->ilevel == octree1->linkB->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkB)) {
						// 1 остается 1
						octree1->maxBsosed = 1;
					}
					else if (is_null1(octree1->linkB)) {
						// однушка прилегает к четвертушке.
						octree1->maxBsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkB, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxBsosed = c1 + c2 + c5 + c6;
					}
				}
			}
			else {
				// NULL 0 остаётся нулём.
				octree1->maxBsosed = 0;
			}
		}


		if (octree1->b4S) { // + 2.sept.2016 13.30
			Smultisosed_patch(octree1);
		}
		else {
			if (octree1->linkS != NULL) {
				//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
				if (octree1->ilevel != octree1->linkS->ilevel) {
					// на разных уровнях.
					octree1->maxSsosed = 1;
				}
				else if (octree1->ilevel == octree1->linkS->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkS)) {
						// 1 остается 1
						octree1->maxSsosed = 1;
					}
					else if (is_null1(octree1->linkS)) {
						// однушка прилегает к четвертушке.
						octree1->maxSsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkS, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxSsosed = c1 + c2 + c5 + c6;
					}
				}
			}
			else {
				// NULL 0 остаётся нулём.
				octree1->maxSsosed = 0;
			}
		}

		if (octree1->b4E) { // +
			Emultisosed_patch(octree1);
		}
		else {
			if (octree1->linkE != NULL) {
				//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
				if (octree1->ilevel != octree1->linkE->ilevel) {
					// На разных уровнях.
					if (bSituationX) {

						if (octree1->linkE != NULL) {
							if (is_null(octree1->linkE)) {
								// 1 остаётся 1.
								octree1->maxEsosed = 1;
							}
							else if (is_null1(octree1->linkE)) {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxEsosed = 1;
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								// других вариантов быть не может, здесь только 4.
								//octree1->maxEsosed = 4;
								octree1->maxEsosed = c7;
							}
						}
						else {
							// 0 остаётся 0.
							octree1->maxEsosed = 0;
						}
					}
					else {
						octree1->maxEsosed = 1;
					}
				}
				else if (octree1->ilevel == octree1->linkE->ilevel) {
					// На одинаковых уровнях.
					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEsosed = 1;
					}
					else if (is_null1(octree1->linkE)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxEsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEsosed = 4;
						octree1->maxEsosed = c7 + c0 + c4 + c3;
					}
				}
			}
			else {
				// NULL
				// 0 остаётся 0.
				octree1->maxEsosed = 0;
			}
		}

		if (octree1->b4W) { // +
			Wmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkW != NULL) {
				//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
				if (octree1->ilevel != octree1->linkW->ilevel) {
					// На разных уровнях


					if (is_null(octree1->linkW)) {
						// 1 остаётся 1.
						octree1->maxWsosed = 1;
					}
					else if (is_null1(octree1->linkW)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxWsosed = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxWsosed = 4;
						octree1->maxWsosed = c6;
					}
				}
				else if (octree1->ilevel == octree1->linkW->ilevel) {
					// На одинаковых уровнях
					if (is_null(octree1->linkW)) {
						// 1 остаётся 1.
						octree1->maxWsosed = 1;
					}
					else if (is_null1(octree1->linkW)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxWsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxWsosed = 4;
						octree1->maxWsosed = c6 + c1 + c5 + c2;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxWsosed = 0;
			}
		}


		if (octree1->b4N) { // +
			Nmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkN != NULL) {
				//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
				if (octree1->ilevel != octree1->linkN->ilevel) {
					// На разных уровнях.

					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNsosed = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxNsosed = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxNsosed = 4;
						octree1->maxNsosed = c4;
					}
				}
				else if (octree1->ilevel == octree1->linkN->ilevel) {
					// На одинаковых уровнях.
					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNsosed = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// Единичка прилегает к четвертушке.
						octree1->maxNsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxNsosed = 4;
						octree1->maxNsosed = c4 + c0 + c1 + c5;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxNsosed = 0;
			}
		}


		if (octree1->b4T) { // + 2.sept.2016 15:57
			Tmultisosed_patch(octree1);
		}
		else {
			if (octree1->linkT != NULL) {
				//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
				if (octree1->ilevel != octree1->linkT->ilevel) {
					// На разных уровнях.
					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTsosed = 1;
					}
					else if (is_null1(octree1->linkT)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxTsosed = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxTsosed = 4;
						octree1->maxTsosed = c3;
					}
				}
				else if (octree1->ilevel == octree1->linkT->ilevel) {
					// На одинаковых уровнях.
					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTsosed = 1;
					}
					else if (is_null1(octree1->linkT)) {
						// Единичка примыкает к четырём соседяим.
						octree1->maxTsosed = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxTsosed = 4;
						octree1->maxTsosed = c3 + c0 + c1 + c2;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxTsosed = 0;
			}
		}
		break;
	default: 
#if doubleintprecision == 1
		printf("error : root=%lld\n", octree1->root);
#else
		printf("error : root=%d\n", octree1->root);
#endif
		
		//getchar();
		system("PAUSE");
		exit(1);
		break;
	}
	// закончили работать.
	//octree1 = NULL;
}

// После каждого сканирования листьев всего дерева мы должны 
// восстановить соседвенные связи т.к. они  изменились после дробления.
void update_max_count_sosed(octTree* &oc) {
	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {
				//if (my_ALICE_STACK[top_ALICE_STACK - 1].link->b_the_geometric_fragmentation == true) {


					octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;

					// разбиение на 8.
					integer minx = my_ALICE_STACK[top_ALICE_STACK - 1].minx;
					integer maxx = my_ALICE_STACK[top_ALICE_STACK - 1].maxx;
					integer miny = my_ALICE_STACK[top_ALICE_STACK - 1].miny;
					integer maxy = my_ALICE_STACK[top_ALICE_STACK - 1].maxy;
					integer minz = my_ALICE_STACK[top_ALICE_STACK - 1].minz;
					integer maxz = my_ALICE_STACK[top_ALICE_STACK - 1].maxz;

					// Дробление  вызывается.
					my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
					top_ALICE_STACK--;

					// octree1 это лист. Situation это ситуация в octree1->parent.
					//printf("incomming update_max_count_sosed");
					//getchar();
					bool bSituationX = octree1->brootSituationX;
					bool bSituationY = octree1->brootSituationY;
					bool bSituationZ = octree1->brootSituationZ;
					//bool bSituationX = octree1->brootSituationX_virtual;
					//bool bSituationY = octree1->brootSituationY_virtual;
					//bool bSituationZ = octree1->brootSituationZ_virtual;
					//octree1->brootSituationX= octree1->brootSituationX_virtual;
					//octree1->brootSituationY = octree1->brootSituationY_virtual;
					//octree1->brootSituationZ = octree1->brootSituationZ_virtual;

					bool bonly_dir_X = false;
					bool bonly_dir_Y = false;
					bool bonly_dir_Z = false;
					if (bSituationX && (bSituationY) && (!bSituationZ)) {
						bonly_dir_Z = true;
					}
					if (bSituationX && (bSituationZ) && (!bSituationY)) {
						bonly_dir_Y = true;
					}
					if (bSituationY && (bSituationZ) && (!bSituationX)) {
						bonly_dir_X = true;
					}

					// 0 остаётся 0.
					// Если что-то неопределённое то соседа просто нет
					octree1->maxTsosed = 0;
					octree1->maxBsosed = 0;
					octree1->maxNsosed = 0;
					octree1->maxSsosed = 0;
					octree1->maxEsosed = 0;
					octree1->maxWsosed = 0;

					// работаем с octree1
					switch (octree1->root) {
					case 0: 

						if (octree1->b4T) { // + 2.09.2016 12.30
							Tmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkT != NULL) {
								//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
								if (octree1->ilevel != octree1->linkT->ilevel) {
									// На разных уровнях.
									if (bSituationZ) {
										// Вырождение по OZ.

										if (octree1->linkT != NULL) {
											if (is_null(octree1->linkT)) {
												// 1 остаётся 1.
												octree1->maxTsosed = 1;
											}
											else if (is_null1(octree1->linkT)) {

												if ((bonly_dir_X) || (bonly_dir_Y)) {
													octree1->maxTsosed = 2;
												}
												else {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxTsosed = 1;
												}
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												if ((bonly_dir_X) || (bonly_dir_Y)) {
													if (bonly_dir_X) {
														// дробим только по оси Ох.
														octree1->maxTsosed = c0 + c3;
													}
													if (bonly_dir_Y) {
														// дробим только по оси Oy.
														octree1->maxTsosed = c0 + c1;
													}
												}
												else {
													//octree1->maxTsosed = 4;
													octree1->maxTsosed = c0;
												}
											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxTsosed = 0;
										}

									}
									else {
										// это была внутренняя ячейка.
										octree1->maxTsosed = 1;

									}
								}
								else if (octree1->ilevel == octree1->linkT->ilevel) {
									// На одном уровне.
									if (octree1->linkT != NULL) {
										if (is_null(octree1->linkT)) {
											// 1 остаётся 1.
											octree1->maxTsosed = 1;
										}
										else if (is_null1(octree1->linkT)) {
												octree1->maxTsosed = 4;
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											
												//octree1->maxTsosed = 4;
												octree1->maxTsosed = c0+c1+c2+c3;
										}
									}
									else {
										// 0 остаётся 0.
										octree1->maxTsosed = 0;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxTsosed = 0;
							}
						}

							// root==0	
							if (octree1->b4N) {// + 2.09.2016 12.30
								Nmultisosed_patch(octree1);
							}
							else {
								if (octree1->linkN != NULL) {
									//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
									if (octree1->ilevel != octree1->linkN->ilevel ) {
										// На разных уровнях.
										if (bSituationY) {

											if (octree1->linkN != NULL) {
												if (is_null(octree1->linkN)) {
													// 1 остаётся 1.
													octree1->maxNsosed = 1;
												}
												else if (is_null1(octree1->linkN)) {
													if ((bonly_dir_X) || (bonly_dir_Z)) {
														octree1->maxNsosed = 2;
													}
													else {
														// две четверные стороны прилегают друг к дружке.
														octree1->maxNsosed = 1;
													}
												}
												else {
													// других вариантов быть не может, здесь только 4.
													// может быть 2, 4, 5, 8
													// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
													integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
													is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
													if ((bonly_dir_X) || (bonly_dir_Z)) {
														if (bonly_dir_X) {
															octree1->maxNsosed = c0 + c4;
														}
														if (bonly_dir_Z) {
															octree1->maxNsosed = c0 + c1;
														}
													}
													else {
														// других вариантов быть не может, здесь только 4.
														//octree1->maxNsosed = 4;
														octree1->maxNsosed = c0;
													}
												}
											}
											else {
												// 0 остаётся 0.
												octree1->maxNsosed = 0;
											}

										}
										else {
											octree1->maxNsosed = 1;
										}

									}
									else if (octree1->ilevel == octree1->linkN->ilevel) {
										// На одном уровне.

										if (octree1->linkN != NULL) {
											if (is_null(octree1->linkN)) {
												// 1 остаётся 1.
												octree1->maxNsosed = 1;
											}
											else if (is_null1(octree1->linkN)) {

												// две четверные стороны прилегают друг к дружке.
												octree1->maxNsosed = 4;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);

												// других вариантов быть не может, здесь только 4.
												//octree1->maxNsosed = 4;
												octree1->maxNsosed = c0 + c1 + c4 + c5;

											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxNsosed = 0;
										}

									}
								}
								else {
									// 0 остаётся 0.
									octree1->maxNsosed = 0;
								}
							}


							if (octree1->b4E) {
								// 4 соседа.
								Emultisosed_patch(octree1);
							}
							else {
								if (octree1->linkE != NULL) {
									//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
									if (octree1->ilevel != octree1->linkE->ilevel) {
										// На разных уровнях.
										if (bSituationX) {


											if (octree1->linkE != NULL) {
												if (is_null(octree1->linkE)) {
													// 1 остаётся 1.
													octree1->maxEsosed = 1;
												}
												else if (is_null1(octree1->linkE)) {
													if ((bonly_dir_Z) || (bonly_dir_Y)) {
														octree1->maxEsosed = 2;
													}
													else {
														// две четверные стороны прилегают друг к дружке.
														octree1->maxEsosed = 1;
													}
												}
												else {
													// других вариантов быть не может, здесь только 4.
													// может быть 2, 4, 5, 8
													// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
													integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
													is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
													if ((bonly_dir_Y) || (bonly_dir_Z)) {
														if (bonly_dir_Y) {
															// дробим только по оси Oy.
															octree1->maxEsosed = c0 + c4;
														}
														if (bonly_dir_Z) {
															// дробим только по оси Oz.
															octree1->maxEsosed = c0 + c3;
														}
													}
													else {
														// других вариантов быть не может, здесь только 4.
														//octree1->maxEsosed = 4;
														octree1->maxEsosed = c0;
													}
												}
											}
											else {
												// 0 остаётся 0.
												octree1->maxEsosed = 0;
											}

										}
										else {
											octree1->maxEsosed = 1;
										}
									}
									else if (octree1->ilevel == octree1->linkE->ilevel) {
										// На одном уровне.
										if (octree1->linkE != NULL) {
											if (is_null(octree1->linkE)) {
												// 1 остаётся 1.
												octree1->maxEsosed = 1;
											}
											else if (is_null1(octree1->linkE)) {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxEsosed = 4;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												
													// других вариантов быть не может, здесь только 4.
													//octree1->maxEsosed = 4;
													octree1->maxEsosed = c0+c3+c4+c7;
												
											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxEsosed = 0;
										}
									}
								}
								else {
									// NULL 
									// 0 остаётся 0.
									octree1->maxEsosed = 0;
								}
							}

							if (octree1->b4W) {
								// 4 соседа.
								Wmultisosed_patch(octree1);
							}
							else {
								// Должно быть уменьшение при дроблении:
								if (octree1->linkW != NULL) {
									//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
									if (octree1->ilevel != octree1->linkW->ilevel) {
										// На разных уровнях.

										if (bSituationY && (!bSituationX) && (!bSituationZ)) {
											if (is_null(octree1->linkW)) {
												// 1 остаётся 1.
												octree1->maxWsosed = 1;
											}
											else if (is_null1(octree1->linkW)) {
												// двойная прилегает к четверной.
												octree1->maxWsosed = 2;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												octree1->maxWsosed = c1 + c2;
											}
										}
										else if (bSituationZ && (!bSituationX) && (!bSituationY)) {
											if (is_null(octree1->linkW)) {
												// 1 остаётся 1.
												octree1->maxWsosed = 1;
											}
											else if (is_null1(octree1->linkW)) {
												// двойная прилегает к четверной.
												octree1->maxWsosed = 2;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												octree1->maxWsosed = c1 + c5;
											}
										}
										else {
											if (is_null(octree1->linkW)) {
												// 1 остаётся 1.
												octree1->maxWsosed = 1;
											}
											else if (is_null1(octree1->linkW)) {
												if (bonly_dir_Y){
													octree1->maxWsosed = 2;
												}
												else if (bonly_dir_Z) {
													octree1->maxWsosed = 2;
												}
												else {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxWsosed = 1;
												}
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												// других вариантов быть не может, здесь только 4.
												//octree1->maxWsosed = 4;
												if (bonly_dir_Y) {
													octree1->maxWsosed = c1 + c5;
												}
												else if (bonly_dir_Z) {
													octree1->maxWsosed = c1 + c2;
												}
												else {
													octree1->maxWsosed = c1;
												}

											}
										}
									}
									else if (octree1->ilevel == octree1->linkW->ilevel) {
										// На одном уровне.
										if (is_null(octree1->linkW)) {
											// 1 остаётся 1.
											octree1->maxWsosed = 1;
										}
										else if (is_null1(octree1->linkW)) {
											// две четверные стороны прилегают друг к дружке.
											octree1->maxWsosed = 4;
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											// других вариантов быть не может, здесь только 4.
											//octree1->maxWsosed = 4;
											octree1->maxWsosed = c1+c2+c5+c6;

										}
									}
								}
								else {
									// 0 остаётся 0.
									octree1->maxWsosed = 0; 
								}
							}


							if (octree1->b4S) {
								// 4 соседа.
								Smultisosed_patch(octree1);
							}
							else {
								if (octree1->linkS != NULL) {
									//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
									if (octree1->ilevel != octree1->linkS->ilevel) {
									    // На разных уровнях.


										if (bSituationX && (!bSituationY) && (!bSituationZ)) {
											if (is_null(octree1->linkS)) {
												// 1 остаётся 1.
												octree1->maxSsosed = 1;
											}
											else if (is_null1(octree1->linkS)) {
												// двойная прилегает к четверной.
												octree1->maxSsosed = 2;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												octree1->maxSsosed = c3 + c2;
											}
										}
										else if (bSituationZ && (!bSituationX) && (!bSituationY)) {
											if (is_null(octree1->linkS)) {
												// 1 остаётся 1.
												octree1->maxSsosed = 1;
											}
											else if (is_null1(octree1->linkS)) {
												// двойная прилегает к четверной.
												octree1->maxSsosed = 2;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												octree1->maxSsosed = c3 + c7;
											}
										}
										else {
											if (is_null(octree1->linkS)) {
												// 1 остаётся 1.
												octree1->maxSsosed = 1;
											}
											else if (is_null1(octree1->linkS)) {
												if (bonly_dir_Z) {
													octree1->maxSsosed = 2;
												}
												else if (bonly_dir_X) {
													octree1->maxSsosed = 2;
												}
												else {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxSsosed = 1;
												}
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												// других вариантов быть не может, здесь только 4.
												if (bonly_dir_Z) {
													octree1->maxSsosed = c3 + c2;
												}
												else if (bonly_dir_X) {
													octree1->maxSsosed = c3 + c7;
												}
												else {
													//octree1->maxSsosed = 4;
													octree1->maxSsosed = c3;
												}
											}
										}
									}
									else if (octree1->ilevel == octree1->linkS->ilevel) {
										// На одном уровне.
										if (is_null(octree1->linkS)) {
											// 1 остаётся 1.
											octree1->maxSsosed = 1;
										}
										else if (is_null1(octree1->linkS)) {
											// Один контачит с четырьмя.
												octree1->maxSsosed = 4;
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											// других вариантов быть не может, здесь только 4.
											
											//octree1->maxSsosed = 4;
											octree1->maxSsosed = c3+c2+c6+c7;
										}
									}
								}
								else {
									// 0 остаётся 0.
									octree1->maxSsosed = 0;
								}
							}

							if (octree1->b4B) {
								// 4 соседа.
								Bmultisosed_patch(octree1);
							}
							else {
								if (octree1->linkB != NULL) {
									//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
									if (octree1->ilevel != octree1->linkB->ilevel) {
										// На разных уровнях.


										if (bSituationY && (!bSituationX) && (!bSituationZ)) {
											if (is_null(octree1->linkB)) {
												// 1 остаётся 1.
												octree1->maxBsosed = 1;
											}
											else if (is_null1(octree1->linkB)) {
												// двойная прилегает к четверной.
												octree1->maxBsosed = 2;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												octree1->maxBsosed = c4 + c7;
											}
										}
										else if (bSituationX && (!bSituationY) && (!bSituationZ)) {
											if (is_null(octree1->linkB)) {
												// 1 остаётся 1.
												octree1->maxBsosed = 1;
											}
											else if (is_null1(octree1->linkB)) {
												// двойная прилегает к четверной.
												octree1->maxBsosed = 2;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												octree1->maxBsosed = c4 + c5;
											}
										}
										else {
											if (is_null(octree1->linkB)) {
												// 1 остаётся 1.
												octree1->maxBsosed = 1;
											}
											else if (is_null1(octree1->linkB)) {
												if (bonly_dir_Y) {
													octree1->maxBsosed = 2;
												}
												else if (bonly_dir_X) {
													octree1->maxBsosed = 2;
												}
												else {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxBsosed = 1;
												}
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												if (bonly_dir_Y) {
													octree1->maxBsosed = c4 + c5;
												}
												else if (bonly_dir_X) {
													octree1->maxBsosed = c4 + c7;
												}
												else {
													// других вариантов быть не может, здесь только 4.
													//octree1->maxBsosed = 4;
													octree1->maxBsosed = c4;
												}
											}
										}
									}
									else if (octree1->ilevel == octree1->linkB->ilevel) {
										if (is_null(octree1->linkB)) {
											// 1 остаётся 1.
											octree1->maxBsosed = 1;
										}
										else if (is_null1(octree1->linkB)) {
												// однушка прилегает к четырём четвертинкам.
												octree1->maxBsosed = 4;
											
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											
												// других вариантов быть не может, здесь только 4.
												//octree1->maxBsosed = 4;
												octree1->maxBsosed = c4+c5+c6+c7;
											
										}
									}
								}
								else {
									// 0 остаётся 0.
									octree1->maxBsosed = 0;
								}
							}
							break;
					case 1:

						if (octree1->b4T) { // +
							// 4 соседа.
							Tmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkT != NULL) {
								//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
								if (octree1->ilevel != octree1->linkT->ilevel) {
									// На разных уровнях.

									if (bSituationZ) {


										// Вырождение по OZ.
										if (octree1->linkT != NULL) {
											if (is_null(octree1->linkT)) {
												// 1 остаётся 1.
												octree1->maxTsosed = 1;
											}
											else if (is_null1(octree1->linkT)) {
												if (bonly_dir_X) {
													octree1->maxTsosed = 2;
												}
												else {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxTsosed = 1;
												}
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												if ((bonly_dir_X)) {
													if (bonly_dir_X) {
														// дробим только по оси Oy.
														octree1->maxTsosed = c1 + c2;
													}
												}
												else {
													// других вариантов быть не может, здесь только 4.
													// может быть  2, 4, 5, 8
													//octree1->maxTsosed = 4;
													octree1->maxTsosed = c1;
												}
											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxTsosed = 0;
										}
									}
									else {
										octree1->maxTsosed = 1;
									}
								}
								else if (octree1->ilevel == octree1->linkT->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTsosed = 1;
									}
									else if (is_null1(octree1->linkT)) {
											// однушка прилегает к четвертушке.
											octree1->maxTsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										
											// других вариантов быть не может, здесь только 4.
											// может быть  2, 4, 5, 8
											//octree1->maxTsosed = 4;
											octree1->maxTsosed = c1+c0+c2+c3;
										
									}
								}
							}
							else {
								// NULL
								// 0 остаётся 0.
								octree1->maxTsosed = 0;
							}
						}

						if (octree1->b4N) { // + 2.sept.2016 13.59
							// 4 соседа.
							Nmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkN != NULL) {
								//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
								if (octree1->ilevel != octree1->linkN->ilevel) {
									// На разных уровнях.
									if (bSituationY) {


										if (octree1->linkN != NULL) {
											if (is_null(octree1->linkN)) {
												// 1 остаётся 1.
												octree1->maxNsosed = 1;
											}
											else if (is_null1(octree1->linkN)) {
												if (bonly_dir_X) {
													octree1->maxNsosed = 2;
												}
												else {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxNsosed = 1;
												}
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												if ((bonly_dir_X)) {
													if (bonly_dir_X) {
														// дробим только по оси Oy.
														octree1->maxNsosed = c1 + c5;
													}
												}
												else {
													// других вариантов быть не может, здесь только 4.
													//octree1->maxNsosed = 4;
													octree1->maxNsosed = c1;
												}
											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxNsosed = 0;
										}

									}
									else {
										octree1->maxNsosed = 1;
									}
								}
								else if (octree1->ilevel == octree1->linkN->ilevel) {
									// На одном уровне.

									if (is_null(octree1->linkN)) {
										// 1 остаётся 1.
										octree1->maxNsosed = 1;
									}
									else if (is_null1(octree1->linkN)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxNsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										
										// других вариантов быть не может, здесь только 4.
										//octree1->maxNsosed = 4;
										octree1->maxNsosed = c1+c0+c4+c5;
										
									}
								}
							}
							else {
								// NULL.
								// 0 остаётся 0.
								octree1->maxNsosed = 0;
							}
						}

						if (octree1->b4W) { // + 2.sept.2016 13.30
							Wmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkW != NULL) {
								//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
								if (octree1->ilevel != octree1->linkW->ilevel) {
									// на разных уровнях.
									octree1->maxWsosed = 1;
								}
								else if (octree1->ilevel == octree1->linkW->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkW)) {
										// 1 остается 1
										octree1->maxWsosed = 1;
									}
									else if (is_null1(octree1->linkW)) {
										// однушка прилегает к четвертушке.
										octree1->maxWsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxWsosed = c1+c2+c5+c6;
									}
								}
							}
							else {
								// NULL 0 остаётся нулём.
								octree1->maxWsosed = 0;
							}
						}
						


						if (octree1->b4E) {// +
							// 4 соседа.
							Emultisosed_patch(octree1);
						}
						else {
							// Должно быть уменьшение при дроблении:
							if (octree1->linkE != NULL) {
								//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
								if (octree1->ilevel != octree1->linkE->ilevel) {
									// На разных уровнях.

									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEsosed = 1;
									}
									else if (is_null1(octree1->linkE)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxEsosed = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxEsosed = c0;
									}
								}
								else if (octree1->ilevel == octree1->linkE->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEsosed = 1;
									}
									else if (is_null1(octree1->linkE)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxEsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxEsosed = c0+c3+c4+c7;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxEsosed = 0;
							}
						}


						if (octree1->b4S) {// +
							// 4 соседа.
							Smultisosed_patch(octree1);
						}
						else {
							if (octree1->linkS != NULL) {
								//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
								if (octree1->ilevel != octree1->linkS->ilevel) {
									// На разных уровнях.


									if (bSituationZ && (!bSituationX) && (!bSituationY)) {
										if (is_null(octree1->linkS)) {
											// 1 остаётся 1.
											octree1->maxSsosed = 1;
										}
										else if (is_null1(octree1->linkS)) {
											// двойная прилегает к четверной.
											octree1->maxSsosed = 2;
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											octree1->maxSsosed = c2 + c6;
										}
									}
									else {
										if (is_null(octree1->linkS)) {
											// 1 остаётся 1.
											octree1->maxSsosed = 1;
										}
										else if (is_null1(octree1->linkS)) {
											if (bonly_dir_X) {
												octree1->maxSsosed = 2;
											}
											else {
												// две четверные стороны прилегают друг к дружке.
												octree1->maxSsosed = 1;
											}
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											if (bonly_dir_X) {
												octree1->maxSsosed = c2 + c6;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												//octree1->maxSsosed = 4;
												octree1->maxSsosed = c2;
											}
										}
									}
								}
								else if (octree1->ilevel == octree1->linkS->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkS)) {
										// 1 остаётся 1.
										octree1->maxSsosed = 1;
									}
									else if (is_null1(octree1->linkS)) {
											// однушка прилегает к четвертушке.
											octree1->maxSsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										
										// других вариантов быть не может, здесь только 4.
										//octree1->maxSsosed = 4;
										octree1->maxSsosed = c2+c3+c6+c7;
										
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxSsosed = 0;
							}
						}

						if (octree1->b4B) {// +
							// 4 соседа.
							Bmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkB != NULL) {
								//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
								if (octree1->ilevel != octree1->linkB->ilevel) {
								    // На разных уровнях.


									if (bSituationY && (!bSituationX) && (!bSituationZ)) {
										if (is_null(octree1->linkB)) {
											// 1 остаётся 1.
											octree1->maxBsosed = 1;
										}
										else if (is_null1(octree1->linkB)) {
											// двойная прилегает к четверной.
											octree1->maxBsosed = 2;
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											octree1->maxBsosed = c5 + c6;
										}
									}
									else {
										if (is_null(octree1->linkB)) {
											// 1 остаётся 1.
											octree1->maxBsosed = 1;
										}
										else if (is_null1(octree1->linkB)) {
											if (bonly_dir_X) {
												octree1->maxBsosed = 2;
											}
											else {
												// две четверные стороны прилегают друг к дружке.
												octree1->maxBsosed = 1;
											}
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											if (bonly_dir_X) {
												octree1->maxBsosed = c5 + c6;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												//octree1->maxBsosed = 4;
												octree1->maxBsosed = c5;
											}
										}
									}
								}
								else if (octree1->ilevel == octree1->linkB->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkB)) {
										// 1 остаётся 1.
										octree1->maxBsosed = 1;
									}
									else if (is_null1(octree1->linkB)) {
											// однушка прилегает к четветушке.
											octree1->maxBsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										
											// других вариантов быть не может, здесь только 4.
											//octree1->maxBsosed = 4;
											octree1->maxBsosed = c5+c4+c6+c7;
										
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxBsosed = 0;
							}
						}
						break;
					case 2:


						if (octree1->b4T) { // +
							// 4 соседа.
							Tmultisosed_patch(octree1);
						}
						else {

							if (octree1->linkT != NULL) {
								//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
								if (octree1->ilevel != octree1->linkT->ilevel) {
								    // На разных уровнях.


									if (bSituationZ) {
										// Вырождение по OZ.


										if (octree1->linkT != NULL) {
											if (is_null(octree1->linkT)) {
												// 1 остаётся 1.
												octree1->maxTsosed = 1;
											}
											else if (is_null1(octree1->linkT)) {
												// две четверные стороны прилегают друг к дружке.
												octree1->maxTsosed = 1;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												// других вариантов быть не может, здесь только 4.
												//octree1->maxTsosed = 4;
												octree1->maxTsosed = c2;
											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxTsosed = 0;
										}

									}
									else {
										octree1->maxTsosed = 1;
									}
								}
								else if (octree1->ilevel == octree1->linkT->ilevel) {
									// На одном уровне.

									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTsosed = 1;
									}
									else if (is_null1(octree1->linkT)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxTsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxTsosed = 4;
										octree1->maxTsosed = c2 + c0 + c1 + c3;
									}
								}

							}
							else {
								// NULL
								// 0 остаётся 0.
								octree1->maxTsosed = 0;
							}
						}


						
						if (octree1->b4S) { // + 2.sept.2016 13.30
							Smultisosed_patch(octree1);
						}
						else {
							if (octree1->linkS != NULL) {
								//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
								if (octree1->ilevel != octree1->linkS->ilevel) {
									// на разных уровнях.
									octree1->maxSsosed = 1;
								}
								else if (octree1->ilevel == octree1->linkS->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkS)) {
										// 1 остается 1
										octree1->maxSsosed = 1;
									}
									else if (is_null1(octree1->linkS)) {
										// однушка прилегает к четвертушке.
										octree1->maxSsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxSsosed = c6 + c7 + c2 + c3;
									}
								}
							}
							else {
								// NULL 0 остаётся нулём.
								octree1->maxSsosed = 0;
							}
						}


						if (octree1->b4W) { // + 2.sept.2016 13.30
							Wmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkW != NULL) {
								//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
								if (octree1->ilevel != octree1->linkW->ilevel) {
								    // на разных уровнях.
									octree1->maxWsosed = 1;
								}
								else if (octree1->ilevel == octree1->linkW->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkW)) {
										// 1 остается 1
										octree1->maxWsosed = 1;
									}
									else if (is_null1(octree1->linkW)) {
										// однушка прилегает к четвертушке.
										octree1->maxWsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxWsosed = c1 + c2 + c5 + c6;
									}
								}
							}
							else {
								// NULL 0 остаётся нулём.
								octree1->maxWsosed = 0;
							}
						}


						if (octree1->b4E) { // + 2.sept.2016 14:27
							// 4 соседа.
							Emultisosed_patch(octree1);
						}
						else {
							// Должно быть уменьшение при дроблении:
							if (octree1->linkE != NULL) {
								//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
								if (octree1->ilevel != octree1->linkE->ilevel) {
								    // На разных уровнях.

									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEsosed = 1;
									}
									else if (is_null1(octree1->linkE)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxEsosed = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxEsosed = c3;
									}
								}
								else if (octree1->ilevel == octree1->linkE->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEsosed = 1;
									}
									else if (is_null1(octree1->linkE)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxEsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxEsosed = c3 + c0 + c4 + c7;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxEsosed = 0;
							}
						}


						if (octree1->b4N) {// + 
							// 4 соседа.
							Nmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkN != NULL) {
								//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
								if (octree1->ilevel != octree1->linkN->ilevel) {
								    // На разных уровнях.

									if (is_null(octree1->linkN)) {
										// 1 остаётся 1.
										octree1->maxNsosed = 1;
									}
									else if (is_null1(octree1->linkN)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxNsosed = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);

										// других вариантов быть не может, здесь только 4.
										//octree1->maxNsosed = 4;
										octree1->maxNsosed = c1;
									}
								}
								else if (octree1->ilevel == octree1->linkN->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkN)) {
										// 1 остаётся 1.
										octree1->maxNsosed = 1;
									}
									else if (is_null1(octree1->linkN)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxNsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);

										// других вариантов быть не может, здесь только 4.
										//octree1->maxNsosed = 4;
										octree1->maxNsosed = c1 + c0 + c4 + c5;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxNsosed = 0;
							}
						}


						if (octree1->b4B) {
							// 4 соседа.
							Bmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkB != NULL) {
								//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
								if (octree1->ilevel != octree1->linkB->ilevel) {

									if (is_null(octree1->linkB)) {
										// 1 остаётся 1.
										octree1->maxBsosed = 1;
									}
									else if (is_null1(octree1->linkB)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxBsosed = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxBsosed = 4;
										octree1->maxBsosed = c6;
									}
								}
								else if (octree1->ilevel == octree1->linkB->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkB)) {
										// 1 остаётся 1.
										octree1->maxBsosed = 1;
									}
									else if (is_null1(octree1->linkB)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxBsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxBsosed = 4;
										octree1->maxBsosed = c6+c5+c7+c4;
									}

								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxBsosed = 0;
							}
						}


						break;
					case 3:

						if (octree1->b4T) {  // + 2.september 2016 17:47
							Tmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkT != NULL) {
								//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
								if (octree1->ilevel != octree1->linkT->ilevel) {
									// На разных уровнях.


									if (bSituationZ) {
										// Вырождение по OZ.

										if (octree1->linkT != NULL) {
											if (is_null(octree1->linkT)) {
												// 1 остаётся 1.
												octree1->maxTsosed = 1;
											}
											else if (is_null1(octree1->linkT)) {
												if (bonly_dir_Y) {
													octree1->maxTsosed = 2;
												}
												else {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxTsosed = 1;
												}
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												if ((bonly_dir_Y)) {
													if (bonly_dir_Y) {
														// дробим только по оси Oy.
														octree1->maxTsosed = c3 + c2;
													}
												}
												else {
													// других вариантов быть не может, здесь только 4.
													// может быть 2, 4, 5, 8.
													//octree1->maxTsosed = 4;
													octree1->maxTsosed = c3;
												}
											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxTsosed = 0;
										}

									}
									else {
										octree1->maxTsosed = 1;
									}
								}
								else if (octree1->ilevel == octree1->linkT->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTsosed = 1;
									}
									else if (is_null1(octree1->linkT)) {
										
											// Целая прилегает к четырём четвертинкам.
											octree1->maxTsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8.
											//octree1->maxTsosed = 4;
											octree1->maxTsosed = c3 + c0 + c1 + c2;
									}
								}
							}
							else {
								// NULL:
								// 0 остаётся 0.
								octree1->maxTsosed = 0;
							}
						}
						

						if (octree1->b4S) { // + 2.sept.2016 13.30
							Smultisosed_patch(octree1);
						}
						else {
							if (octree1->linkS != NULL) {
								//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
								if (octree1->ilevel != octree1->linkS->ilevel) {
								    // на разных уровнях.
									octree1->maxSsosed = 1;
								}
								else if (octree1->ilevel == octree1->linkS->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkS)) {
										// 1 остается 1
										octree1->maxSsosed = 1;
									}
									else if (is_null1(octree1->linkS)) {
										// однушка прилегает к четвертушке.
										octree1->maxSsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkS, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxSsosed = c2 + c3 + c6 + c7;
									}
								}
							}
							else {
								// NULL 0 остаётся нулём.
								octree1->maxSsosed = 0;
							}
						}


						if (octree1->b4E) { // + 2.september.2016 17:41
							Emultisosed_patch(octree1);
						}
						else {
							if (octree1->linkE != NULL) {
								//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
								if (octree1->ilevel != octree1->linkE->ilevel) {
									// На разных уровнях.

									if (bSituationX) {


										if (octree1->linkE != NULL) {
											if (is_null(octree1->linkE)) {
												// 1 остаётся 1.
												octree1->maxEsosed = 1;
											}
											else if (is_null1(octree1->linkE)) {
												if (bonly_dir_Y) {
													octree1->maxEsosed = 2;
												}
												else {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxEsosed = 1;
												}
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												if ((bonly_dir_Y)) {
													if (bonly_dir_Y) {
														// дробим только по оси Oy.
														octree1->maxEsosed = c3 + c7;
													}
												}
												else {
													// других вариантов быть не может, здесь только 4.
													// Может быть 2, 4, 5, 8
													//octree1->maxEsosed = 4;
													octree1->maxEsosed = c3;
												}
											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxEsosed = 0;
										}

									}
									else {
										octree1->maxEsosed = 1;
									}
								}
								else if (octree1->ilevel == octree1->linkE->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEsosed = 1;
									}
									else if (is_null1(octree1->linkE)) {
										
											// однушка примыкает к четырем четвертинкам.
											octree1->maxEsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										
											// других вариантов быть не может, здесь только 4.
											// Может быть 2, 4, 5, 8
											//octree1->maxEsosed = 4;
											octree1->maxEsosed = c3 + c0 + c4 + c7;
									}
								}
							}
							else {
								// NULL;
								// 0 остаётся 0.
								octree1->maxEsosed = 0;
							}
						}

						if (octree1->b4W) { // + 2.sept.2016 17:24
							Wmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkW != NULL) {
								//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
								if (octree1->ilevel != octree1->linkW->ilevel) {
								    // На разных уровнях.


									if (bSituationZ && (!bSituationX) && (!bSituationY)) {
										if (is_null(octree1->linkW)) {
											// 1 остаётся 1.
											octree1->maxWsosed = 1;
										}
										else if (is_null1(octree1->linkW)) {
											// двойная прилегает к четверной.
											octree1->maxWsosed = 2;
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											octree1->maxWsosed = c2 + c6;
										}
									}
									else {
										if (is_null(octree1->linkW)) {
											// 1 остаётся 1.
											octree1->maxWsosed = 1;
										}
										else if (is_null1(octree1->linkW)) {
											if (bonly_dir_Y) {
												octree1->maxWsosed = 2;
											}
											else {
												// две четверные стороны прилегают друг к дружке.
												octree1->maxWsosed = 1;
											}
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											// других вариантов быть не может, здесь только 4.
											//octree1->maxWsosed = 4;
											if (bonly_dir_Y) {
												octree1->maxWsosed = c2 + c6;
											}
											else {
												octree1->maxWsosed = c2;
											}
										}
									}
								}
								else if (octree1->ilevel == octree1->linkW->ilevel) {
									// На одинаковых уровнях.
									if (is_null(octree1->linkW)) {
										// 1 остаётся 1.
										octree1->maxWsosed = 1;
									}
									else if (is_null1(octree1->linkW)) {
										// однушка примыкает к четырём четвертинкам.
										octree1->maxWsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxWsosed = 4;
										
										octree1->maxWsosed = c2 + c1 + c5 + c6;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxWsosed = 0;
							}
						}

						if (octree1->b4N) { // +
							Nmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkN != NULL) {
								//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
								if (octree1->ilevel != octree1->linkN->ilevel) {
								     // На разных уровнях.


									if (is_null(octree1->linkN)) {
										// 1 остаётся 1.
										octree1->maxNsosed = 1;
									}
									else if (is_null1(octree1->linkN)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxNsosed = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxNsosed = 4;
										octree1->maxNsosed = c0;
									}
								}
								else if (octree1->ilevel == octree1->linkN->ilevel) {
									// На одинаковых уровнях.
									if (is_null(octree1->linkN)) {
										// 1 остаётся 1.
										octree1->maxNsosed = 1;
									}
									else if (is_null1(octree1->linkN)) {
										// однушка примыкает к четвертинке.
										octree1->maxNsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxNsosed = 4;
										octree1->maxNsosed = c0 + c1 + c4 + c5;
									}

								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxNsosed = 0;
							}
						}

						if (octree1->b4B) { // +
							Bmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkB != NULL) {
								//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
								if (octree1->ilevel != octree1->linkB->ilevel) {
									// На разных уровнях.
									if (bSituationX && (!bSituationY) && (!bSituationZ)) {
										if (is_null(octree1->linkB)) {
											// 1 остаётся 1.
											octree1->maxBsosed = 1;
										}
										else if (is_null1(octree1->linkB)) {
											// двойная прилегает к четверной.
											octree1->maxBsosed = 2;
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											octree1->maxBsosed = c7 + c6;
										}
									}
									else {
										if (is_null(octree1->linkB)) {
											// 1 остаётся 1.
											octree1->maxBsosed = 1;
										}
										else if (is_null1(octree1->linkB)) {
											if (bonly_dir_Y) {
												octree1->maxBsosed = 2;
											}
											else {
												// две четверные стороны прилегают друг к дружке.
												octree1->maxBsosed = 1;
											}
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											if (bonly_dir_Y) {
												octree1->maxBsosed = c7 + c6;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												//octree1->maxBsosed = 4;
												octree1->maxBsosed = c7;
											}
										}
									}
								}
								else if (octree1->ilevel == octree1->linkB->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkB)) {
										// 1 остаётся 1.
										octree1->maxBsosed = 1;
									}
									else if (is_null1(octree1->linkB)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxBsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										
											// других вариантов быть не может, здесь только 4.
											//octree1->maxBsosed = 4;
											octree1->maxBsosed = c7+c6+c5+c4;
										
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxBsosed = 0;
							}
						}

						break;
					case 4:

						if (octree1->b4N) { // + 2.september.2016 17:10
							Nmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkN != NULL) {
								//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
								if (octree1->ilevel != octree1->linkN->ilevel) {
								    // На разных уровнях.


									if (bSituationY) {

										if (octree1->linkN != NULL) {
											if (is_null(octree1->linkN)) {
												// 1 остаётся 1.
												octree1->maxNsosed = 1;
											}
											else if (is_null1(octree1->linkN)) {
												if (bonly_dir_Z) {
													octree1->maxNsosed = 2;
												}
												else {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxNsosed = 1;
												}
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												if ((bonly_dir_Z)) {
													if (bonly_dir_Z) {
														// дробим только по оси Oy.
														octree1->maxNsosed = c4 + c5;
													}
												}
												else {
													// других вариантов быть не может, здесь только 4.
													// Здесь может быть 2, 4, 5, 8
													//octree1->maxNsosed = 4;
													octree1->maxNsosed = c4;
												}
											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxNsosed = 0;
										}

									}
									else {
										octree1->maxNsosed = 1;
									}
								}
								else if (octree1->ilevel == octree1->linkN->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkN)) {
										// 1 остаётся 1.
										octree1->maxNsosed = 1;
									}
									else if (is_null1(octree1->linkN)) {
											// однушка примыкает к четырём четвертинкам.
											octree1->maxNsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										
											// других вариантов быть не может, здесь только 4.
											// Здесь может быть 2, 4, 5, 8
											//octree1->maxNsosed = 4;
											octree1->maxNsosed = c4 + c0 + c1 + c5;
										
									}
								}
								/*else {
								#if doubleintprecision == 1
									printf("FATAL ERROR! octree1->ilevel=%lld octree1->linkN->ilevel=%lld\n", octree1->ilevel, octree1->linkN->ilevel);
									printf("octree1->maxNsosed=%lld\n", octree1->maxNsosed);
								#else
									printf("FATAL ERROR! octree1->ilevel=%d octree1->linkN->ilevel=%d\n", octree1->ilevel, octree1->linkN->ilevel);
									printf("octree1->maxNsosed=%d\n", octree1->maxNsosed);
								#endif
									
									getchar();
								}*/
							}
							else {
								// NULL
								// 0 остаётся 0.
								octree1->maxNsosed = 0;
							}
						}

						if (octree1->b4E) { // + 2 sept 2016 16:49
							Emultisosed_patch(octree1);
						}
						else {
							if (octree1->linkE!=NULL) {
								//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
								if (octree1->ilevel != octree1->linkE->ilevel) {
									// На разных уровнях.

									if (bSituationX) {

										if (octree1->linkE != NULL) {
											if (is_null(octree1->linkE)) {
												// 1 остаётся 1.
												octree1->maxEsosed = 1;
											}
											else if (is_null1(octree1->linkE)) {
												if (bonly_dir_Z) {
													octree1->maxEsosed = 2;
												}
												else {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxEsosed = 1;
												}
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												if ((bonly_dir_Z)) {
													if (bonly_dir_Z) {
														// дробим только по оси Oy.
														octree1->maxEsosed = c4 + c7;
													}
												}
												else {
													// других вариантов быть не может, здесь только 4.
													//octree1->maxEsosed = 4;
													octree1->maxEsosed = c4;
												}
											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxEsosed = 0;
										}
									}
									else {
										octree1->maxEsosed = 1;
									}
								}
								else if (octree1->ilevel == octree1->linkE->ilevel) {
									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEsosed = 1;
									}
									else if (is_null1(octree1->linkE)) {
											// две четверные стороны прилегают друг к дружке.
											octree1->maxEsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										
											// других вариантов быть не может, здесь только 4.
											//octree1->maxEsosed = 4;
											octree1->maxEsosed = c4+c0+c3+c7;
									}
								}
								}
								else {
									// NULL
									// 0 остаётся 0.
									octree1->maxEsosed = 0;
								}
						}
						

						if (octree1->b4W) { // +
							Wmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkW != NULL) {
								//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
								if (octree1->ilevel != octree1->linkW->ilevel) {
									// На разных уровнях.

									if (bSituationY && (!bSituationX) && (!bSituationZ)) {
										if (is_null(octree1->linkW)) {
											// 1 остаётся 1.
											octree1->maxWsosed = 1;
										}
										else if (is_null1(octree1->linkW)) {
											// двойная прилегает к четверной.
											octree1->maxWsosed = 2;
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											octree1->maxWsosed = c5 + c6;
										}
									}
									else {
										if (is_null(octree1->linkW)) {
											// 1 остаётся 1.
											octree1->maxWsosed = 1;
										}
										else if (is_null1(octree1->linkW)) {
											if (bonly_dir_Z) {
												octree1->maxWsosed = 2;
											}
											else {
												// две четверные стороны прилегают друг к дружке.
												octree1->maxWsosed = 1;
											}
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											// других вариантов быть не может, здесь только 4.
											//octree1->maxWsosed = 4;
											if (bonly_dir_Z) {
												octree1->maxWsosed = c5 + c6;
											}
											else {
												octree1->maxWsosed = c5;
											}
										}
									}
								}
								else if (octree1->ilevel == octree1->linkW->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkW)) {
										// 1 остаётся 1.
										octree1->maxWsosed = 1;
									}
									else if (is_null1(octree1->linkW)) {
											// однушка примыкает к четвертинкам.
											octree1->maxWsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxWsosed = 4;
										
											octree1->maxWsosed = c5+c1+c2+c6;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxWsosed = 0;
							}
						}

						if (octree1->b4S) { // + 2.september. 2016 16:59
							Smultisosed_patch(octree1);
						}
						else {
							if (octree1->linkS != NULL) {
								//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
								if (octree1->ilevel != octree1->linkS->ilevel) {
								    // На разных уровнях.


									if (bSituationX && (!bSituationY) && (!bSituationZ)) {
										if (is_null(octree1->linkS)) {
											// 1 остаётся 1.
											octree1->maxSsosed = 1;
										}
										else if (is_null1(octree1->linkS)) {
											// двойная прилегает к четверной.
											octree1->maxSsosed = 2;
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											octree1->maxSsosed = c7 + c6;
										}
									}
									else {
										if (is_null(octree1->linkS)) {
											// 1 остаётся 1.
											octree1->maxSsosed = 1;
										}
										else if (is_null1(octree1->linkS)) {
											if (bonly_dir_Z) {
												octree1->maxSsosed = 2;
											}
											else {
												// две четверные стороны прилегают друг к дружке.
												octree1->maxSsosed = 1;
											}
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											// других вариантов быть не может, здесь только 4.
											//octree1->maxSsosed = 4;
											if (bonly_dir_Z) {
												octree1->maxSsosed = c7 + c6;
											}
											else {
												octree1->maxSsosed = c7;
											}
										}
									}
								}
								else if (octree1->ilevel == octree1->linkS->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkS)) {
										// 1 остаётся 1.
										octree1->maxSsosed = 1;
									}
									else if (is_null1(octree1->linkS)) {
											// однушка примыкает к четырем четвертинкам.
											octree1->maxSsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxSsosed = 4;
										
											octree1->maxSsosed = c7+c2+c3+c6;
										
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxSsosed = 0;
							}
						}


						if (octree1->b4T) { // +
							Tmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkT != NULL) {
								//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
								if (octree1->ilevel != octree1->linkT->ilevel) {
									// На разных уровнях.

									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTsosed = 1;
									}
									else if (is_null1(octree1->linkT)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxTsosed = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxTsosed = 4;
										octree1->maxTsosed = c0;
									}
								}
								else if (octree1->ilevel == octree1->linkT->ilevel) {
									// На одинаковых уровнях.
									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTsosed = 1;
									}
									else if (is_null1(octree1->linkT)) {
										// однушка примыкает к четырём четвертинкам.
										octree1->maxTsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxTsosed = 4;
										octree1->maxTsosed = c0 + c1 + c2 + c3;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxTsosed = 0;
							}
						}

						if (octree1->b4B) { // + 2.sept.2016 13.30
							Bmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkB != NULL) {
								//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
								if (octree1->ilevel != octree1->linkB->ilevel) {
								    // на разных уровнях.
									octree1->maxBsosed = 1;
								}
								else if (octree1->ilevel == octree1->linkB->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkB)) {
										// 1 остается 1
										octree1->maxBsosed = 1;
									}
									else if (is_null1(octree1->linkB)) {
										// однушка прилегает к четвертушке.
										octree1->maxBsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkB, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxBsosed = c4 + c5 + c6 + c7;
									}
								}
							}
							else {
								// NULL 0 остаётся нулём.
								octree1->maxBsosed = 0;
							}
						}

						break;
					case 5:
						
						if (octree1->b4B) { // + 2.sept.2016 13.30
							Bmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkB != NULL) {
								//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
								if (octree1->ilevel != octree1->linkB->ilevel) {
								    // на разных уровнях.
									octree1->maxBsosed = 1;
								}
								else if (octree1->ilevel == octree1->linkB->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkB)) {
										// 1 остается 1
										octree1->maxBsosed = 1;
									}
									else if (is_null1(octree1->linkB)) {
										// однушка прилегает к четвертушке.
										octree1->maxBsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkB, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxBsosed = c4 + c5 + c6 + c7;
									}
								}
							}
							else {
								// NULL 0 остаётся нулём.
								octree1->maxBsosed = 0;
							}
						}

						 
							if (octree1->b4N) {// + 2.sept.2016 16:18
								Nmultisosed_patch(octree1);
							}
							else {
								if (octree1->linkN != NULL) {
									//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
									if (octree1->ilevel != octree1->linkN->ilevel) {
										// На разных уровнях.

										if (bSituationY) {
											if (is_null(octree1->linkN)) {
												// 1 остаётся 1.
												octree1->maxNsosed = 1;
											}
											else if (is_null1(octree1->linkN)) {
												// две четверные стороны прилегают друг к дружке.
												octree1->maxNsosed = 1;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												// других вариантов быть не может, здесь только 4.
												//octree1->maxNsosed = 4;
												octree1->maxNsosed = c5;
											}
										}
										else {
											octree1->maxNsosed = 1;
										}
									}
									else if (octree1->ilevel == octree1->linkN->ilevel) {
										// На одинаковых уровнях.
										if (is_null(octree1->linkN)) {
											// 1 остаётся 1.
											octree1->maxNsosed = 1;
										}
										else if (is_null1(octree1->linkN)) {
											// одна ячейка прилегает к четверной.
											octree1->maxNsosed = 4;
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											// других вариантов быть не может, здесь только 4.
											//octree1->maxNsosed = 4;
											octree1->maxNsosed = c5 + c0 + c1 + c4;
										}

									}
								}
								else {
									// 0 остаётся 0.
									octree1->maxNsosed = 0;
								}
							}
						
						

						
						if (octree1->b4W) { // + 2.sept.2016 13.30
							Wmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkW != NULL) {
								//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
								if (octree1->ilevel != octree1->linkW->ilevel) {
									// на разных уровнях.
									octree1->maxWsosed = 1;
								}
								else if (octree1->ilevel == octree1->linkW->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkW)) {
										// 1 остается 1
										octree1->maxWsosed = 1;
									}
									else if (is_null1(octree1->linkW)) {
										// однушка прилегает к четвертушке.
										octree1->maxWsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxWsosed = c1 + c2 + c5 + c6;
									}
								}
							}
							else {
								// NULL 0 остаётся нулём.
								octree1->maxWsosed = 0;
							}
						}



						if (octree1->b4E) { // +
							Emultisosed_patch(octree1);
						}
						else {
							if (octree1->linkE != NULL) {
								//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
								if (octree1->ilevel != octree1->linkE->ilevel) {
									// На разных уровнях.

									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEsosed = 1;
									}
									else if (is_null1(octree1->linkE)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxEsosed = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxEsosed = c4;
									}
								}
								else if (octree1->ilevel == octree1->linkE->ilevel) {
									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEsosed = 1;
									}
									else if (is_null1(octree1->linkE)) {
										// одинарная ячейка прилегает к четверной.
										octree1->maxEsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxEsosed = c4+c0+c3+c7;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxEsosed = 0;
							}
						}

						if (octree1->b4S) { // +
							Smultisosed_patch(octree1);
						}
						else {
							if (octree1->linkS != NULL) {
								//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
								if (octree1->ilevel != octree1->linkS->ilevel) {
								    // На разных уровнях.
									if (is_null(octree1->linkS)) {
										// 1 остаётся 1.
										octree1->maxSsosed = 1;
									}
									else if (is_null1(octree1->linkS)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxSsosed = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxSsosed = 4;
										octree1->maxSsosed = c6;
									}
								}
								else if (octree1->ilevel == octree1->linkS->ilevel) {
									// На одинаковых уровнях.
									if (is_null(octree1->linkS)) {
										// 1 остаётся 1.
										octree1->maxSsosed = 1;
									}
									else if (is_null1(octree1->linkS)) {
										// однва ячейка прилегает к четыврём.
										octree1->maxSsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxSsosed = 4;
										octree1->maxSsosed = c6 + c2 + c3 + c7;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxSsosed = 0;
							}
						}

						if (octree1->b4T) { // + 2 september 2016 16:14
							Tmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkT != NULL) {
								//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
								if (octree1->ilevel != octree1->linkT->ilevel) {
								    // На разных уровнях.


									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTsosed = 1; // octree1->maxTsosed;
									}
									else if (is_null1(octree1->linkT)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxTsosed = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxTsosed = 4;
										octree1->maxTsosed = c1;
									}
								}
								else if (octree1->ilevel == octree1->linkT->ilevel) {
									// На одинаковых уровнях.
									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTsosed = 1; // octree1->maxTsosed;
									}
									else if (is_null1(octree1->linkT)) {
										// одинарная ячейка прилегает к четверной.
										octree1->maxTsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxTsosed = 4;
										octree1->maxTsosed = c1 + c0 + c2 + c3;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxTsosed = 0;
							}
						}

						break;
					case 6:
						
						if (octree1->b4B) { // + 2.sept.2016 13.30
							Bmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkB != NULL) {
								//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
								if (octree1->ilevel != octree1->linkB->ilevel) {
									// на разных уровнях.
									octree1->maxBsosed = 1;
								}
								else if (octree1->ilevel == octree1->linkB->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkB)) {
										// 1 остается 1
										octree1->maxBsosed = 1;
									}
									else if (is_null1(octree1->linkB)) {
										// однушка прилегает к четвертушке.
										octree1->maxBsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkB, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxBsosed = c4 + c5 + c6 + c7;
									}
								}
							}
							else {
								// NULL 0 остаётся нулём.
								octree1->maxBsosed = 0;
							}
						}


						if (octree1->b4S) { // + 2.sept.2016 13.30
							Smultisosed_patch(octree1);
						}
						else {
							if (octree1->linkS != NULL) {
								//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
								if (octree1->ilevel != octree1->linkS->ilevel) {
								    // на разных уровнях.
									octree1->maxSsosed = 1;
								}
								else if (octree1->ilevel == octree1->linkS->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkS)) {
										// 1 остается 1
										octree1->maxSsosed = 1;
									}
									else if (is_null1(octree1->linkS)) {
										// однушка прилегает к четвертушке.
										octree1->maxSsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkS, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxSsosed = c2 + c3 + c6 + c7;
									}
								}
							}
							else {
								// NULL 0 остаётся нулём.
								octree1->maxSsosed = 0;
							}
						}


						if (octree1->b4W) { // + 2.sept.2016 13.30
							Wmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkW != NULL) {
								//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
								if (octree1->ilevel != octree1->linkW->ilevel) {
								    // на разных уровнях.
									octree1->maxWsosed = 1;
								}
								else if (octree1->ilevel == octree1->linkW->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkW)) {
										// 1 остается 1
										octree1->maxWsosed = 1;
									}
									else if (is_null1(octree1->linkW)) {
										// однушка прилегает к четвертушке.
										octree1->maxWsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxWsosed = c1 + c2 + c5 + c6;
									}
								}
							}
							else {
								// NULL 0 остаётся нулём.
								octree1->maxWsosed = 0;
							}
						}


						if (octree1->b4E) { // +
							Emultisosed_patch(octree1);
						}
						else {
							if (octree1->linkE != NULL) {
								//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
								if (octree1->ilevel != octree1->linkE->ilevel) {
									// На разных уровнях.

									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEsosed = 1;
									}
									else if (is_null1(octree1->linkE)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxEsosed = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxEsosed = c7;
									}
								}
								else if (octree1->ilevel == octree1->linkE->ilevel) {
									// На одном уровнене.
									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEsosed = 1;
									}
									else if (is_null1(octree1->linkE)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxEsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxEsosed = c7+c0+c3+c4;
									}

								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxEsosed = 0;
							}
						}

						if (octree1->b4N) {  // +
							Nmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkN != NULL) {
								//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
								if (octree1->ilevel != octree1->linkN->ilevel) {
									// На разных уровнях.

									if (is_null(octree1->linkN)) {
										// 1 остаётся 1.
										octree1->maxNsosed = 1;
									}
									else if (is_null1(octree1->linkN)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxNsosed = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxNsosed = 4;
										octree1->maxNsosed = c5;
									}
								}
								else if (octree1->ilevel == octree1->linkN->ilevel) {
									// На одном уровне.

									if (is_null(octree1->linkN)) {
										// 1 остаётся 1.
										octree1->maxNsosed = 1;
									}
									else if (is_null1(octree1->linkN)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxNsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxNsosed = 4;
										octree1->maxNsosed = c5+c0+c1+c4;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxNsosed = 0;
							}
						}

						if (octree1->b4T) { // + 2 sept 2016 15:33
							Tmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkT != NULL) {
								//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
								if (octree1->ilevel != octree1->linkT->ilevel) {
								    // На разных уровнях.

									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTsosed = 1;
									}
									else if (is_null1(octree1->linkT)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxTsosed = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxTsosed = 4;
										octree1->maxTsosed = c2;
									}
								}
								else if (octree1->ilevel==octree1->linkT->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTsosed = 1;
									}
									else if (is_null1(octree1->linkT)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxTsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxTsosed = 4;
										octree1->maxTsosed = c2 + c0 + c1 + c3;
									}

								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxTsosed = 0;
							}
						}
						break;
					case 7:

					
						if (octree1->b4B) { // + 2.sept.2016 13.30
							Bmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkB != NULL) {
								//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
								if (octree1->ilevel != octree1->linkB->ilevel) {
								    // на разных уровнях.
									octree1->maxBsosed = 1;
								}
								else if (octree1->ilevel == octree1->linkB->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkB)) {
										// 1 остается 1
										octree1->maxBsosed = 1;
									}
									else if (is_null1(octree1->linkB)) {
										// однушка прилегает к четвертушке.
										octree1->maxBsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkB, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxBsosed = c1 + c2 + c5 + c6;
									}
								}
							}
							else {
								// NULL 0 остаётся нулём.
								octree1->maxBsosed = 0;
							}
						}


						if (octree1->b4S) { // + 2.sept.2016 13.30
							Smultisosed_patch(octree1);
						}
						else {
							if (octree1->linkS != NULL) {
								//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
								if (octree1->ilevel != octree1->linkS->ilevel) {
								    // на разных уровнях.
									octree1->maxSsosed = 1;
								}
								else if (octree1->ilevel == octree1->linkS->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkS)) {
										// 1 остается 1
										octree1->maxSsosed = 1;
									}
									else if (is_null1(octree1->linkS)) {
										// однушка прилегает к четвертушке.
										octree1->maxSsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkS, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxSsosed = c1 + c2 + c5 + c6;
									}
								}
							}
							else {
								// NULL 0 остаётся нулём.
								octree1->maxSsosed = 0;
							}
						}

						if (octree1->b4E) { // +
							Emultisosed_patch(octree1);
						}
						else {
							if (octree1->linkE != NULL) {
								//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
								if (octree1->ilevel != octree1->linkE->ilevel ) {
								    // На разных уровнях.
									if (bSituationX) {

										if (octree1->linkE != NULL) {
											if (is_null(octree1->linkE)) {
												// 1 остаётся 1.
												octree1->maxEsosed = 1;
											}
											else if (is_null1(octree1->linkE)) {
												// две четверные стороны прилегают друг к дружке.
												octree1->maxEsosed = 1;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												// других вариантов быть не может, здесь только 4.
												//octree1->maxEsosed = 4;
												octree1->maxEsosed = c7;
											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxEsosed = 0;
										}
									}
									else {
										octree1->maxEsosed = 1;
									}
								}
								else if (octree1->ilevel == octree1->linkE->ilevel) {
									// На одинаковых уровнях.
									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEsosed = 1;
									}
									else if (is_null1(octree1->linkE)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxEsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEsosed = 4;
										octree1->maxEsosed = c7+c0+c4+c3;
									}
								}
						    }
							else {
								// NULL
								// 0 остаётся 0.
								octree1->maxEsosed = 0;
							}
						}

						if (octree1->b4W) { // +
							Wmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkW != NULL) {
								//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
								if (octree1->ilevel != octree1->linkW->ilevel) {
								    // На разных уровнях


									if (is_null(octree1->linkW)) {
										// 1 остаётся 1.
										octree1->maxWsosed = 1;
									}
									else if (is_null1(octree1->linkW)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxWsosed = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxWsosed = 4;
										octree1->maxWsosed = c6;
									}
								}
								else if (octree1->ilevel == octree1->linkW->ilevel) {
									// На одинаковых уровнях
									if (is_null(octree1->linkW)) {
										// 1 остаётся 1.
										octree1->maxWsosed = 1;
									}
									else if (is_null1(octree1->linkW)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxWsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxWsosed = 4;
										octree1->maxWsosed = c6+c1+c5+c2;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxWsosed = 0;
							}
						}


						if (octree1->b4N) { // +
							Nmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkN != NULL) {
								//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
								if (octree1->ilevel != octree1->linkN->ilevel) {
								    // На разных уровнях.

									if (is_null(octree1->linkN)) {
										// 1 остаётся 1.
										octree1->maxNsosed = 1;
									}
									else if (is_null1(octree1->linkN)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxNsosed = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxNsosed = 4;
										octree1->maxNsosed = c4;
									}
								}
								else if (octree1->ilevel == octree1->linkN->ilevel) {
									// На одинаковых уровнях.
									if (is_null(octree1->linkN)) {
										// 1 остаётся 1.
										octree1->maxNsosed = 1;
									}
									else if (is_null1(octree1->linkN)) {
										// Единичка прилегает к четвертушке.
										octree1->maxNsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxNsosed = 4;
										octree1->maxNsosed = c4+c0+c1+c5;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxNsosed = 0;
							}
						}


						if (octree1->b4T) { // + 2.sept.2016 15:57
							Tmultisosed_patch(octree1);
						}
						else {
							if (octree1->linkT != NULL) {
								//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
								if (octree1->ilevel != octree1->linkT->ilevel) {
									// На разных уровнях.
									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTsosed = 1;
									}
									else if (is_null1(octree1->linkT)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxTsosed = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxTsosed = 4;
										octree1->maxTsosed = c3;
									}
								}
								else if (octree1->ilevel == octree1->linkT->ilevel) {
									// На одинаковых уровнях.
									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTsosed = 1;
									}
									else if (is_null1(octree1->linkT)) {
										// Единичка примыкает к четырём соседяим.
										octree1->maxTsosed = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										integer c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxTsosed = 4;
										octree1->maxTsosed = c3 + c0 + c1 + c2;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxTsosed = 0;
							}
						}
						break;
					default: 
#if doubleintprecision == 1
						printf("error : root=%lld\n", octree1->root);
#else
						printf("error : root=%d\n", octree1->root);
#endif
						
						//getchar();
						system("PAUSE");
						exit(1);
						break;
					}
					// закончили работать.
					octree1 = NULL;
				//}
				//else {
					// Закоментировано 30.08.2016.
					//my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
					//top_ALICE_STACK--;
				//}

			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//getchar();
	}
} // update_max_count_sosed


// После каждого сканирования листьев всего дерева мы должны 
// восстановить соседвенные связи т.к. они  изменились после дробления.
void update_link_neighbor(octTree* &oc) {

	bool bold_stable_version = true;

	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {
				// Внимание обязательно нужно оставить закоментированным 30.08.2016.
				//if (my_ALICE_STACK[top_ALICE_STACK - 1].link->b_the_geometric_fragmentation) 
				//{

					// Внимание обязательно нужно оставить закоментированным 30.08.2016.
					//my_ALICE_STACK[top_ALICE_STACK - 1].link->b_the_geometric_fragmentation = false;

					octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;

					// разбиение на 8.
					integer minx = my_ALICE_STACK[top_ALICE_STACK - 1].minx;
					integer maxx = my_ALICE_STACK[top_ALICE_STACK - 1].maxx;
					integer miny = my_ALICE_STACK[top_ALICE_STACK - 1].miny;
					integer maxy = my_ALICE_STACK[top_ALICE_STACK - 1].maxy;
					integer minz = my_ALICE_STACK[top_ALICE_STACK - 1].minz;
					integer maxz = my_ALICE_STACK[top_ALICE_STACK - 1].maxz;

					// Дробление  вызывается.
					my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
					top_ALICE_STACK--;

					// работаем с octree1

					// А другие случаи исключаются при додроблении.
					// одиночная связь, НЕ 4
					if (octree1->b4E == false) {
					if (octree1->linkE != NULL) {

						if (octree1->linkE->link0 != NULL) {
							if ((octree1->linkE->link1 == NULL) && (octree1->linkE->link2 == NULL) && (octree1->linkE->link3 == NULL) && (octree1->linkE->link4 == NULL) && (octree1->linkE->link5 == NULL) && (octree1->linkE->link6 == NULL) && (octree1->linkE->link7 == NULL)) {
								printf("error : octree1->linkE->link0!=NULL a na samom dele ==NULL\n");
								//getchar();
								system("PAUSE");
								exit(1);
							}

						// octree1 это лист.
						// Situation внутри Е соседа.
						bool bSituationX = false;
						bool bSituationY = false;
						bool bSituationZ = false;
						if (bold_stable_version) {
							if (octree1->linkE->minx + 1 == octree1->linkE->maxx) {
								bSituationX = true;
							}
							if (octree1->linkE->miny + 1 == octree1->linkE->maxy) {
								bSituationY = true;
							}
							if (octree1->linkE->minz + 1 == octree1->linkE->maxz) {
								bSituationZ = true;
							}
							if ((octree1->linkE->link0 != NULL)) {
								if (bSituationX != octree1->linkE->link0->brootSituationX) {
									printf("error ne sovpadenie Situation X.");
								}
								if (bSituationY != octree1->linkE->link0->brootSituationY) {
									printf("error ne sovpadenie Situation Y.");
								}
								if (bSituationZ != octree1->linkE->link0->brootSituationZ) {
									printf("error ne sovpadenie Situation Z.");
								}
							}
						}
						else {
							// 4.01.2018 Попробуем так. Чисто на интуиции пока.
							// Здесь мы сохраняем запрет дробления в заданном координатном направлении.
							bSituationX = octree1->linkE->link0->brootSituationX;
							bSituationY = octree1->linkE->link0->brootSituationY;
							bSituationZ = octree1->linkE->link0->brootSituationZ;
						}
						bool bsitX = false;
						if (((!bSituationX) && (bSituationY) && (bSituationZ))) bsitX = true;
						

						//if ((!octree1->b_the_geometric_fragmentation)||(octree1->bcrushing_when_balancing)) {
						if ((octree1->ilevel==octree1->linkE->ilevel)||(bsitX)) {
							// Не дробленный лист контачит по грани E с дроблённым обектом.
							// Situaton - это ситуация в Е соседе.
							if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
								// вырождение по Х
								// 0,3,4,7 
								octree1->b4E = true;
								octree1->linkE1 = octree1->linkE->link0;
								octree1->linkE2 = octree1->linkE->link3;
								octree1->linkE5 = octree1->linkE->link4;
								octree1->linkE6 = octree1->linkE->link7;
								octree1->linkE = NULL;
							}
							else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
								// вырождение по Y
								// 0,1,4,5 
								octree1->b4E = true;
								octree1->linkE1 = octree1->linkE->link0;
								octree1->linkE2 = NULL; 
								octree1->linkE5 = octree1->linkE->link4;
								octree1->linkE6 = NULL;
								octree1->linkE = NULL;
							}
							else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
								// вырождение по Z
								// 0,1,2,3
								octree1->b4E = true;
								octree1->linkE1 = octree1->linkE->link0;
								octree1->linkE2 = octree1->linkE->link3;
								octree1->linkE5 = NULL; 
								octree1->linkE6 = NULL; 
								octree1->linkE = NULL;
							}
							else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
								// direction Z
								// 0,4
								octree1->b4E = true;
								octree1->linkE1 = octree1->linkE->link0;
								octree1->linkE2 = NULL; 
								octree1->linkE5 = octree1->linkE->link4;
								octree1->linkE6 = NULL; 
								octree1->linkE = NULL;
							}
							else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
								// direction X
								// 0,1
								octree1->b4E = true;
								octree1->linkE1 = octree1->linkE->link0;
								octree1->linkE2 = NULL;
								octree1->linkE5 = NULL; 
								octree1->linkE6 = NULL;
								// Оратное редуцирование т.к. связь только одна.
								octree1->b4E = false;
								octree1->linkE1 = NULL; 
								octree1->linkE = octree1->linkE->link0;
								//printf("FOUND ERROR!!! E direction X\n");
								//getchar();
							}
							else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
								// direction Y
								// 0,3
								octree1->b4E = true;
								octree1->linkE1 = octree1->linkE->link0;
								octree1->linkE2 = octree1->linkE->link3;
								octree1->linkE5 = NULL; 
								octree1->linkE6 = NULL; 
								octree1->linkE = NULL;
							}
							else if (is_null1(octree1->linkE)) {
								// Разбита на 8 равных частей:
								// 1,2,5,6
								octree1->b4E = true;
								octree1->linkE1 = octree1->linkE->link0;
								octree1->linkE2 = octree1->linkE->link3;
								octree1->linkE5 = octree1->linkE->link4;
								octree1->linkE6 = octree1->linkE->link7;
								octree1->linkE = NULL;
							}


						}
						else {
							if (octree1->ilevel - octree1->linkE->ilevel != 1) {
								
								if (is_null1_new(octree1->linkE)) {
									if (DEBUG_ALICE_MESH) {
										printf("linkE  is_null1_new\n");
									}
									if (octree1->ilevel - octree1->linkE->ilevel==2) {
										
										if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
											// вырождение по Х
											// 0,3,4,7 
											// Эквивалентность : (0,1) (3,2) (4,5) (7,6)
											// Разбита на 8 равных частей:
											// 1,2,5,6
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// нет вырождения.
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1: octree1->linkE = octree1->linkE->link0;
													break;
												case 2:octree1->linkE = octree1->linkE->link3;
													break;
												case 3:
													break;
												case 4:
													break;
												case 5: octree1->linkE = octree1->linkE->link4;
													break;
												case 6: octree1->linkE = octree1->linkE->link7;
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												switch (octree1->parent->root) {
												case 0: octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkE = octree1->linkE->link3;
													break;
												case 4:octree1->linkE = octree1->linkE->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkE = octree1->linkE->link7;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//1,5
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:octree1->linkE = octree1->linkE->link4;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//1,2
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:octree1->linkE = octree1->linkE->link3;
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkE = octree1->linkE->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//1
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkE = octree1->linkE->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}


										}
										else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
											// вырождение по Y
											// 0,1,4,5 
											// (3->0),(2->1),(7->4), (6->5)
											// Разбита на 8 равных частей:
											// 1,2,5,6
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// нет вырождения.
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1: octree1->linkE = octree1->linkE->link0;
													break;
												case 2:octree1->linkE = octree1->linkE->link0;
													break;
												case 3:
													break;
												case 4:
													break;
												case 5: octree1->linkE = octree1->linkE->link4;
													break;
												case 6: octree1->linkE = octree1->linkE->link4;
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												switch (octree1->parent->root) {
												case 0: octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkE = octree1->linkE->link0;
													break;
												case 4:octree1->linkE = octree1->linkE->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkE = octree1->linkE->link4;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//1,5
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:octree1->linkE = octree1->linkE->link4;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//1,2
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:octree1->linkE = octree1->linkE->link0;
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkE = octree1->linkE->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//1
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkE = octree1->linkE->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
										else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
											// вырождение по Z
											// 0,1,2,3
											// (4->0) (5->1) (6->2) (7->3)
											// Разбита на 8 равных частей:
											// 1,2,5,6
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// нет вырождения.
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1: octree1->linkE = octree1->linkE->link0;
													break;
												case 2:octree1->linkE = octree1->linkE->link3;
													break;
												case 3:
													break;
												case 4:
													break;
												case 5: octree1->linkE = octree1->linkE->link0;
													break;
												case 6: octree1->linkE = octree1->linkE->link3;
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												switch (octree1->parent->root) {
												case 0: octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkE = octree1->linkE->link3;
													break;
												case 4:octree1->linkE = octree1->linkE->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkE = octree1->linkE->link3;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//1,5
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:octree1->linkE = octree1->linkE->link0;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//1,2
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:octree1->linkE = octree1->linkE->link3;
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkE = octree1->linkE->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//1
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkE = octree1->linkE->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
											// direction Z
											// 0,4
											// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
											// Разбита на 8 равных частей:
											// 1,2,5,6
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// нет вырождения.
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1: octree1->linkE = octree1->linkE->link0;
													break;
												case 2:octree1->linkE = octree1->linkE->link0;
													break;
												case 3:
													break;
												case 4:
													break;
												case 5: octree1->linkE = octree1->linkE->link4;
													break;
												case 6: octree1->linkE = octree1->linkE->link4;
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												switch (octree1->parent->root) {
												case 0: octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkE = octree1->linkE->link0;
													break;
												case 4:octree1->linkE = octree1->linkE->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkE = octree1->linkE->link4;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//1,5
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:octree1->linkE = octree1->linkE->link4;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//1,2
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:octree1->linkE = octree1->linkE->link0;
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkE = octree1->linkE->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//1
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkE = octree1->linkE->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
										else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
											// direction X
											// 0,1
											// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
											// Разбита на 8 равных частей:
											// 1,2,5,6
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// нет вырождения.
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1: octree1->linkE = octree1->linkE->link0;
													break;
												case 2:octree1->linkE = octree1->linkE->link0;
													break;
												case 3:
													break;
												case 4:
													break;
												case 5: octree1->linkE = octree1->linkE->link0;
													break;
												case 6: octree1->linkE = octree1->linkE->link0;
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												switch (octree1->parent->root) {
												case 0: octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkE = octree1->linkE->link0;
													break;
												case 4:octree1->linkE = octree1->linkE->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkE = octree1->linkE->link0;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//1,5
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:octree1->linkE = octree1->linkE->link0;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//1,2
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:octree1->linkE = octree1->linkE->link0;
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkE = octree1->linkE->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//1
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkE = octree1->linkE->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
											// direction Y
											// 0,3
											// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
											// Разбита на 8 равных частей:
											// 1,2,5,6
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// нет вырождения.
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1: octree1->linkE = octree1->linkE->link0;
													break;
												case 2:octree1->linkE = octree1->linkE->link3;
													break;
												case 3:
													break;
												case 4:
													break;
												case 5: octree1->linkE = octree1->linkE->link0;
													break;
												case 6: octree1->linkE = octree1->linkE->link3;
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												switch (octree1->parent->root) {
												case 0: octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkE = octree1->linkE->link3;
													break;
												case 4:octree1->linkE = octree1->linkE->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkE = octree1->linkE->link3;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//1,5
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:octree1->linkE = octree1->linkE->link0;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//1,2
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:octree1->linkE = octree1->linkE->link3;
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkE = octree1->linkE->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//1
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkE = octree1->linkE->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if (is_null1(octree1->linkE)) {
											// Разбита на 8 равных частей:
											// 1,2,5,6
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// нет вырождения.
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1: octree1->linkE = octree1->linkE->link0;
													break;
												case 2:octree1->linkE = octree1->linkE->link3;
													break;
												case 3:
													break;
												case 4:
													break;
												case 5: octree1->linkE = octree1->linkE->link4;
													break;
												case 6: octree1->linkE = octree1->linkE->link7;
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												switch (octree1->parent->root) {
												case 0: octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkE = octree1->linkE->link3;
													break;
												case 4:octree1->linkE = octree1->linkE->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkE = octree1->linkE->link7;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//1,5
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:octree1->linkE = octree1->linkE->link4;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//1,2
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:octree1->linkE = octree1->linkE->link3;
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkE = octree1->linkE->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//1
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:octree1->linkE = octree1->linkE->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkE = octree1->linkE->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkE = octree1->linkE->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
									}
									else {
										printf("Fatal error!!! E distance meshdu urovnqmi > 2\n");
										if (is_null1_new(octree1->linkE)) {
												printf("linkE  is_null1_new\n");
										}
#if doubleintprecision == 1
			printf("octree1->ilevel=%lld octree1->linkE->ilevel=%lld\n", octree1->ilevel, octree1->linkE->ilevel);
#else
			printf("octree1->ilevel=%d octree1->linkE->ilevel=%d\n", octree1->ilevel, octree1->linkE->ilevel);
#endif
										
										//getchar();
										system("PAUSE");
										//exit(1);
									}


								}
								else {
									printf("error : linkE nepravilnje urovni.\n");
									integer c0 = 0;
									integer c1 = 0;
									integer c2 = 0;
									integer c3 = 0;
									integer c4 = 0;
									integer c5 = 0;
									integer c6 = 0;
									integer c7 = 0;
									is_null3(octree1->linkE, ESIDE, c0, c1, c2, c3, c4, c5, c6, c7);
#if doubleintprecision == 1
									printf("c0=%lld c1=%lld c2=%lld c3=%lld c4=%lld c5=%lld c6=%lld c7=%lld\n", c0, c1, c2, c3, c4, c5, c6, c7);
									printf("%lld ", print_link(octree1->linkE->link0));
									if (octree1->linkE->link0 != NULL) {
										printf("%lld ", print_link(octree1->linkE->link0->link0));
										printf("%lld ", print_link(octree1->linkE->link0->link1));
										printf("%lld ", print_link(octree1->linkE->link0->link2));
										printf("%lld ", print_link(octree1->linkE->link0->link3));
										printf("%lld ", print_link(octree1->linkE->link0->link4));
										printf("%lld ", print_link(octree1->linkE->link0->link5));
										printf("%lld ", print_link(octree1->linkE->link0->link6));
										printf("%lld ", print_link(octree1->linkE->link0->link7));
									}
									printf("%lld ", print_link(octree1->linkE->link1));
									if (octree1->linkE->link1 != NULL) {
										printf("%lld ", print_link(octree1->linkE->link1->link0));
										printf("%lld ", print_link(octree1->linkE->link1->link1));
										printf("%lld ", print_link(octree1->linkE->link1->link2));
										printf("%lld ", print_link(octree1->linkE->link1->link3));
										printf("%lld ", print_link(octree1->linkE->link1->link4));
										printf("%lld ", print_link(octree1->linkE->link1->link5));
										printf("%lld ", print_link(octree1->linkE->link1->link6));
										printf("%lld ", print_link(octree1->linkE->link1->link7));
									}
									printf("%lld ", print_link(octree1->linkE->link2));
									if (octree1->linkE->link2 != NULL) {
										printf("%lld ", print_link(octree1->linkE->link2->link0));
										printf("%lld ", print_link(octree1->linkE->link2->link1));
										printf("%lld ", print_link(octree1->linkE->link2->link2));
										printf("%lld ", print_link(octree1->linkE->link2->link3));
										printf("%lld ", print_link(octree1->linkE->link2->link4));
										printf("%lld ", print_link(octree1->linkE->link2->link5));
										printf("%lld ", print_link(octree1->linkE->link2->link6));
										printf("%lld ", print_link(octree1->linkE->link2->link7));
									}
									printf("%lld ", print_link(octree1->linkE->link3));
									if (octree1->linkE->link3 != NULL) {
										printf("%lld ", print_link(octree1->linkE->link3->link0));
										printf("%lld ", print_link(octree1->linkE->link3->link1));
										printf("%lld ", print_link(octree1->linkE->link3->link2));
										printf("%lld ", print_link(octree1->linkE->link3->link3));
										printf("%lld ", print_link(octree1->linkE->link3->link4));
										printf("%lld ", print_link(octree1->linkE->link3->link5));
										printf("%lld ", print_link(octree1->linkE->link3->link6));
										printf("%lld ", print_link(octree1->linkE->link3->link7));
									}
									printf("%lld ", print_link(octree1->linkE->link4));
									if (octree1->linkE->link4 != NULL) {
										printf("%lld ", print_link(octree1->linkE->link4->link0));
										printf("%lld ", print_link(octree1->linkE->link4->link1));
										printf("%lld ", print_link(octree1->linkE->link4->link2));
										printf("%lld ", print_link(octree1->linkE->link4->link3));
										printf("%lld ", print_link(octree1->linkE->link4->link4));
										printf("%lld ", print_link(octree1->linkE->link4->link5));
										printf("%lld ", print_link(octree1->linkE->link4->link6));
										printf("%lld ", print_link(octree1->linkE->link4->link7));
									}
									printf("%lld ", print_link(octree1->linkE->link5));
									if (octree1->linkE->link5 != NULL) {
										printf("%lld ", print_link(octree1->linkE->link5->link0));
										printf("%lld ", print_link(octree1->linkE->link5->link1));
										printf("%lld ", print_link(octree1->linkE->link5->link2));
										printf("%lld ", print_link(octree1->linkE->link5->link3));
										printf("%lld ", print_link(octree1->linkE->link5->link4));
										printf("%lld ", print_link(octree1->linkE->link5->link5));
										printf("%lld ", print_link(octree1->linkE->link5->link6));
										printf("%lld ", print_link(octree1->linkE->link5->link7));
									}
									printf("%lld ", print_link(octree1->linkE->link6));
									if (octree1->linkE->link6 != NULL) {
										printf("%lld ", print_link(octree1->linkE->link6->link0));
										printf("%lld ", print_link(octree1->linkE->link6->link1));
										printf("%lld ", print_link(octree1->linkE->link6->link2));
										printf("%lld ", print_link(octree1->linkE->link6->link3));
										printf("%lld ", print_link(octree1->linkE->link6->link4));
										printf("%lld ", print_link(octree1->linkE->link6->link5));
										printf("%lld ", print_link(octree1->linkE->link6->link6));
										printf("%lld ", print_link(octree1->linkE->link6->link7));
									}
									printf("%lld ", print_link(octree1->linkE->link7));
									if (oc->linkE->link7 != NULL) {
										printf("%lld ", print_link(octree1->linkE->link7->link0));
										printf("%lld ", print_link(octree1->linkE->link7->link1));
										printf("%lld ", print_link(octree1->linkE->link7->link2));
										printf("%lld ", print_link(octree1->linkE->link7->link3));
										printf("%lld ", print_link(octree1->linkE->link7->link4));
										printf("%lld ", print_link(octree1->linkE->link7->link5));
										printf("%lld ", print_link(octree1->linkE->link7->link6));
										printf("%lld ", print_link(octree1->linkE->link7->link7));
									}
#else
									printf("c0=%d c1=%d c2=%d c3=%d c4=%d c5=%d c6=%d c7=%d\n", c0, c1, c2, c3, c4, c5, c6, c7);
									printf("%d ", print_link(octree1->linkE->link0));
									if (octree1->linkE->link0 != NULL) {
										printf("%d ", print_link(octree1->linkE->link0->link0));
										printf("%d ", print_link(octree1->linkE->link0->link1));
										printf("%d ", print_link(octree1->linkE->link0->link2));
										printf("%d ", print_link(octree1->linkE->link0->link3));
										printf("%d ", print_link(octree1->linkE->link0->link4));
										printf("%d ", print_link(octree1->linkE->link0->link5));
										printf("%d ", print_link(octree1->linkE->link0->link6));
										printf("%d ", print_link(octree1->linkE->link0->link7));
									}
									printf("%d ", print_link(octree1->linkE->link1));
									if (octree1->linkE->link1 != NULL) {
										printf("%d ", print_link(octree1->linkE->link1->link0));
										printf("%d ", print_link(octree1->linkE->link1->link1));
										printf("%d ", print_link(octree1->linkE->link1->link2));
										printf("%d ", print_link(octree1->linkE->link1->link3));
										printf("%d ", print_link(octree1->linkE->link1->link4));
										printf("%d ", print_link(octree1->linkE->link1->link5));
										printf("%d ", print_link(octree1->linkE->link1->link6));
										printf("%d ", print_link(octree1->linkE->link1->link7));
									}
									printf("%d ", print_link(octree1->linkE->link2));
									if (octree1->linkE->link2 != NULL) {
										printf("%d ", print_link(octree1->linkE->link2->link0));
										printf("%d ", print_link(octree1->linkE->link2->link1));
										printf("%d ", print_link(octree1->linkE->link2->link2));
										printf("%d ", print_link(octree1->linkE->link2->link3));
										printf("%d ", print_link(octree1->linkE->link2->link4));
										printf("%d ", print_link(octree1->linkE->link2->link5));
										printf("%d ", print_link(octree1->linkE->link2->link6));
										printf("%d ", print_link(octree1->linkE->link2->link7));
									}
									printf("%d ", print_link(octree1->linkE->link3));
									if (octree1->linkE->link3 != NULL) {
										printf("%d ", print_link(octree1->linkE->link3->link0));
										printf("%d ", print_link(octree1->linkE->link3->link1));
										printf("%d ", print_link(octree1->linkE->link3->link2));
										printf("%d ", print_link(octree1->linkE->link3->link3));
										printf("%d ", print_link(octree1->linkE->link3->link4));
										printf("%d ", print_link(octree1->linkE->link3->link5));
										printf("%d ", print_link(octree1->linkE->link3->link6));
										printf("%d ", print_link(octree1->linkE->link3->link7));
									}
									printf("%d ", print_link(octree1->linkE->link4));
									if (octree1->linkE->link4 != NULL) {
										printf("%d ", print_link(octree1->linkE->link4->link0));
										printf("%d ", print_link(octree1->linkE->link4->link1));
										printf("%d ", print_link(octree1->linkE->link4->link2));
										printf("%d ", print_link(octree1->linkE->link4->link3));
										printf("%d ", print_link(octree1->linkE->link4->link4));
										printf("%d ", print_link(octree1->linkE->link4->link5));
										printf("%d ", print_link(octree1->linkE->link4->link6));
										printf("%d ", print_link(octree1->linkE->link4->link7));
									}
									printf("%d ", print_link(octree1->linkE->link5));
									if (octree1->linkE->link5 != NULL) {
										printf("%d ", print_link(octree1->linkE->link5->link0));
										printf("%d ", print_link(octree1->linkE->link5->link1));
										printf("%d ", print_link(octree1->linkE->link5->link2));
										printf("%d ", print_link(octree1->linkE->link5->link3));
										printf("%d ", print_link(octree1->linkE->link5->link4));
										printf("%d ", print_link(octree1->linkE->link5->link5));
										printf("%d ", print_link(octree1->linkE->link5->link6));
										printf("%d ", print_link(octree1->linkE->link5->link7));
									}
									printf("%d ", print_link(octree1->linkE->link6));
									if (octree1->linkE->link6 != NULL) {
										printf("%d ", print_link(octree1->linkE->link6->link0));
										printf("%d ", print_link(octree1->linkE->link6->link1));
										printf("%d ", print_link(octree1->linkE->link6->link2));
										printf("%d ", print_link(octree1->linkE->link6->link3));
										printf("%d ", print_link(octree1->linkE->link6->link4));
										printf("%d ", print_link(octree1->linkE->link6->link5));
										printf("%d ", print_link(octree1->linkE->link6->link6));
										printf("%d ", print_link(octree1->linkE->link6->link7));
									}
									printf("%d ", print_link(octree1->linkE->link7));
									if (oc->linkE->link7 != NULL) {
										printf("%d ", print_link(octree1->linkE->link7->link0));
										printf("%d ", print_link(octree1->linkE->link7->link1));
										printf("%d ", print_link(octree1->linkE->link7->link2));
										printf("%d ", print_link(octree1->linkE->link7->link3));
										printf("%d ", print_link(octree1->linkE->link7->link4));
										printf("%d ", print_link(octree1->linkE->link7->link5));
										printf("%d ", print_link(octree1->linkE->link7->link6));
										printf("%d ", print_link(octree1->linkE->link7->link7));
									}
#endif
									
									//getchar();
									system("PAUSE");

								}

								//getchar();
							}
							else {
						if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
							// вырождение по Х
							// 0,3,4,7 
							// Эквивалентность : (0,1) (3,2) (4,5) (7,6)
							// Разбита на 8 равных частей:
							// 1,2,5,6
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// нет вырождения.
								switch (octree1->root) {
								case 0:
									break;
								case 1: octree1->linkE = octree1->linkE->link0;
									break;
								case 2:octree1->linkE = octree1->linkE->link3;
									break;
								case 3:
									break;
								case 4:
									break;
								case 5: octree1->linkE = octree1->linkE->link4;
									break;
								case 6: octree1->linkE = octree1->linkE->link7;
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								switch (octree1->root) {
								case 0: octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkE = octree1->linkE->link3;
									break;
								case 4:octree1->linkE = octree1->linkE->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkE = octree1->linkE->link7;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//1,5
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:octree1->linkE = octree1->linkE->link4;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//1,2
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:octree1->linkE = octree1->linkE->link3;
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkE = octree1->linkE->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//1
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkE = octree1->linkE->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}


						}
						else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
							// вырождение по Y
							// 0,1,4,5 
							// (3->0),(2->1),(7->4), (6->5)
							// Разбита на 8 равных частей:
							// 1,2,5,6
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// нет вырождения.
								switch (octree1->root) {
								case 0:
									break;
								case 1: octree1->linkE = octree1->linkE->link0;
									break;
								case 2:octree1->linkE = octree1->linkE->link0;
									break;
								case 3:
									break;
								case 4:
									break;
								case 5: octree1->linkE = octree1->linkE->link4;
									break;
								case 6: octree1->linkE = octree1->linkE->link4;
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								switch (octree1->root) {
								case 0: octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkE = octree1->linkE->link0;
									break;
								case 4:octree1->linkE = octree1->linkE->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkE = octree1->linkE->link4;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//1,5
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:octree1->linkE = octree1->linkE->link4;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//1,2
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:octree1->linkE = octree1->linkE->link0;
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkE = octree1->linkE->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//1
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkE = octree1->linkE->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

						}
						else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
							// вырождение по Z
							// 0,1,2,3
							// (4->0) (5->1) (6->2) (7->3)
							// Разбита на 8 равных частей:
							// 1,2,5,6
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// нет вырождения.
								switch (octree1->root) {
								case 0:
									break;
								case 1: octree1->linkE = octree1->linkE->link0;
									break;
								case 2:octree1->linkE = octree1->linkE->link3;
									break;
								case 3:
									break;
								case 4:
									break;
								case 5: octree1->linkE = octree1->linkE->link0;
									break;
								case 6: octree1->linkE = octree1->linkE->link3;
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								switch (octree1->root) {
								case 0: octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkE = octree1->linkE->link3;
									break;
								case 4:octree1->linkE = octree1->linkE->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkE = octree1->linkE->link3;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//1,5
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:octree1->linkE = octree1->linkE->link0;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//1,2
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:octree1->linkE = octree1->linkE->link3;
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkE = octree1->linkE->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//1
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkE = octree1->linkE->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
							// direction Z
							// 0,4
							// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
							// Разбита на 8 равных частей:
							// 1,2,5,6
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// нет вырождения.
								switch (octree1->root) {
								case 0:
									break;
								case 1: octree1->linkE = octree1->linkE->link0;
									break;
								case 2:octree1->linkE = octree1->linkE->link0;
									break;
								case 3:
									break;
								case 4:
									break;
								case 5: octree1->linkE = octree1->linkE->link4;
									break;
								case 6: octree1->linkE = octree1->linkE->link4;
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								switch (octree1->root) {
								case 0: octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkE = octree1->linkE->link0;
									break;
								case 4:octree1->linkE = octree1->linkE->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkE = octree1->linkE->link4;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//1,5
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:octree1->linkE = octree1->linkE->link4;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//1,2
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:octree1->linkE = octree1->linkE->link0;
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkE = octree1->linkE->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//1
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkE = octree1->linkE->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

						}
						else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
							// direction X
							// 0,1
							// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
							// Разбита на 8 равных частей:
							// 1,2,5,6
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// нет вырождения.
								switch (octree1->root) {
								case 0:
									break;
								case 1: octree1->linkE = octree1->linkE->link0;
									break;
								case 2:octree1->linkE = octree1->linkE->link0;
									break;
								case 3:
									break;
								case 4:
									break;
								case 5: octree1->linkE = octree1->linkE->link0;
									break;
								case 6: octree1->linkE = octree1->linkE->link0;
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								switch (octree1->root) {
								case 0: octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkE = octree1->linkE->link0;
									break;
								case 4:octree1->linkE = octree1->linkE->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkE = octree1->linkE->link0;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//1,5
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:octree1->linkE = octree1->linkE->link0;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//1,2
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:octree1->linkE = octree1->linkE->link0;
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkE = octree1->linkE->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//1
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkE = octree1->linkE->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
							// direction Y
							// 0,3
							// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
							// Разбита на 8 равных частей:
							// 1,2,5,6
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// нет вырождения.
								switch (octree1->root) {
								case 0:
									break;
								case 1: octree1->linkE = octree1->linkE->link0;
									break;
								case 2:octree1->linkE = octree1->linkE->link3;
									break;
								case 3:
									break;
								case 4:
									break;
								case 5: octree1->linkE = octree1->linkE->link0;
									break;
								case 6: octree1->linkE = octree1->linkE->link3;
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								switch (octree1->root) {
								case 0: octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkE = octree1->linkE->link3;
									break;
								case 4:octree1->linkE = octree1->linkE->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkE = octree1->linkE->link3;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//1,5
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:octree1->linkE = octree1->linkE->link0;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//1,2
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:octree1->linkE = octree1->linkE->link3;
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkE = octree1->linkE->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//1
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkE = octree1->linkE->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if (is_null1(octree1->linkE)) {
							// Разбита на 8 равных частей:
							// 1,2,5,6
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// нет вырождения.
								switch (octree1->root) {
								case 0:
									break;
								case 1: octree1->linkE = octree1->linkE->link0;
									break;
								case 2:octree1->linkE = octree1->linkE->link3;
									break;
								case 3:
									break;
								case 4:
									break;
								case 5: octree1->linkE = octree1->linkE->link4;
									break;
								case 6: octree1->linkE = octree1->linkE->link7;
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								switch (octree1->root) {
								case 0: octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkE = octree1->linkE->link3;
									break;
								case 4:octree1->linkE = octree1->linkE->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkE = octree1->linkE->link7;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//1,5
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:octree1->linkE = octree1->linkE->link4;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//1,2
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:octree1->linkE = octree1->linkE->link3;
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkE = octree1->linkE->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//1
								switch (octree1->root) {
								case 0:
									break;
								case 1:octree1->linkE = octree1->linkE->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkE = octree1->linkE->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkE = octree1->linkE->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

						}
						}
						}
						}
					}
					}

					// А другие случаи исключаются при додроблении.
					// одиночная связь, НЕ 4
					if (octree1->b4W == false) {
					if (octree1->linkW != NULL) {
						if (octree1->linkW->link0!=NULL) {
							if ((octree1->linkW->link1 == NULL) && (octree1->linkW->link2 == NULL) && (octree1->linkW->link3 == NULL) && (octree1->linkW->link4 == NULL) && (octree1->linkW->link5 == NULL) && (octree1->linkW->link6 == NULL) && (octree1->linkW->link7 == NULL)) {
								printf("error : octree1->linkW->link0!=NULL a na samom dele ==NULL\n");
								//getchar();
								system("PAUSE");
								exit(1);
							}

						// octree1 это лист.
						bool bSituationX = false;
						bool bSituationY = false;
						bool bSituationZ = false;

						if (bold_stable_version) {
							if (octree1->linkW->minx + 1 == octree1->linkW->maxx) {
								bSituationX = true;
							}
							if (octree1->linkW->miny + 1 == octree1->linkW->maxy) {
								bSituationY = true;
							}
							if (octree1->linkW->minz + 1 == octree1->linkW->maxz) {
								bSituationZ = true;
							}
							if ((octree1->linkW->link0 != NULL)) {
								if (bSituationX != octree1->linkW->link0->brootSituationX) {
									printf("error ne sovpadenie Situation X.");
								}
								if (bSituationY != octree1->linkW->link0->brootSituationY) {
									printf("error ne sovpadenie Situation Y.");
								}
								if (bSituationZ != octree1->linkW->link0->brootSituationZ) {
									printf("error ne sovpadenie Situation Z.");
								}
							}
						}
						else {
							// 4.01.2018 Попробуем так. Чисто на интуиции пока.
							// Здесь мы сохраняем запрет дробления в заданном координатном направлении.
							bSituationX = octree1->linkW->link0->brootSituationX;
							bSituationY = octree1->linkW->link0->brootSituationY;
							bSituationZ = octree1->linkW->link0->brootSituationZ;
						}

						bool bsitX = false;
						if (((!bSituationX) && (bSituationY) && (bSituationZ))) bsitX = true;

						//if ((!octree1->b_the_geometric_fragmentation) || (octree1->bcrushing_when_balancing)) {
						if ((octree1->ilevel==octree1->linkW->ilevel)||(bsitX)) {
						    // Не дробленный лист контачит по грани E с дроблённым обектом.
							if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
								// вырождение по Х
								// 0,3,4,7 
								octree1->b4W = true;
								octree1->linkW0 = octree1->linkW->link0;
								octree1->linkW3 = octree1->linkW->link3;
								octree1->linkW4 = octree1->linkW->link4;
								octree1->linkW7 = octree1->linkW->link7;
								octree1->linkW = NULL;
							}
							else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
								// вырождение по Y
								// 0,1,4,5 
								octree1->b4W = true;
								octree1->linkW0 = octree1->linkW->link1;
								octree1->linkW3 = NULL;
								octree1->linkW4 = octree1->linkW->link5;
								octree1->linkW7 = NULL;
								octree1->linkW = NULL;
							}
							else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
								// вырождение по Z
								// 0,1,2,3
								octree1->b4W = true;
								octree1->linkW0 = octree1->linkW->link1;
								octree1->linkW3 = octree1->linkW->link2;
								octree1->linkW4 = NULL; 
								octree1->linkW7 = NULL; 
								octree1->linkW = NULL;
							}
							else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
								// direction Z
								// 0,4
								octree1->b4W = true;
								octree1->linkW0 = octree1->linkW->link0;
								octree1->linkW3 = NULL; 
								octree1->linkW4 = octree1->linkW->link4;
								octree1->linkW7 = NULL; 
								octree1->linkW = NULL;
							}
							else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
								// direction X
								// 0,1
								octree1->b4W = true;
								octree1->linkW0 = octree1->linkW->link1;
								octree1->linkW3 = NULL; 
								octree1->linkW4 = NULL; 
								octree1->linkW7 = NULL; 
								// Редуцирование четырёх соседей, связь только одна.
								octree1->b4W = false;
								octree1->linkW0 = NULL;
								octree1->linkW = octree1->linkW->link1;
							}
							else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
								// direction Y
								// 0,3
								octree1->b4W = true;
								octree1->linkW0 = octree1->linkW->link0;
								octree1->linkW3 = octree1->linkW->link3;
								octree1->linkW4 = NULL; 
								octree1->linkW7 = NULL; 
								octree1->linkW = NULL;
							}
							else if (is_null1(octree1->linkW)) {
								// Разбита на 8 равных частей:
								// 1,2,5,6
								octree1->b4W = true;
								octree1->linkW0 = octree1->linkW->link1;
								octree1->linkW3 = octree1->linkW->link2;
								octree1->linkW4 = octree1->linkW->link5;
								octree1->linkW7 = octree1->linkW->link6;
								octree1->linkW = NULL;
							}
						}
						else {
							if (octree1->ilevel - octree1->linkW->ilevel != 1) {
								
								if (is_null1_new(octree1->linkW)) {
									if (DEBUG_ALICE_MESH) {
										printf("linkW  is_null1_new\n");
									}
									if (octree1->ilevel-octree1->linkW->ilevel==2) {
										if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
											// вырождение по Х
											// 0,3,4,7 
											// Эквивалентность : (0,1) (3,2) (4,5) (7,6)
											// Разбита на 8 равных частей:
											// 0,3,4,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link3;
													break;
												case 4:octree1->linkW = octree1->linkW->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkW = octree1->linkW->link7;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3,4,7
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkW = octree1->linkW->link3;
													break;
												case 4: octree1->linkW = octree1->linkW->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkW = octree1->linkW->link7;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkW = octree1->linkW->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkW = octree1->linkW->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
										else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
											// вырождение по Y
											// 0,1,4,5 
											// (3->0),(2->1),(7->4), (6->5)
											// Разбита на 8 равных частей:
											// 0,3,4,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link1;
													break;
												case 4:octree1->linkW = octree1->linkW->link5;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkW = octree1->linkW->link5;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3,4,7
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkW = octree1->linkW->link1;
													break;
												case 4: octree1->linkW = octree1->linkW->link5;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkW = octree1->linkW->link5;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkW = octree1->linkW->link5;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link1;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkW = octree1->linkW->link5;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link1;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
											// вырождение по Z
											// 0,1,2,3
											// Разбита на 8 равных частей:
											// 0,3,4,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link2;
													break;
												case 4:octree1->linkW = octree1->linkW->link1;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkW = octree1->linkW->link2;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3,4,7
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkW = octree1->linkW->link2;
													break;
												case 4: octree1->linkW = octree1->linkW->link1;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkW = octree1->linkW->link2;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkW = octree1->linkW->link1;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link2;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkW = octree1->linkW->link1;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link2;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
											// direction Z
											// 0,4
											// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
											// Разбита на 8 равных частей:
											// 0,3,4,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link0;
													break;
												case 4:octree1->linkW = octree1->linkW->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkW = octree1->linkW->link4;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3,4,7
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkW = octree1->linkW->link0;
													break;
												case 4: octree1->linkW = octree1->linkW->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkW = octree1->linkW->link4;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkW = octree1->linkW->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkW = octree1->linkW->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
											// direction X
											// 0,1
											// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
											// Разбита на 8 равных частей:
											// 0,3,4,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link1;
													break;
												case 4:octree1->linkW = octree1->linkW->link1;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkW = octree1->linkW->link1;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3,4,7
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkW = octree1->linkW->link1;
													break;
												case 4: octree1->linkW = octree1->linkW->link1;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkW = octree1->linkW->link1;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkW = octree1->linkW->link1;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link1;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkW = octree1->linkW->link1;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link1;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
											// direction Y
											// 0,3
											// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
											// Разбита на 8 равных частей:
											// 0,3,4,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link3;
													break;
												case 4:octree1->linkW = octree1->linkW->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkW = octree1->linkW->link3;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3,4,7
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkW = octree1->linkW->link3;
													break;
												case 4: octree1->linkW = octree1->linkW->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkW = octree1->linkW->link3;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkW = octree1->linkW->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkW = octree1->linkW->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
										else if (is_null1(octree1->linkW)) {
											// Разбита на 8 равных частей:
											// 0,3,4,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link2;
													break;
												case 4:octree1->linkW = octree1->linkW->link5;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkW = octree1->linkW->link6;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3,4,7
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkW = octree1->linkW->link2;
													break;
												case 4: octree1->linkW = octree1->linkW->link5;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkW = octree1->linkW->link6;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkW = octree1->linkW->link5;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link2;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkW = octree1->linkW->link5;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link2;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}

								    }
								    else {
									     printf("Fatal error!!! W distance meshdu urovnqmi > 2\n");
									     //getchar();
										 system("PAUSE");
									    // exit(1);
								    }
								}
								else {
									printf("error : linkW nepravilnje urovni.\n");
									integer c0 = 0;
									integer c1 = 0;
									integer c2 = 0;
									integer c3 = 0;
									integer c4 = 0;
									integer c5 = 0;
									integer c6 = 0;
									integer c7 = 0;
									is_null3(octree1->linkW, WSIDE, c0, c1, c2, c3, c4, c5, c6, c7);

#if doubleintprecision == 1
									printf("c0=%lld c1=%lld c2=%lld c3=%lld c4=%lld c5=%lld c6=%lld c7=%lld\n", c0, c1, c2, c3, c4, c5, c6, c7);
									printf("%lld ", print_link(octree1->linkW->link0));
									if (octree1->linkW->link0 != NULL) {
										printf("%lld ", print_link(octree1->linkW->link0->link0));
										printf("%lld ", print_link(octree1->linkW->link0->link1));
										printf("%lld ", print_link(octree1->linkW->link0->link2));
										printf("%lld ", print_link(octree1->linkW->link0->link3));
										printf("%lld ", print_link(octree1->linkW->link0->link4));
										printf("%lld ", print_link(octree1->linkW->link0->link5));
										printf("%lld ", print_link(octree1->linkW->link0->link6));
										printf("%lld ", print_link(octree1->linkW->link0->link7));
									}
									printf("%lld ", print_link(octree1->linkW->link1));
									if (octree1->linkW->link1 != NULL) {
										printf("%lld ", print_link(octree1->linkW->link1->link0));
										printf("%lld ", print_link(octree1->linkW->link1->link1));
										printf("%lld ", print_link(octree1->linkW->link1->link2));
										printf("%lld ", print_link(octree1->linkW->link1->link3));
										printf("%lld ", print_link(octree1->linkW->link1->link4));
										printf("%lld ", print_link(octree1->linkW->link1->link5));
										printf("%lld ", print_link(octree1->linkW->link1->link6));
										printf("%lld ", print_link(octree1->linkW->link1->link7));
									}
									printf("%lld ", print_link(octree1->linkW->link2));
									if (octree1->linkW->link2 != NULL) {
										printf("%lld ", print_link(octree1->linkW->link2->link0));
										printf("%lld ", print_link(octree1->linkW->link2->link1));
										printf("%lld ", print_link(octree1->linkW->link2->link2));
										printf("%lld ", print_link(octree1->linkW->link2->link3));
										printf("%lld ", print_link(octree1->linkW->link2->link4));
										printf("%lld ", print_link(octree1->linkW->link2->link5));
										printf("%lld ", print_link(octree1->linkW->link2->link6));
										printf("%lld ", print_link(octree1->linkW->link2->link7));
									}
									printf("%lld ", print_link(octree1->linkW->link3));
									if (octree1->linkW->link3 != NULL) {
										printf("%lld ", print_link(octree1->linkW->link3->link0));
										printf("%lld ", print_link(octree1->linkW->link3->link1));
										printf("%lld ", print_link(octree1->linkW->link3->link2));
										printf("%lld ", print_link(octree1->linkW->link3->link3));
										printf("%lld ", print_link(octree1->linkW->link3->link4));
										printf("%lld ", print_link(octree1->linkW->link3->link5));
										printf("%lld ", print_link(octree1->linkW->link3->link6));
										printf("%lld ", print_link(octree1->linkW->link3->link7));
									}
									printf("%lld ", print_link(octree1->linkW->link4));
									if (octree1->linkW->link4 != NULL) {
										printf("%lld ", print_link(octree1->linkW->link4->link0));
										printf("%lld ", print_link(octree1->linkW->link4->link1));
										printf("%lld ", print_link(octree1->linkW->link4->link2));
										printf("%lld ", print_link(octree1->linkW->link4->link3));
										printf("%lld ", print_link(octree1->linkW->link4->link4));
										printf("%lld ", print_link(octree1->linkW->link4->link5));
										printf("%lld ", print_link(octree1->linkW->link4->link6));
										printf("%lld ", print_link(octree1->linkW->link4->link7));
									}
									printf("%lld ", print_link(octree1->linkW->link5));
									if (octree1->linkW->link5 != NULL) {
										printf("%lld ", print_link(octree1->linkW->link5->link0));
										printf("%lld ", print_link(octree1->linkW->link5->link1));
										printf("%lld ", print_link(octree1->linkW->link5->link2));
										printf("%lld ", print_link(octree1->linkW->link5->link3));
										printf("%lld ", print_link(octree1->linkW->link5->link4));
										printf("%lld ", print_link(octree1->linkW->link5->link5));
										printf("%lld ", print_link(octree1->linkW->link5->link6));
										printf("%lld ", print_link(octree1->linkW->link5->link7));
									}
									printf("%lld ", print_link(octree1->linkW->link6));
									if (octree1->linkW->link6 != NULL) {
										printf("%lld ", print_link(octree1->linkW->link6->link0));
										printf("%lld ", print_link(octree1->linkW->link6->link1));
										printf("%lld ", print_link(octree1->linkW->link6->link2));
										printf("%lld ", print_link(octree1->linkW->link6->link3));
										printf("%lld ", print_link(octree1->linkW->link6->link4));
										printf("%lld ", print_link(octree1->linkW->link6->link5));
										printf("%lld ", print_link(octree1->linkW->link6->link6));
										printf("%lld ", print_link(octree1->linkW->link6->link7));
									}
									printf("%lld ", print_link(octree1->linkW->link7));
									if (oc->linkW->link7 != NULL) {
										printf("%lld ", print_link(octree1->linkW->link7->link0));
										printf("%lld ", print_link(octree1->linkW->link7->link1));
										printf("%lld ", print_link(octree1->linkW->link7->link2));
										printf("%lld ", print_link(octree1->linkW->link7->link3));
										printf("%lld ", print_link(octree1->linkW->link7->link4));
										printf("%lld ", print_link(octree1->linkW->link7->link5));
										printf("%lld ", print_link(octree1->linkW->link7->link6));
										printf("%lld ", print_link(octree1->linkW->link7->link7));
									}
#else
									printf("c0=%d c1=%d c2=%d c3=%d c4=%d c5=%d c6=%d c7=%d\n", c0, c1, c2, c3, c4, c5, c6, c7);
									printf("%d ", print_link(octree1->linkW->link0));
									if (octree1->linkW->link0 != NULL) {
										printf("%d ", print_link(octree1->linkW->link0->link0));
										printf("%d ", print_link(octree1->linkW->link0->link1));
										printf("%d ", print_link(octree1->linkW->link0->link2));
										printf("%d ", print_link(octree1->linkW->link0->link3));
										printf("%d ", print_link(octree1->linkW->link0->link4));
										printf("%d ", print_link(octree1->linkW->link0->link5));
										printf("%d ", print_link(octree1->linkW->link0->link6));
										printf("%d ", print_link(octree1->linkW->link0->link7));
									}
									printf("%d ", print_link(octree1->linkW->link1));
									if (octree1->linkW->link1 != NULL) {
										printf("%d ", print_link(octree1->linkW->link1->link0));
										printf("%d ", print_link(octree1->linkW->link1->link1));
										printf("%d ", print_link(octree1->linkW->link1->link2));
										printf("%d ", print_link(octree1->linkW->link1->link3));
										printf("%d ", print_link(octree1->linkW->link1->link4));
										printf("%d ", print_link(octree1->linkW->link1->link5));
										printf("%d ", print_link(octree1->linkW->link1->link6));
										printf("%d ", print_link(octree1->linkW->link1->link7));
									}
									printf("%d ", print_link(octree1->linkW->link2));
									if (octree1->linkW->link2 != NULL) {
										printf("%d ", print_link(octree1->linkW->link2->link0));
										printf("%d ", print_link(octree1->linkW->link2->link1));
										printf("%d ", print_link(octree1->linkW->link2->link2));
										printf("%d ", print_link(octree1->linkW->link2->link3));
										printf("%d ", print_link(octree1->linkW->link2->link4));
										printf("%d ", print_link(octree1->linkW->link2->link5));
										printf("%d ", print_link(octree1->linkW->link2->link6));
										printf("%d ", print_link(octree1->linkW->link2->link7));
									}
									printf("%d ", print_link(octree1->linkW->link3));
									if (octree1->linkW->link3 != NULL) {
										printf("%d ", print_link(octree1->linkW->link3->link0));
										printf("%d ", print_link(octree1->linkW->link3->link1));
										printf("%d ", print_link(octree1->linkW->link3->link2));
										printf("%d ", print_link(octree1->linkW->link3->link3));
										printf("%d ", print_link(octree1->linkW->link3->link4));
										printf("%d ", print_link(octree1->linkW->link3->link5));
										printf("%d ", print_link(octree1->linkW->link3->link6));
										printf("%d ", print_link(octree1->linkW->link3->link7));
									}
									printf("%d ", print_link(octree1->linkW->link4));
									if (octree1->linkW->link4 != NULL) {
										printf("%d ", print_link(octree1->linkW->link4->link0));
										printf("%d ", print_link(octree1->linkW->link4->link1));
										printf("%d ", print_link(octree1->linkW->link4->link2));
										printf("%d ", print_link(octree1->linkW->link4->link3));
										printf("%d ", print_link(octree1->linkW->link4->link4));
										printf("%d ", print_link(octree1->linkW->link4->link5));
										printf("%d ", print_link(octree1->linkW->link4->link6));
										printf("%d ", print_link(octree1->linkW->link4->link7));
									}
									printf("%d ", print_link(octree1->linkW->link5));
									if (octree1->linkW->link5 != NULL) {
										printf("%d ", print_link(octree1->linkW->link5->link0));
										printf("%d ", print_link(octree1->linkW->link5->link1));
										printf("%d ", print_link(octree1->linkW->link5->link2));
										printf("%d ", print_link(octree1->linkW->link5->link3));
										printf("%d ", print_link(octree1->linkW->link5->link4));
										printf("%d ", print_link(octree1->linkW->link5->link5));
										printf("%d ", print_link(octree1->linkW->link5->link6));
										printf("%d ", print_link(octree1->linkW->link5->link7));
									}
									printf("%d ", print_link(octree1->linkW->link6));
									if (octree1->linkW->link6 != NULL) {
										printf("%d ", print_link(octree1->linkW->link6->link0));
										printf("%d ", print_link(octree1->linkW->link6->link1));
										printf("%d ", print_link(octree1->linkW->link6->link2));
										printf("%d ", print_link(octree1->linkW->link6->link3));
										printf("%d ", print_link(octree1->linkW->link6->link4));
										printf("%d ", print_link(octree1->linkW->link6->link5));
										printf("%d ", print_link(octree1->linkW->link6->link6));
										printf("%d ", print_link(octree1->linkW->link6->link7));
									}
									printf("%d ", print_link(octree1->linkW->link7));
									if (oc->linkW->link7 != NULL) {
										printf("%d ", print_link(octree1->linkW->link7->link0));
										printf("%d ", print_link(octree1->linkW->link7->link1));
										printf("%d ", print_link(octree1->linkW->link7->link2));
										printf("%d ", print_link(octree1->linkW->link7->link3));
										printf("%d ", print_link(octree1->linkW->link7->link4));
										printf("%d ", print_link(octree1->linkW->link7->link5));
										printf("%d ", print_link(octree1->linkW->link7->link6));
										printf("%d ", print_link(octree1->linkW->link7->link7));
									}
#endif
									
									//getchar();
									system("PAUSE");
								}


								//getchar();
							}
							else {
						if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
							// вырождение по Х
							// 0,3,4,7 
							// Эквивалентность : (0,1) (3,2) (4,5) (7,6)
							// Разбита на 8 равных частей:
							// 0,3,4,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link3;
									break;
								case 4:octree1->linkW = octree1->linkW->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkW = octree1->linkW->link7;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3,4,7
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkW = octree1->linkW->link3;
									break;
								case 4: octree1->linkW = octree1->linkW->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkW = octree1->linkW->link7;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,4
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkW = octree1->linkW->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkW = octree1->linkW->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

						}
						else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
							// вырождение по Y
							// 0,1,4,5 
							// (3->0),(2->1),(7->4), (6->5)
							// Разбита на 8 равных частей:
							// 0,3,4,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link1;
									break;
								case 4:octree1->linkW = octree1->linkW->link5;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkW = octree1->linkW->link5;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3,4,7
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkW = octree1->linkW->link1;
									break;
								case 4: octree1->linkW = octree1->linkW->link5;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkW = octree1->linkW->link5;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,4
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkW = octree1->linkW->link5;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link1;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkW = octree1->linkW->link5;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link1;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
							// вырождение по Z
							// 0,1,2,3
							// Разбита на 8 равных частей:
							// 0,3,4,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link2;
									break;
								case 4:octree1->linkW = octree1->linkW->link1;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkW = octree1->linkW->link2;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3,4,7
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkW = octree1->linkW->link2;
									break;
								case 4: octree1->linkW = octree1->linkW->link1;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkW = octree1->linkW->link2;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,4
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkW = octree1->linkW->link1;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link2;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkW = octree1->linkW->link1;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link2;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
							// direction Z
							// 0,4
							// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
							// Разбита на 8 равных частей:
							// 0,3,4,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link0;
									break;
								case 4:octree1->linkW = octree1->linkW->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkW = octree1->linkW->link4;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3,4,7
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkW = octree1->linkW->link0;
									break;
								case 4: octree1->linkW = octree1->linkW->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkW = octree1->linkW->link4;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,4
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkW = octree1->linkW->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkW = octree1->linkW->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
							// direction X
							// 0,1
							// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
							// Разбита на 8 равных частей:
							// 0,3,4,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link1;
									break;
								case 4:octree1->linkW = octree1->linkW->link1;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkW = octree1->linkW->link1;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3,4,7
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkW = octree1->linkW->link1;
									break;
								case 4: octree1->linkW = octree1->linkW->link1;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkW = octree1->linkW->link1;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,4
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkW = octree1->linkW->link1;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link1;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkW = octree1->linkW->link1;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link1;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
							// direction Y
							// 0,3
							// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
							// Разбита на 8 равных частей:
							// 0,3,4,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link3;
									break;
								case 4:octree1->linkW = octree1->linkW->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkW = octree1->linkW->link3;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3,4,7
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkW = octree1->linkW->link3;
									break;
								case 4: octree1->linkW = octree1->linkW->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkW = octree1->linkW->link3;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,4
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkW = octree1->linkW->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkW = octree1->linkW->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

						}
						else if (is_null1(octree1->linkW)) {
							// Разбита на 8 равных частей:
							// 0,3,4,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link2;
									break;
								case 4:octree1->linkW = octree1->linkW->link5;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkW = octree1->linkW->link6;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3,4,7
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkW = octree1->linkW->link2;
									break;
								case 4: octree1->linkW = octree1->linkW->link5;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkW = octree1->linkW->link6;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,4
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkW = octree1->linkW->link5;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link2;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkW = octree1->linkW->link5;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link2;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						}
						}
						}
					}
					}

					// А другие случаи исключаются при додроблении.
					// одиночная связь, НЕ 4
					if (octree1->b4N == false) {
						// только одиночная связь.
					if (octree1->linkN != NULL) {
						// Если одиночная связь не пустая и
						// если одна содержит дробление.
						if (octree1->linkN->link0!=NULL) {
							if ((octree1->linkN->link1 == NULL) && (octree1->linkN->link2 == NULL) && (octree1->linkN->link3 == NULL) && (octree1->linkN->link4 == NULL) && (octree1->linkN->link5 == NULL) && (octree1->linkN->link6 == NULL) && (octree1->linkN->link7 == NULL)) {
								printf("error : octree1->linkN->link0!=NULL a na samom dele ==NULL\n");
								//getchar();
								system("PAUSE");
								exit(1);
							}
						// octree1 это лист.

                        // это ситуации вырождения внутри соседа.
						bool bSituationX = false;
						bool bSituationY = false;
						bool bSituationZ = false;

						if (bold_stable_version) {
							if (octree1->linkN->minx + 1 == octree1->linkN->maxx) {
								bSituationX = true;
							}
							if (octree1->linkN->miny + 1 == octree1->linkN->maxy) {
								bSituationY = true;
							}
							if (octree1->linkN->minz + 1 == octree1->linkN->maxz) {
								bSituationZ = true;
							}
							if ((octree1->linkN->link0 != NULL)) {
								if (bSituationX != octree1->linkN->link0->brootSituationX) {
									printf("error ne sovpadenie Situation X.");
								}
								if (bSituationY != octree1->linkN->link0->brootSituationY) {
									printf("error ne sovpadenie Situation Y.");
								}
								if (bSituationZ != octree1->linkN->link0->brootSituationZ) {
									printf("error ne sovpadenie Situation Z.");
								}
							}
						}
						else {
							// 4.01.2018 Попробуем так. Чисто на интуиции пока.
							// Здесь мы сохраняем запрет дробления в заданном координатном направлении.
							bSituationX = octree1->linkN->link0->brootSituationX;
							bSituationY = octree1->linkN->link0->brootSituationY;
							bSituationZ = octree1->linkN->link0->brootSituationZ;
						}

						// Чрезвычайно коварный случай. 7сентября 2016.
						bool bsitY = false;
						if (((!bSituationY) && (bSituationX) && (bSituationZ))) bsitY = true;


						//if ((!octree1->b_the_geometric_fragmentation) || (octree1->bcrushing_when_balancing)) {
						if ((octree1->ilevel==octree1->linkN->ilevel)||(bsitY)) {
							if (DEBUG_ALICE_MESH) {
								printf("incomming b4N Create. Ok\n");
								//getchar();
							}

						    // Не дробленный лист контачит по грани E с дроблённым обектом.
							if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
								// вырождение по Х
								// 0,3,4,7 
								octree1->b4N = true;
								octree1->linkN2 = NULL;
								octree1->linkN3 = octree1->linkN->link0;
								octree1->linkN6 = NULL;
								octree1->linkN7 = octree1->linkN->link4;
								octree1->linkN = NULL;
							}
							else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
								// вырождение по Y
								// 0,1,4,5 

								//printf("N situation Y\n");
								octree1->b4N = true;
								octree1->linkN2 = octree1->linkN->link1;
								octree1->linkN3 = octree1->linkN->link0;
								octree1->linkN6 = octree1->linkN->link5;
								octree1->linkN7 = octree1->linkN->link4;
								octree1->linkN = NULL;
							}
							else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
								// вырождение по Z
								// 0,1,2,3
								octree1->b4N = true;
								octree1->linkN2 = octree1->linkN->link1;
								octree1->linkN3 = octree1->linkN->link0;
								octree1->linkN6 = NULL; 
								octree1->linkN7 = NULL; 
								octree1->linkN = NULL;
							}
							else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
								// direction Z
								// 0,4
								octree1->b4N = true;
								octree1->linkN2 = NULL;
								octree1->linkN3 = octree1->linkN->link0;
								octree1->linkN6 = NULL; 
								octree1->linkN7 = octree1->linkN->link4;
								octree1->linkN = NULL;
							}
							else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
								// direction X
								// 0,1
								octree1->b4N = true;
								octree1->linkN2 = octree1->linkN->link1;
								octree1->linkN3 = octree1->linkN->link0;
								octree1->linkN6 = NULL; 
								octree1->linkN7 = NULL; 
								octree1->linkN = NULL;
							}
							else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
								// direction Y
								// 0,3
								octree1->b4N = true;
								octree1->linkN2 = NULL; 
								octree1->linkN3 = octree1->linkN->link0;
								octree1->linkN6 = NULL; 
								octree1->linkN7 = NULL;
								// Редуцирование четырёх соседей.
								octree1->b4N = false;
								octree1->linkN3 = NULL;
								octree1->linkN = octree1->linkN->link0;
							}
							else if (is_null1(octree1->linkN)) {
								// Разбита на 8 равных частей:
								// 1,2,5,6
#if doubleintprecision == 1
			//printf("N div by 8 octree1->root=%lld",octree1->root); // Во всех 16.
#else
			//printf("N div by 8 octree1->root=%d",octree1->root); // Во всех 16.
#endif
								
								if (octree1->brootSituationY) {
									//printf(" sitY=1\n");
								}
								else {
									//printf(" sitY=0\n");
								}
								octree1->b4N = true;
								octree1->linkN2 = octree1->linkN->link1;
								octree1->linkN3 = octree1->linkN->link0;
								octree1->linkN6 = octree1->linkN->link5;
								octree1->linkN7 = octree1->linkN->link4;
								octree1->linkN = NULL;
							}
						}
						else {
							if (octree1->ilevel - octree1->linkN->ilevel != 1) {
								
								if (is_null1_new(octree1->linkN)) {
									if (DEBUG_ALICE_MESH) {
										printf("linkN is_null1_new.\n");
									}
									if (octree1->ilevel - octree1->linkN->ilevel ==2) {
										if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
											// вырождение по Х
											// 0,3,4,7 
											// Эквивалентность : (0,1) (3,2) (4,5) (7,6)
											// Разбита на 8 равных частей:
											// 3,2,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link0;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6: octree1->linkN = octree1->linkN->link4;
													break;
												case 7:octree1->linkN = octree1->linkN->link4;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 3, 7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkN = octree1->linkN->link4;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link4;
													break;
												case 5:octree1->linkN = octree1->linkN->link4;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//2,3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link0;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
										else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
											// вырождение по Y
											// 0,1,4,5 
											// (3->0),(2->1),(7->4), (6->5)
											// Разбита на 8 равных частей:
											// 3,2,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link1;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6: octree1->linkN = octree1->linkN->link5;
													break;
												case 7:octree1->linkN = octree1->linkN->link4;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 3, 7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkN = octree1->linkN->link4;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link4;
													break;
												case 5:octree1->linkN = octree1->linkN->link5;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//2,3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link1;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
											// вырождение по Z
											// 0,1,2,3
											// (4->0) (5->1) (6->2) (7->3)
											// Разбита на 8 равных частей:
											// 3,2,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link1;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6: octree1->linkN = octree1->linkN->link1;
													break;
												case 7:octree1->linkN = octree1->linkN->link0;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 3, 7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkN = octree1->linkN->link0;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link0;
													break;
												case 5:octree1->linkN = octree1->linkN->link1;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//2,3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link1;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
											// direction Z
											// 0,4
											// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
											// Разбита на 8 равных частей:
											// 3,2,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link0;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6: octree1->linkN = octree1->linkN->link4;
													break;
												case 7:octree1->linkN = octree1->linkN->link4;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 3, 7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkN = octree1->linkN->link4;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link4;
													break;
												case 5:octree1->linkN = octree1->linkN->link4;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//2,3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link0;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
											// direction X
											// 0,1
											// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
											// Разбита на 8 равных частей:
											// 3,2,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link1;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6: octree1->linkN = octree1->linkN->link1;
													break;
												case 7:octree1->linkN = octree1->linkN->link0;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 3, 7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkN = octree1->linkN->link0;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link0;
													break;
												case 5:octree1->linkN = octree1->linkN->link1;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//2,3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link1;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
											// direction Y
											// 0,3
											// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
											// Разбита на 8 равных частей:
											// 3,2,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link0;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6: octree1->linkN = octree1->linkN->link0;
													break;
												case 7:octree1->linkN = octree1->linkN->link0;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 3, 7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkN = octree1->linkN->link0;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link0;
													break;
												case 5:octree1->linkN = octree1->linkN->link0;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//2,3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link0;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if (is_null1(octree1->linkN)) {
											// Разбита на 8 равных частей:
											// 3,2,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link1;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6: octree1->linkN = octree1->linkN->link5;
													break;
												case 7:octree1->linkN = octree1->linkN->link4;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 3, 7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkN = octree1->linkN->link4;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link4;
													break;
												case 5:octree1->linkN = octree1->linkN->link5;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//2,3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link1;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}

									}
									else {
										printf("Fatal error!!! N distance meshdu urovnqmi > 2\n");
										//getchar();
										system("PAUSE");
										//exit(1);
									}

								}
								else {
									printf("error : linkN nepravilnje urovni.\n");
#if doubleintprecision == 1
									printf("octree1->ilevel=%lld octree1->linkN->ilevel=%lld\n", octree1->ilevel, octree1->linkN->ilevel);
#else
									printf("octree1->ilevel=%d octree1->linkN->ilevel=%d\n", octree1->ilevel, octree1->linkN->ilevel);
#endif
									integer c0 = 0;
									integer c1 = 0;
									integer c2 = 0;
									integer c3 = 0;
									integer c4 = 0;
									integer c5 = 0;
									integer c6 = 0;
									integer c7 = 0;
									is_null3(octree1->linkN, NSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
#if doubleintprecision == 1

									printf("c0=%lld c1=%lld c2=%lld c3=%lld c4=%lld c5=%lld c6=%lld c7=%lld\n", c0, c1, c2, c3, c4, c5, c6, c7);
									printf("%lld ", print_link(octree1->linkN->link0));
									if (octree1->linkN->link0 != NULL) {
										printf("%lld ", print_link(octree1->linkN->link0->link0));
										printf("%lld ", print_link(octree1->linkN->link0->link1));
										printf("%lld ", print_link(octree1->linkN->link0->link2));
										printf("%lld ", print_link(octree1->linkN->link0->link3));
										printf("%lld ", print_link(octree1->linkN->link0->link4));
										printf("%lld ", print_link(octree1->linkN->link0->link5));
										printf("%lld ", print_link(octree1->linkN->link0->link6));
										printf("%lld ", print_link(octree1->linkN->link0->link7));
									}
									printf("%lld ", print_link(octree1->linkN->link1));
									if (octree1->linkN->link1 != NULL) {
										printf("%lld ", print_link(octree1->linkN->link1->link0));
										printf("%lld ", print_link(octree1->linkN->link1->link1));
										printf("%lld ", print_link(octree1->linkN->link1->link2));
										printf("%lld ", print_link(octree1->linkN->link1->link3));
										printf("%lld ", print_link(octree1->linkN->link1->link4));
										printf("%lld ", print_link(octree1->linkN->link1->link5));
										printf("%lld ", print_link(octree1->linkN->link1->link6));
										printf("%lld ", print_link(octree1->linkN->link1->link7));
									}
									printf("%lld ", print_link(octree1->linkN->link2));
									if (octree1->linkN->link2 != NULL) {
										printf("%lld ", print_link(octree1->linkN->link2->link0));
										printf("%lld ", print_link(octree1->linkN->link2->link1));
										printf("%lld ", print_link(octree1->linkN->link2->link2));
										printf("%lld ", print_link(octree1->linkN->link2->link3));
										printf("%lld ", print_link(octree1->linkN->link2->link4));
										printf("%lld ", print_link(octree1->linkN->link2->link5));
										printf("%lld ", print_link(octree1->linkN->link2->link6));
										printf("%lld ", print_link(octree1->linkN->link2->link7));
									}
									printf("%lld ", print_link(octree1->linkN->link3));
									if (octree1->linkN->link3 != NULL) {
										printf("%lld ", print_link(octree1->linkN->link3->link0));
										printf("%lld ", print_link(octree1->linkN->link3->link1));
										printf("%lld ", print_link(octree1->linkN->link3->link2));
										printf("%lld ", print_link(octree1->linkN->link3->link3));
										printf("%lld ", print_link(octree1->linkN->link3->link4));
										printf("%lld ", print_link(octree1->linkN->link3->link5));
										printf("%lld ", print_link(octree1->linkN->link3->link6));
										printf("%lld ", print_link(octree1->linkN->link3->link7));
									}
									printf("%lld ", print_link(octree1->linkN->link4));
									if (octree1->linkN->link4 != NULL) {
										printf("%lld ", print_link(octree1->linkN->link4->link0));
										printf("%lld ", print_link(octree1->linkN->link4->link1));
										printf("%lld ", print_link(octree1->linkN->link4->link2));
										printf("%lld ", print_link(octree1->linkN->link4->link3));
										printf("%lld ", print_link(octree1->linkN->link4->link4));
										printf("%lld ", print_link(octree1->linkN->link4->link5));
										printf("%lld ", print_link(octree1->linkN->link4->link6));
										printf("%lld ", print_link(octree1->linkN->link4->link7));
									}
									printf("%lld ", print_link(octree1->linkN->link5));
									if (octree1->linkN->link5 != NULL) {
										printf("%lld ", print_link(octree1->linkN->link5->link0));
										printf("%lld ", print_link(octree1->linkN->link5->link1));
										printf("%lld ", print_link(octree1->linkN->link5->link2));
										printf("%lld ", print_link(octree1->linkN->link5->link3));
										printf("%lld ", print_link(octree1->linkN->link5->link4));
										printf("%lld ", print_link(octree1->linkN->link5->link5));
										printf("%lld ", print_link(octree1->linkN->link5->link6));
										printf("%lld ", print_link(octree1->linkN->link5->link7));
									}
									printf("%lld ", print_link(octree1->linkN->link6));
									if (octree1->linkN->link6 != NULL) {
										printf("%lld ", print_link(octree1->linkN->link6->link0));
										printf("%lld ", print_link(octree1->linkN->link6->link1));
										printf("%lld ", print_link(octree1->linkN->link6->link2));
										printf("%lld ", print_link(octree1->linkN->link6->link3));
										printf("%lld ", print_link(octree1->linkN->link6->link4));
										printf("%lld ", print_link(octree1->linkN->link6->link5));
										printf("%lld ", print_link(octree1->linkN->link6->link6));
										printf("%lld ", print_link(octree1->linkN->link6->link7));
									}
									printf("%lld ", print_link(octree1->linkN->link7));
									if (oc->linkN->link7 != NULL) {
										printf("%lld ", print_link(octree1->linkN->link7->link0));
										printf("%lld ", print_link(octree1->linkN->link7->link1));
										printf("%lld ", print_link(octree1->linkN->link7->link2));
										printf("%lld ", print_link(octree1->linkN->link7->link3));
										printf("%lld ", print_link(octree1->linkN->link7->link4));
										printf("%lld ", print_link(octree1->linkN->link7->link5));
										printf("%lld ", print_link(octree1->linkN->link7->link6));
										printf("%lld ", print_link(octree1->linkN->link7->link7));
									}
#else

									printf("c0=%d c1=%d c2=%d c3=%d c4=%d c5=%d c6=%d c7=%d\n", c0, c1, c2, c3, c4, c5, c6, c7);
									printf("%d ", print_link(octree1->linkN->link0));
									if (octree1->linkN->link0 != NULL) {
										printf("%d ", print_link(octree1->linkN->link0->link0));
										printf("%d ", print_link(octree1->linkN->link0->link1));
										printf("%d ", print_link(octree1->linkN->link0->link2));
										printf("%d ", print_link(octree1->linkN->link0->link3));
										printf("%d ", print_link(octree1->linkN->link0->link4));
										printf("%d ", print_link(octree1->linkN->link0->link5));
										printf("%d ", print_link(octree1->linkN->link0->link6));
										printf("%d ", print_link(octree1->linkN->link0->link7));
									}
									printf("%d ", print_link(octree1->linkN->link1));
									if (octree1->linkN->link1 != NULL) {
										printf("%d ", print_link(octree1->linkN->link1->link0));
										printf("%d ", print_link(octree1->linkN->link1->link1));
										printf("%d ", print_link(octree1->linkN->link1->link2));
										printf("%d ", print_link(octree1->linkN->link1->link3));
										printf("%d ", print_link(octree1->linkN->link1->link4));
										printf("%d ", print_link(octree1->linkN->link1->link5));
										printf("%d ", print_link(octree1->linkN->link1->link6));
										printf("%d ", print_link(octree1->linkN->link1->link7));
									}
									printf("%d ", print_link(octree1->linkN->link2));
									if (octree1->linkN->link2 != NULL) {
										printf("%d ", print_link(octree1->linkN->link2->link0));
										printf("%d ", print_link(octree1->linkN->link2->link1));
										printf("%d ", print_link(octree1->linkN->link2->link2));
										printf("%d ", print_link(octree1->linkN->link2->link3));
										printf("%d ", print_link(octree1->linkN->link2->link4));
										printf("%d ", print_link(octree1->linkN->link2->link5));
										printf("%d ", print_link(octree1->linkN->link2->link6));
										printf("%d ", print_link(octree1->linkN->link2->link7));
									}
									printf("%d ", print_link(octree1->linkN->link3));
									if (octree1->linkN->link3 != NULL) {
										printf("%d ", print_link(octree1->linkN->link3->link0));
										printf("%d ", print_link(octree1->linkN->link3->link1));
										printf("%d ", print_link(octree1->linkN->link3->link2));
										printf("%d ", print_link(octree1->linkN->link3->link3));
										printf("%d ", print_link(octree1->linkN->link3->link4));
										printf("%d ", print_link(octree1->linkN->link3->link5));
										printf("%d ", print_link(octree1->linkN->link3->link6));
										printf("%d ", print_link(octree1->linkN->link3->link7));
									}
									printf("%d ", print_link(octree1->linkN->link4));
									if (octree1->linkN->link4 != NULL) {
										printf("%d ", print_link(octree1->linkN->link4->link0));
										printf("%d ", print_link(octree1->linkN->link4->link1));
										printf("%d ", print_link(octree1->linkN->link4->link2));
										printf("%d ", print_link(octree1->linkN->link4->link3));
										printf("%d ", print_link(octree1->linkN->link4->link4));
										printf("%d ", print_link(octree1->linkN->link4->link5));
										printf("%d ", print_link(octree1->linkN->link4->link6));
										printf("%d ", print_link(octree1->linkN->link4->link7));
									}
									printf("%d ", print_link(octree1->linkN->link5));
									if (octree1->linkN->link5 != NULL) {
										printf("%d ", print_link(octree1->linkN->link5->link0));
										printf("%d ", print_link(octree1->linkN->link5->link1));
										printf("%d ", print_link(octree1->linkN->link5->link2));
										printf("%d ", print_link(octree1->linkN->link5->link3));
										printf("%d ", print_link(octree1->linkN->link5->link4));
										printf("%d ", print_link(octree1->linkN->link5->link5));
										printf("%d ", print_link(octree1->linkN->link5->link6));
										printf("%d ", print_link(octree1->linkN->link5->link7));
									}
									printf("%d ", print_link(octree1->linkN->link6));
									if (octree1->linkN->link6 != NULL) {
										printf("%d ", print_link(octree1->linkN->link6->link0));
										printf("%d ", print_link(octree1->linkN->link6->link1));
										printf("%d ", print_link(octree1->linkN->link6->link2));
										printf("%d ", print_link(octree1->linkN->link6->link3));
										printf("%d ", print_link(octree1->linkN->link6->link4));
										printf("%d ", print_link(octree1->linkN->link6->link5));
										printf("%d ", print_link(octree1->linkN->link6->link6));
										printf("%d ", print_link(octree1->linkN->link6->link7));
									}
									printf("%d ", print_link(octree1->linkN->link7));
									if (oc->linkN->link7 != NULL) {
										printf("%d ", print_link(octree1->linkN->link7->link0));
										printf("%d ", print_link(octree1->linkN->link7->link1));
										printf("%d ", print_link(octree1->linkN->link7->link2));
										printf("%d ", print_link(octree1->linkN->link7->link3));
										printf("%d ", print_link(octree1->linkN->link7->link4));
										printf("%d ", print_link(octree1->linkN->link7->link5));
										printf("%d ", print_link(octree1->linkN->link7->link6));
										printf("%d ", print_link(octree1->linkN->link7->link7));
									}
#endif
									//getchar();
									system("PAUSE");

								}
								
								//getchar();
							}
							else {
						if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
							// вырождение по Х
							// 0,3,4,7 
							// Эквивалентность : (0,1) (3,2) (4,5) (7,6)
							// Разбита на 8 равных частей:
							// 3,2,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link0;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6: octree1->linkN = octree1->linkN->link4;
									break;
								case 7:octree1->linkN = octree1->linkN->link4;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 3, 7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkN = octree1->linkN->link4;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link4;
									break;
								case 5:octree1->linkN = octree1->linkN->link4;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//2,3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link0;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

						}
						else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
							// вырождение по Y
							// 0,1,4,5 
							// (3->0),(2->1),(7->4), (6->5)
							// Разбита на 8 равных частей:
							// 3,2,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link1;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6: octree1->linkN = octree1->linkN->link5;
									break;
								case 7:octree1->linkN = octree1->linkN->link4;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 3, 7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkN = octree1->linkN->link4;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link4;
									break;
								case 5:octree1->linkN = octree1->linkN->link5;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//2,3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link1;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
							// вырождение по Z
							// 0,1,2,3
							// (4->0) (5->1) (6->2) (7->3)
							// Разбита на 8 равных частей:
							// 3,2,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link1;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6: octree1->linkN = octree1->linkN->link1;
									break;
								case 7:octree1->linkN = octree1->linkN->link0;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 3, 7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkN = octree1->linkN->link0;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link0;
									break;
								case 5:octree1->linkN = octree1->linkN->link1;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//2,3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link1;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
							// direction Z
							// 0,4
							// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
							// Разбита на 8 равных частей:
							// 3,2,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link0;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6: octree1->linkN = octree1->linkN->link4;
									break;
								case 7:octree1->linkN = octree1->linkN->link4;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 3, 7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkN = octree1->linkN->link4;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link4;
									break;
								case 5:octree1->linkN = octree1->linkN->link4;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//2,3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link0;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
							// direction X
							// 0,1
							// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
							// Разбита на 8 равных частей:
							// 3,2,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link1;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6: octree1->linkN = octree1->linkN->link1;
									break;
								case 7:octree1->linkN = octree1->linkN->link0;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 3, 7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkN = octree1->linkN->link0;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link0;
									break;
								case 5:octree1->linkN = octree1->linkN->link1;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//2,3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link1;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
							// direction Y
							// 0,3
							// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
							// Разбита на 8 равных частей:
							// 3,2,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link0;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6: octree1->linkN = octree1->linkN->link0;
									break;
								case 7:octree1->linkN = octree1->linkN->link0;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 3, 7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkN = octree1->linkN->link0;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link0;
									break;
								case 5:octree1->linkN = octree1->linkN->link0;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//2,3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link0;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if (is_null1(octree1->linkN)) {
							// Разбита на 8 равных частей:
							// 3,2,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link1;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6: octree1->linkN = octree1->linkN->link5;
									break;
								case 7:octree1->linkN = octree1->linkN->link4;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 3, 7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkN = octree1->linkN->link4;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link4;
									break;
								case 5:octree1->linkN = octree1->linkN->link5;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//2,3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link1;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						}
						}
						}
					}
					}

					// А другие случаи исключаются при додроблении.
					// одиночная связь, НЕ 4
					if (octree1->b4S == false) {
					if (octree1->linkS != NULL) {
						if (octree1->linkS->link0!=NULL) {
							if ((octree1->linkS->link1 == NULL) && (octree1->linkS->link2 == NULL) && (octree1->linkS->link3 == NULL) && (octree1->linkS->link4 == NULL) && (octree1->linkS->link5 == NULL) && (octree1->linkS->link6 == NULL) && (octree1->linkS->link7 == NULL)) {
								printf("error : octree1->linkS->link0!=NULL a na samom dele ==NULL\n");
								//getchar();
								system("PAUSE");
								exit(1);
							}


						// octree1 это лист.
						bool bSituationX = false;
						bool bSituationY = false;
						bool bSituationZ = false;

						if (bold_stable_version) {
							if (octree1->linkS->minx + 1 == octree1->linkS->maxx) {
								bSituationX = true;
							}
							if (octree1->linkS->miny + 1 == octree1->linkS->maxy) {
								bSituationY = true;
							}
							if (octree1->linkS->minz + 1 == octree1->linkS->maxz) {
								bSituationZ = true;
							}
							if ((octree1->linkS->link0 != NULL)) {
								if (bSituationX != octree1->linkS->link0->brootSituationX) {
									printf("error ne sovpadenie Situation X.");
								}
								if (bSituationY != octree1->linkS->link0->brootSituationY) {
									printf("error ne sovpadenie Situation Y.");
								}
								if (bSituationZ != octree1->linkS->link0->brootSituationZ) {
									printf("error ne sovpadenie Situation Z.");
								}
							}
						}
						else {
							// 4.01.2018 Попробуем так. Чисто на интуиции пока.
							// Здесь мы сохраняем запрет дробления в заданном координатном направлении.
							bSituationX = octree1->linkS->link0->brootSituationX;
							bSituationY = octree1->linkS->link0->brootSituationY;
							bSituationZ = octree1->linkS->link0->brootSituationZ;
						}

						// Чрезвычайно коварный случай. 7 сентября 2016.
						bool bsitY = false;
						if (((!bSituationY) && (bSituationX) && (bSituationZ))) bsitY = true;

						//if ((!octree1->b_the_geometric_fragmentation) || (octree1->bcrushing_when_balancing)) {
						if ((octree1->ilevel==octree1->linkS->ilevel)||(bsitY)) {
						    // Не дробленный лист контачит по грани E с дроблённым обектом.
							if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
								// вырождение по Х
								// 0,3,4,7 
								octree1->b4S = true;
								octree1->linkS0 = octree1->linkS->link3;
								octree1->linkS1 = NULL; 
								octree1->linkS4 = octree1->linkS->link7;
								octree1->linkS5 = NULL; 
								octree1->linkS = NULL;
							}
							else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
								// вырождение по Y
								// 0,1,4,5 
								octree1->b4S = true;
								octree1->linkS0 = octree1->linkS->link0;
								octree1->linkS1 = octree1->linkS->link1;
								octree1->linkS4 = octree1->linkS->link4;
								octree1->linkS5 = octree1->linkS->link5;
								octree1->linkS = NULL;
							}
							else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
								// вырождение по Z
								// 0,1,2,3
								octree1->b4S = true;
								octree1->linkS0 = octree1->linkS->link3;
								octree1->linkS1 = octree1->linkS->link2;
								octree1->linkS4 = NULL; 
								octree1->linkS5 = NULL; 
								octree1->linkS = NULL;
							}
							else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
								// direction Z
								// 0,4
								octree1->b4S = true;
								octree1->linkS0 = octree1->linkS->link0;
								octree1->linkS1 = NULL; 
								octree1->linkS4 = octree1->linkS->link4;
								octree1->linkS5 = NULL;
								octree1->linkS = NULL;
							}
							else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
								// direction X
								// 0,1
								octree1->b4S = true;
								octree1->linkS0 = octree1->linkS->link0;
								octree1->linkS1 = octree1->linkS->link1;
								octree1->linkS4 = NULL;
								octree1->linkS5 = NULL;
								octree1->linkS = NULL;
							}
							else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
								// direction Y
								// 0,3
								octree1->b4S = true;
								octree1->linkS0 = octree1->linkS->link3;
								octree1->linkS1 = NULL; 
								octree1->linkS4 = NULL; 
								octree1->linkS5 = NULL;
								// редуцирование четырёх соседов к одному.
								octree1->b4S = false;
								octree1->linkS0 = NULL;
								octree1->linkS = octree1->linkS->link3;
							}
							else if (is_null1(octree1->linkS)) {
								// Разбита на 8 равных частей:
								// 1,2,5,6
								octree1->b4S = true;
								octree1->linkS0 = octree1->linkS->link3;
								octree1->linkS1 = octree1->linkS->link2;
								octree1->linkS4 = octree1->linkS->link7;
								octree1->linkS5 = octree1->linkS->link6;
								octree1->linkS = NULL;
							}
						}
						else {
							if (octree1->ilevel - octree1->linkS->ilevel != 1) {
								
								if (is_null1_new(octree1->linkS)) {
									if (DEBUG_ALICE_MESH) {
										printf("linkS  is_null1_new. \n");
									}
									if (octree1->ilevel - octree1->linkS->ilevel ==2) {
										if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
											// вырождение по Х
											// 0,3,4,7 
											// Эквивалентность : (0,1) (3,2) (4,5) (7,6)
											// Разбита на 8 равных частей:
											// 0,1,4,5
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1: octree1->linkS = octree1->linkS->link3;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkS = octree1->linkS->link7;
													break;
												case 5: octree1->linkS = octree1->linkS->link7;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link7;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:octree1->linkS = octree1->linkS->link3;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link7;
													break;
												case 5:octree1->linkS = octree1->linkS->link7;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1: octree1->linkS = octree1->linkS->link3;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link7;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:octree1->linkS = octree1->linkS->link3;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
										else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
											// вырождение по Y
											// 0,1,4,5 
											// (3->0),(2->1),(7->4), (6->5)
											// Разбита на 8 равных частей:
											// 0,1,4,5
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link0;
													break;
												case 1: octree1->linkS = octree1->linkS->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkS = octree1->linkS->link4;
													break;
												case 5: octree1->linkS = octree1->linkS->link5;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:octree1->linkS = octree1->linkS->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link4;
													break;
												case 5:octree1->linkS = octree1->linkS->link5;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link0;
													break;
												case 1: octree1->linkS = octree1->linkS->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:octree1->linkS = octree1->linkS->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
										else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
											// вырождение по Z
											// 0,1,2,3
											// (4->0) (5->1) (6->2) (7->3)
											// Разбита на 8 равных частей:
											// 0,1,4,5
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1: octree1->linkS = octree1->linkS->link2;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkS = octree1->linkS->link3;
													break;
												case 5: octree1->linkS = octree1->linkS->link2;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link3;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:octree1->linkS = octree1->linkS->link2;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link3;
													break;
												case 5:octree1->linkS = octree1->linkS->link2;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1: octree1->linkS = octree1->linkS->link2;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link3;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:octree1->linkS = octree1->linkS->link2;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
										else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
											// direction Z
											// 0,4
											// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
											// Разбита на 8 равных частей:
											// 0,1,4,5
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link0;
													break;
												case 1: octree1->linkS = octree1->linkS->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkS = octree1->linkS->link4;
													break;
												case 5: octree1->linkS = octree1->linkS->link4;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:octree1->linkS = octree1->linkS->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link4;
													break;
												case 5:octree1->linkS = octree1->linkS->link4;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link0;
													break;
												case 1: octree1->linkS = octree1->linkS->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:octree1->linkS = octree1->linkS->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
											// direction X
											// 0,1
											// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
											// Разбита на 8 равных частей:
											// 0,1,4,5
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link0;
													break;
												case 1: octree1->linkS = octree1->linkS->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkS = octree1->linkS->link0;
													break;
												case 5: octree1->linkS = octree1->linkS->link1;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:octree1->linkS = octree1->linkS->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link0;
													break;
												case 5:octree1->linkS = octree1->linkS->link1;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link0;
													break;
												case 1: octree1->linkS = octree1->linkS->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:octree1->linkS = octree1->linkS->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
											// direction Y
											// 0,3
											// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
											// Разбита на 8 равных частей:
											// 0,1,4,5
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1: octree1->linkS = octree1->linkS->link3;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkS = octree1->linkS->link3;
													break;
												case 5: octree1->linkS = octree1->linkS->link3;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link3;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:octree1->linkS = octree1->linkS->link3;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link3;
													break;
												case 5:octree1->linkS = octree1->linkS->link3;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1: octree1->linkS = octree1->linkS->link3;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link3;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:octree1->linkS = octree1->linkS->link3;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if (is_null1(octree1->linkS)) {
											// Разбита на 8 равных частей:
											// 0,1,4,5
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1: octree1->linkS = octree1->linkS->link2;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkS = octree1->linkS->link7;
													break;
												case 5: octree1->linkS = octree1->linkS->link6;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link7;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:octree1->linkS = octree1->linkS->link2;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link7;
													break;
												case 5:octree1->linkS = octree1->linkS->link6;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1: octree1->linkS = octree1->linkS->link2;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link7;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:octree1->linkS = octree1->linkS->link2;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0
												switch (octree1->parent->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}

									}
									else {
										printf("Fatal error!!! S distance meshdu urovnqmi > 2\n");
										//getchar();
										system("PAUSE");
										//exit(1);
									}

								}
								else {
									printf("error : linkS nepravilnje urovni.\n");

									integer c0 = 0;
									integer c1 = 0;
									integer c2 = 0;
									integer c3 = 0;
									integer c4 = 0;
									integer c5 = 0;
									integer c6 = 0;
									integer c7 = 0;
									is_null3(octree1->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
#if doubleintprecision == 1
									printf("c0=%lld c1=%lld c2=%lld c3=%lld c4=%lld c5=%lld c6=%lld c7=%lld\n", c0, c1, c2, c3, c4, c5, c6, c7);
									printf("%lld ", print_link(octree1->linkS->link0));
									if (octree1->linkS->link0 != NULL) {
										printf("%lld ", print_link(octree1->linkS->link0->link0));
										printf("%lld ", print_link(octree1->linkS->link0->link1));
										printf("%lld ", print_link(octree1->linkS->link0->link2));
										printf("%lld ", print_link(octree1->linkS->link0->link3));
										printf("%lld ", print_link(octree1->linkS->link0->link4));
										printf("%lld ", print_link(octree1->linkS->link0->link5));
										printf("%lld ", print_link(octree1->linkS->link0->link6));
										printf("%lld ", print_link(octree1->linkS->link0->link7));
									}
									printf("%lld ", print_link(octree1->linkS->link1));
									if (octree1->linkS->link1 != NULL) {
										printf("%lld ", print_link(octree1->linkS->link1->link0));
										printf("%lld ", print_link(octree1->linkS->link1->link1));
										printf("%lld ", print_link(octree1->linkS->link1->link2));
										printf("%lld ", print_link(octree1->linkS->link1->link3));
										printf("%lld ", print_link(octree1->linkS->link1->link4));
										printf("%lld ", print_link(octree1->linkS->link1->link5));
										printf("%lld ", print_link(octree1->linkS->link1->link6));
										printf("%lld ", print_link(octree1->linkS->link1->link7));
									}
									printf("%lld ", print_link(octree1->linkS->link2));
									if (octree1->linkS->link2 != NULL) {
										printf("%lld ", print_link(octree1->linkS->link2->link0));
										printf("%lld ", print_link(octree1->linkS->link2->link1));
										printf("%lld ", print_link(octree1->linkS->link2->link2));
										printf("%lld ", print_link(octree1->linkS->link2->link3));
										printf("%lld ", print_link(octree1->linkS->link2->link4));
										printf("%lld ", print_link(octree1->linkS->link2->link5));
										printf("%lld ", print_link(octree1->linkS->link2->link6));
										printf("%lld ", print_link(octree1->linkS->link2->link7));
									}
									printf("%lld ", print_link(octree1->linkS->link3));
									if (octree1->linkS->link3 != NULL) {
										printf("%lld ", print_link(octree1->linkS->link3->link0));
										printf("%lld ", print_link(octree1->linkS->link3->link1));
										printf("%lld ", print_link(octree1->linkS->link3->link2));
										printf("%lld ", print_link(octree1->linkS->link3->link3));
										printf("%lld ", print_link(octree1->linkS->link3->link4));
										printf("%lld ", print_link(octree1->linkS->link3->link5));
										printf("%lld ", print_link(octree1->linkS->link3->link6));
										printf("%lld ", print_link(octree1->linkS->link3->link7));
									}
									printf("%lld ", print_link(octree1->linkS->link4));
									if (octree1->linkS->link4 != NULL) {
										printf("%lld ", print_link(octree1->linkS->link4->link0));
										printf("%lld ", print_link(octree1->linkS->link4->link1));
										printf("%lld ", print_link(octree1->linkS->link4->link2));
										printf("%lld ", print_link(octree1->linkS->link4->link3));
										printf("%lld ", print_link(octree1->linkS->link4->link4));
										printf("%lld ", print_link(octree1->linkS->link4->link5));
										printf("%lld ", print_link(octree1->linkS->link4->link6));
										printf("%lld ", print_link(octree1->linkS->link4->link7));
									}
									printf("%lld ", print_link(octree1->linkS->link5));
									if (octree1->linkS->link5 != NULL) {
										printf("%lld ", print_link(octree1->linkS->link5->link0));
										printf("%lld ", print_link(octree1->linkS->link5->link1));
										printf("%lld ", print_link(octree1->linkS->link5->link2));
										printf("%lld ", print_link(octree1->linkS->link5->link3));
										printf("%lld ", print_link(octree1->linkS->link5->link4));
										printf("%lld ", print_link(octree1->linkS->link5->link5));
										printf("%lld ", print_link(octree1->linkS->link5->link6));
										printf("%lld ", print_link(octree1->linkS->link5->link7));
									}
									printf("%lld ", print_link(octree1->linkS->link6));
									if (octree1->linkS->link6 != NULL) {
										printf("%lld ", print_link(octree1->linkS->link6->link0));
										printf("%lld ", print_link(octree1->linkS->link6->link1));
										printf("%lld ", print_link(octree1->linkS->link6->link2));
										printf("%lld ", print_link(octree1->linkS->link6->link3));
										printf("%lld ", print_link(octree1->linkS->link6->link4));
										printf("%lld ", print_link(octree1->linkS->link6->link5));
										printf("%lld ", print_link(octree1->linkS->link6->link6));
										printf("%lld ", print_link(octree1->linkS->link6->link7));
									}
									printf("%lld ", print_link(octree1->linkS->link7));
									if (oc->linkS->link7 != NULL) {
										printf("%lld ", print_link(octree1->linkS->link7->link0));
										printf("%lld ", print_link(octree1->linkS->link7->link1));
										printf("%lld ", print_link(octree1->linkS->link7->link2));
										printf("%lld ", print_link(octree1->linkS->link7->link3));
										printf("%lld ", print_link(octree1->linkS->link7->link4));
										printf("%lld ", print_link(octree1->linkS->link7->link5));
										printf("%lld ", print_link(octree1->linkS->link7->link6));
										printf("%lld ", print_link(octree1->linkS->link7->link7));
									}
#else
									printf("c0=%d c1=%d c2=%d c3=%d c4=%d c5=%d c6=%d c7=%d\n", c0, c1, c2, c3, c4, c5, c6, c7);
									printf("%d ", print_link(octree1->linkS->link0));
									if (octree1->linkS->link0 != NULL) {
										printf("%d ", print_link(octree1->linkS->link0->link0));
										printf("%d ", print_link(octree1->linkS->link0->link1));
										printf("%d ", print_link(octree1->linkS->link0->link2));
										printf("%d ", print_link(octree1->linkS->link0->link3));
										printf("%d ", print_link(octree1->linkS->link0->link4));
										printf("%d ", print_link(octree1->linkS->link0->link5));
										printf("%d ", print_link(octree1->linkS->link0->link6));
										printf("%d ", print_link(octree1->linkS->link0->link7));
									}
									printf("%d ", print_link(octree1->linkS->link1));
									if (octree1->linkS->link1 != NULL) {
										printf("%d ", print_link(octree1->linkS->link1->link0));
										printf("%d ", print_link(octree1->linkS->link1->link1));
										printf("%d ", print_link(octree1->linkS->link1->link2));
										printf("%d ", print_link(octree1->linkS->link1->link3));
										printf("%d ", print_link(octree1->linkS->link1->link4));
										printf("%d ", print_link(octree1->linkS->link1->link5));
										printf("%d ", print_link(octree1->linkS->link1->link6));
										printf("%d ", print_link(octree1->linkS->link1->link7));
									}
									printf("%d ", print_link(octree1->linkS->link2));
									if (octree1->linkS->link2 != NULL) {
										printf("%d ", print_link(octree1->linkS->link2->link0));
										printf("%d ", print_link(octree1->linkS->link2->link1));
										printf("%d ", print_link(octree1->linkS->link2->link2));
										printf("%d ", print_link(octree1->linkS->link2->link3));
										printf("%d ", print_link(octree1->linkS->link2->link4));
										printf("%d ", print_link(octree1->linkS->link2->link5));
										printf("%d ", print_link(octree1->linkS->link2->link6));
										printf("%d ", print_link(octree1->linkS->link2->link7));
									}
									printf("%d ", print_link(octree1->linkS->link3));
									if (octree1->linkS->link3 != NULL) {
										printf("%d ", print_link(octree1->linkS->link3->link0));
										printf("%d ", print_link(octree1->linkS->link3->link1));
										printf("%d ", print_link(octree1->linkS->link3->link2));
										printf("%d ", print_link(octree1->linkS->link3->link3));
										printf("%d ", print_link(octree1->linkS->link3->link4));
										printf("%d ", print_link(octree1->linkS->link3->link5));
										printf("%d ", print_link(octree1->linkS->link3->link6));
										printf("%d ", print_link(octree1->linkS->link3->link7));
									}
									printf("%d ", print_link(octree1->linkS->link4));
									if (octree1->linkS->link4 != NULL) {
										printf("%d ", print_link(octree1->linkS->link4->link0));
										printf("%d ", print_link(octree1->linkS->link4->link1));
										printf("%d ", print_link(octree1->linkS->link4->link2));
										printf("%d ", print_link(octree1->linkS->link4->link3));
										printf("%d ", print_link(octree1->linkS->link4->link4));
										printf("%d ", print_link(octree1->linkS->link4->link5));
										printf("%d ", print_link(octree1->linkS->link4->link6));
										printf("%d ", print_link(octree1->linkS->link4->link7));
									}
									printf("%d ", print_link(octree1->linkS->link5));
									if (octree1->linkS->link5 != NULL) {
										printf("%d ", print_link(octree1->linkS->link5->link0));
										printf("%d ", print_link(octree1->linkS->link5->link1));
										printf("%d ", print_link(octree1->linkS->link5->link2));
										printf("%d ", print_link(octree1->linkS->link5->link3));
										printf("%d ", print_link(octree1->linkS->link5->link4));
										printf("%d ", print_link(octree1->linkS->link5->link5));
										printf("%d ", print_link(octree1->linkS->link5->link6));
										printf("%d ", print_link(octree1->linkS->link5->link7));
									}
									printf("%d ", print_link(octree1->linkS->link6));
									if (octree1->linkS->link6 != NULL) {
										printf("%d ", print_link(octree1->linkS->link6->link0));
										printf("%d ", print_link(octree1->linkS->link6->link1));
										printf("%d ", print_link(octree1->linkS->link6->link2));
										printf("%d ", print_link(octree1->linkS->link6->link3));
										printf("%d ", print_link(octree1->linkS->link6->link4));
										printf("%d ", print_link(octree1->linkS->link6->link5));
										printf("%d ", print_link(octree1->linkS->link6->link6));
										printf("%d ", print_link(octree1->linkS->link6->link7));
									}
									printf("%d ", print_link(octree1->linkS->link7));
									if (oc->linkS->link7 != NULL) {
										printf("%d ", print_link(octree1->linkS->link7->link0));
										printf("%d ", print_link(octree1->linkS->link7->link1));
										printf("%d ", print_link(octree1->linkS->link7->link2));
										printf("%d ", print_link(octree1->linkS->link7->link3));
										printf("%d ", print_link(octree1->linkS->link7->link4));
										printf("%d ", print_link(octree1->linkS->link7->link5));
										printf("%d ", print_link(octree1->linkS->link7->link6));
										printf("%d ", print_link(octree1->linkS->link7->link7));
									}
#endif
									
									//getchar();
									system("PAUSE");

								}
								//getchar();
							}
							else {
						if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
							// вырождение по Х
							// 0,3,4,7 
							// Эквивалентность : (0,1) (3,2) (4,5) (7,6)
							// Разбита на 8 равных частей:
							// 0,1,4,5
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link3;
									break;
								case 1: octree1->linkS = octree1->linkS->link3;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkS = octree1->linkS->link7;
									break;
								case 5: octree1->linkS = octree1->linkS->link7;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link3;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link7;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link3;
									break;
								case 1:octree1->linkS = octree1->linkS->link3;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link7;
									break;
								case 5:octree1->linkS = octree1->linkS->link7;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link3;
									break;
								case 1: octree1->linkS = octree1->linkS->link3;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link3;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link7;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link3;
									break;
								case 1:octree1->linkS = octree1->linkS->link3;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link3;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

						}
						else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
							// вырождение по Y
							// 0,1,4,5 
							// (3->0),(2->1),(7->4), (6->5)
							// Разбита на 8 равных частей:
							// 0,1,4,5
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link0;
									break;
								case 1: octree1->linkS = octree1->linkS->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkS = octree1->linkS->link4;
									break;
								case 5: octree1->linkS = octree1->linkS->link5;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link0;
									break;
								case 1:octree1->linkS = octree1->linkS->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link4;
									break;
								case 5:octree1->linkS = octree1->linkS->link5;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link0;
									break;
								case 1: octree1->linkS = octree1->linkS->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link0;
									break;
								case 1:octree1->linkS = octree1->linkS->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

						}
						else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
							// вырождение по Z
							// 0,1,2,3
							// (4->0) (5->1) (6->2) (7->3)
							// Разбита на 8 равных частей:
							// 0,1,4,5
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link3;
									break;
								case 1: octree1->linkS = octree1->linkS->link2;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkS = octree1->linkS->link3;
									break;
								case 5: octree1->linkS = octree1->linkS->link2;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link3;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link3;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link3;
									break;
								case 1:octree1->linkS = octree1->linkS->link2;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link3;
									break;
								case 5:octree1->linkS = octree1->linkS->link2;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link3;
									break;
								case 1: octree1->linkS = octree1->linkS->link2;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link3;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link3;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link3;
									break;
								case 1:octree1->linkS = octree1->linkS->link2;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link3;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

						}
						else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
							// direction Z
							// 0,4
							// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
							// Разбита на 8 равных частей:
							// 0,1,4,5
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link0;
									break;
								case 1: octree1->linkS = octree1->linkS->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkS = octree1->linkS->link4;
									break;
								case 5: octree1->linkS = octree1->linkS->link4;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link0;
									break;
								case 1:octree1->linkS = octree1->linkS->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link4;
									break;
								case 5:octree1->linkS = octree1->linkS->link4;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link0;
									break;
								case 1: octree1->linkS = octree1->linkS->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link0;
									break;
								case 1:octree1->linkS = octree1->linkS->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
							// direction X
							// 0,1
							// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
							// Разбита на 8 равных частей:
							// 0,1,4,5
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link0;
									break;
								case 1: octree1->linkS = octree1->linkS->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkS = octree1->linkS->link0;
									break;
								case 5: octree1->linkS = octree1->linkS->link1;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link0;
									break;
								case 1:octree1->linkS = octree1->linkS->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link0;
									break;
								case 5:octree1->linkS = octree1->linkS->link1;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link0;
									break;
								case 1: octree1->linkS = octree1->linkS->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link0;
									break;
								case 1:octree1->linkS = octree1->linkS->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
							// direction Y
							// 0,3
							// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
							// Разбита на 8 равных частей:
							// 0,1,4,5
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link3;
									break;
								case 1: octree1->linkS = octree1->linkS->link3;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkS = octree1->linkS->link3;
									break;
								case 5: octree1->linkS = octree1->linkS->link3;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link3;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link3;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link3;
									break;
								case 1:octree1->linkS = octree1->linkS->link3;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link3;
									break;
								case 5:octree1->linkS = octree1->linkS->link3;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link3;
									break;
								case 1: octree1->linkS = octree1->linkS->link3;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link3;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link3;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link3;
									break;
								case 1:octree1->linkS = octree1->linkS->link3;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link3;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if (is_null1(octree1->linkS)) {
							// Разбита на 8 равных частей:
							// 0,1,4,5
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link3;
									break;
								case 1: octree1->linkS = octree1->linkS->link2;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkS = octree1->linkS->link7;
									break;
								case 5: octree1->linkS = octree1->linkS->link6;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link3;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link7;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link3;
									break;
								case 1:octree1->linkS = octree1->linkS->link2;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link7;
									break;
								case 5:octree1->linkS = octree1->linkS->link6;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link3;
									break;
								case 1: octree1->linkS = octree1->linkS->link2;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link3;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkS = octree1->linkS->link7;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkS = octree1->linkS->link3;
									break;
								case 1:octree1->linkS = octree1->linkS->link2;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0
								switch (octree1->root) {
								case 0: octree1->linkS = octree1->linkS->link3;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

						}
						}
						}
						}
					}
					}

					// А другие случаи исключаются при додроблении.
					// одиночная связь, НЕ 4
					if (octree1->b4T == false) {
					if (octree1->linkT != NULL) {
						if (octree1->linkT->link0!=NULL) {
							if ((octree1->linkT->link1 == NULL) && (octree1->linkT->link2 == NULL) && (octree1->linkT->link3 == NULL) && (octree1->linkT->link4 == NULL) && (octree1->linkT->link5 == NULL) && (octree1->linkT->link6 == NULL) && (octree1->linkT->link7 == NULL)) {
								printf("error : octree1->linkT->link0!=NULL a na samom dele ==NULL\n");
								//getchar();
								system("PAUSE");
								exit(1);
							}

						// octree1 это лист.
						bool bSituationX = false;
						bool bSituationY = false;
						bool bSituationZ = false;

						if (bold_stable_version) {
							if (octree1->linkT->minx + 1 == octree1->linkT->maxx) {
								bSituationX = true;
							}
							if (octree1->linkT->miny + 1 == octree1->linkT->maxy) {
								bSituationY = true;
							}
							if (octree1->linkT->minz + 1 == octree1->linkT->maxz) {
								bSituationZ = true;
							}
							if ((octree1->linkT->link0 != NULL)) {
								if (bSituationX != octree1->linkT->link0->brootSituationX) {
									printf("error ne sovpadenie Situation X.");
								}
								if (bSituationY != octree1->linkT->link0->brootSituationY) {
									printf("error ne sovpadenie Situation Y.");
								}
								if (bSituationZ != octree1->linkT->link0->brootSituationZ) {
									printf("error ne sovpadenie Situation Z.");
								}
							}
						}
						else {
							// 4.01.2018 Попробуем так. Чисто на интуиции пока.
							// Здесь мы сохраняем запрет дробления в заданном координатном направлении.
							bSituationX = octree1->linkT->link0->brootSituationX;
							bSituationY = octree1->linkT->link0->brootSituationY;
							bSituationZ = octree1->linkT->link0->brootSituationZ;
						}


						// Чрезвычайно коварный случай. 7сентября 2016.
						bool bsitZ = false;
						if (((!bSituationZ) && (bSituationX) && (bSituationY))) bsitZ = true;

						//if ((!octree1->b_the_geometric_fragmentation) || (octree1->bcrushing_when_balancing)) {
						if ((octree1->ilevel==octree1->linkT->ilevel)||(bsitZ)) {
						// Не дробленный лист контачит по грани E с дроблённым обектом.
							if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
								// вырождение по Х
								// 0,3,4,7 
								octree1->b4T = true;
								octree1->linkT4 = octree1->linkT->link0;
								octree1->linkT5 = NULL; 
								octree1->linkT6 = NULL; 
								octree1->linkT7 = octree1->linkT->link3;
								octree1->linkT = NULL;
							}
							else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
								// вырождение по Y
								// 0,1,4,5 
								octree1->b4T = true;
								octree1->linkT4 = octree1->linkT->link0;
								octree1->linkT5 = octree1->linkT->link1;
								octree1->linkT6 = NULL; 
								octree1->linkT7 = NULL; 
								octree1->linkT = NULL;
							}
							else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
								// вырождение по Z
								// 0,1,2,3
								octree1->b4T = true;
								octree1->linkT4 = octree1->linkT->link0;
								octree1->linkT5 = octree1->linkT->link1;
								octree1->linkT6 = octree1->linkT->link2;
								octree1->linkT7 = octree1->linkT->link3;
								octree1->linkT = NULL;
							}
							else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
								// direction Z
								// 0,4
								octree1->b4T = true;
								octree1->linkT4 = octree1->linkT->link0;
								octree1->linkT5 = NULL; 
								octree1->linkT6 = NULL; 
								octree1->linkT7 = NULL; 
								// Вырождение четырёх соседов к одному.
								octree1->b4T = false;
								octree1->linkT4 = NULL;
								octree1->linkT = octree1->linkT->link0;
							}
							else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
								// direction X
								// 0,1
								octree1->b4T = true;
								octree1->linkT4 = octree1->linkT->link0;
								octree1->linkT5 = octree1->linkT->link1;
								octree1->linkT6 = NULL; 
								octree1->linkT7 = NULL;
								octree1->linkT = NULL;
							}
							else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
								// direction Y
								// 0,3
								octree1->b4T = true;
								octree1->linkT4 = octree1->linkT->link0;
								octree1->linkT5 = NULL; 
								octree1->linkT6 = NULL; 
								octree1->linkT7 = octree1->linkT->link3;
								octree1->linkT = NULL;
							}
							else if (is_null1(octree1->linkT)) {
								// Разбита на 8 равных частей:
								// 1,2,5,6
								octree1->b4T = true;
								octree1->linkT4 = octree1->linkT->link0;
								octree1->linkT5 = octree1->linkT->link1;
								octree1->linkT6 = octree1->linkT->link2;
								octree1->linkT7 = octree1->linkT->link3;
								octree1->linkT = NULL;
							}
						}
						else {
							if (octree1->ilevel - octree1->linkT->ilevel != 1) {
								
								if (is_null1_new(octree1->linkT)) {
									if (DEBUG_ALICE_MESH) {
										printf("linkT  is_null1_new. \n");
									}
									if (octree1->ilevel - octree1->linkT->ilevel ==2) {
										if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
											// вырождение по Х
											// 0,3,4,7 
											// Эквивалентность : (0,1) (3,2) (4,5) (7,6)
											// Разбита на 8 равных частей:
											// 4,5,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkT = octree1->linkT->link0;
													break;
												case 5: octree1->linkT = octree1->linkT->link0;
													break;
												case 6: octree1->linkT = octree1->linkT->link3;
													break;
												case 7: octree1->linkT = octree1->linkT->link3;
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 4,7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkT = octree1->linkT->link3;
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//4,5
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:octree1->linkT = octree1->linkT->link0;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1: octree1->linkT = octree1->linkT->link0;
													break;
												case 2:octree1->linkT = octree1->linkT->link3;
													break;
												case 3:octree1->linkT = octree1->linkT->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkT = octree1->linkT->link0;
													break;
												case 1:octree1->linkT = octree1->linkT->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkT = octree1->linkT->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}


										}
										else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
											// вырождение по Y
											// 0,1,4,5 
											// (3->0),(2->1),(7->4), (6->5)
											// Разбита на 8 равных частей:
											// 4,5,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkT = octree1->linkT->link0;
													break;
												case 5: octree1->linkT = octree1->linkT->link1;
													break;
												case 6: octree1->linkT = octree1->linkT->link1;
													break;
												case 7: octree1->linkT = octree1->linkT->link0;
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 4,7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkT = octree1->linkT->link0;
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//4,5
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:octree1->linkT = octree1->linkT->link1;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1: octree1->linkT = octree1->linkT->link1;
													break;
												case 2:octree1->linkT = octree1->linkT->link1;
													break;
												case 3:octree1->linkT = octree1->linkT->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkT = octree1->linkT->link0;
													break;
												case 1:octree1->linkT = octree1->linkT->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkT = octree1->linkT->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
											// вырождение по Z
											// 0,1,2,3
											// (4->0) (5->1) (6->2) (7->3)
											// Разбита на 8 равных частей:
											// 4,5,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkT = octree1->linkT->link0;
													break;
												case 5: octree1->linkT = octree1->linkT->link1;
													break;
												case 6: octree1->linkT = octree1->linkT->link2;
													break;
												case 7: octree1->linkT = octree1->linkT->link3;
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 4,7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkT = octree1->linkT->link3;
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//4,5
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:octree1->linkT = octree1->linkT->link1;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1: octree1->linkT = octree1->linkT->link1;
													break;
												case 2:octree1->linkT = octree1->linkT->link2;
													break;
												case 3:octree1->linkT = octree1->linkT->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkT = octree1->linkT->link0;
													break;
												case 1:octree1->linkT = octree1->linkT->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkT = octree1->linkT->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
											// direction Z
											// 0,4
											// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
											// Разбита на 8 равных частей:
											// 4,5,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkT = octree1->linkT->link0;
													break;
												case 5: octree1->linkT = octree1->linkT->link0;
													break;
												case 6: octree1->linkT = octree1->linkT->link0;
													break;
												case 7: octree1->linkT = octree1->linkT->link0;
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 4,7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkT = octree1->linkT->link0;
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//4,5
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:octree1->linkT = octree1->linkT->link0;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1: octree1->linkT = octree1->linkT->link0;
													break;
												case 2:octree1->linkT = octree1->linkT->link0;
													break;
												case 3:octree1->linkT = octree1->linkT->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkT = octree1->linkT->link0;
													break;
												case 1:octree1->linkT = octree1->linkT->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkT = octree1->linkT->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
											// direction X
											// 0,1
											// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
											// Разбита на 8 равных частей:
											// 4,5,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
											
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkT = octree1->linkT->link0;
													break;
												case 5: octree1->linkT = octree1->linkT->link1;
													break;
												case 6: octree1->linkT = octree1->linkT->link1;
													break;
												case 7: octree1->linkT = octree1->linkT->link0;
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 4,7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkT = octree1->linkT->link0;
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//4,5
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:octree1->linkT = octree1->linkT->link1;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1: octree1->linkT = octree1->linkT->link1;
													break;
												case 2:octree1->linkT = octree1->linkT->link1;
													break;
												case 3:octree1->linkT = octree1->linkT->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkT = octree1->linkT->link0;
													break;
												case 1:octree1->linkT = octree1->linkT->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkT = octree1->linkT->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
											// direction Y
											// 0,3
											// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
											// Разбита на 8 равных частей:
											// 4,5,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkT = octree1->linkT->link0;
													break;
												case 5: octree1->linkT = octree1->linkT->link0;
													break;
												case 6: octree1->linkT = octree1->linkT->link3;
													break;
												case 7: octree1->linkT = octree1->linkT->link3;
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 4,7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkT = octree1->linkT->link3;
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//4,5
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:octree1->linkT = octree1->linkT->link0;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1: octree1->linkT = octree1->linkT->link0;
													break;
												case 2:octree1->linkT = octree1->linkT->link3;
													break;
												case 3:octree1->linkT = octree1->linkT->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkT = octree1->linkT->link0;
													break;
												case 1:octree1->linkT = octree1->linkT->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkT = octree1->linkT->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if (is_null1(octree1->linkT)) {
											// Разбита на 8 равных частей:
											// 4,5,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkT = octree1->linkT->link0;
													break;
												case 5: octree1->linkT = octree1->linkT->link1;
													break;
												case 6: octree1->linkT = octree1->linkT->link2;
													break;
												case 7: octree1->linkT = octree1->linkT->link3;
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 4,7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkT = octree1->linkT->link3;
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//4,5
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:octree1->linkT = octree1->linkT->link1;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1: octree1->linkT = octree1->linkT->link1;
													break;
												case 2:octree1->linkT = octree1->linkT->link2;
													break;
												case 3:octree1->linkT = octree1->linkT->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkT = octree1->linkT->link0;
													break;
												case 1:octree1->linkT = octree1->linkT->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkT = octree1->linkT->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}

									}
									else {
										printf("Fatal error!!! T distance meshdu urovnqmi > 2\n");
										//getchar();
										system("PAUSE");
										//exit(1);
									}

								}
								else {
									printf("error : linkT nepravilnje urovni.\n");

									integer c0 = 0;
									integer c1 = 0;
									integer c2 = 0;
									integer c3 = 0;
									integer c4 = 0;
									integer c5 = 0;
									integer c6 = 0;
									integer c7 = 0;
									is_null3(octree1->linkT, TSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
#if doubleintprecision == 1
									printf("c0=%lld c1=%lld c2=%lld c3=%lld c4=%lld c5=%lld c6=%lld c7=%lld\n", c0, c1, c2, c3, c4, c5, c6, c7);
									printf("%lld ", print_link(octree1->linkT->link0));
									if (octree1->linkT->link0 != NULL) {
										printf("%lld ", print_link(octree1->linkT->link0->link0));
										printf("%lld ", print_link(octree1->linkT->link0->link1));
										printf("%lld ", print_link(octree1->linkT->link0->link2));
										printf("%lld ", print_link(octree1->linkT->link0->link3));
										printf("%lld ", print_link(octree1->linkT->link0->link4));
										printf("%lld ", print_link(octree1->linkT->link0->link5));
										printf("%lld ", print_link(octree1->linkT->link0->link6));
										printf("%lld ", print_link(octree1->linkT->link0->link7));
									}
									printf("%lld ", print_link(octree1->linkT->link1));
									if (octree1->linkT->link1 != NULL) {
										printf("%lld ", print_link(octree1->linkT->link1->link0));
										printf("%lld ", print_link(octree1->linkT->link1->link1));
										printf("%lld ", print_link(octree1->linkT->link1->link2));
										printf("%lld ", print_link(octree1->linkT->link1->link3));
										printf("%lld ", print_link(octree1->linkT->link1->link4));
										printf("%lld ", print_link(octree1->linkT->link1->link5));
										printf("%lld ", print_link(octree1->linkT->link1->link6));
										printf("%lld ", print_link(octree1->linkT->link1->link7));
									}
									printf("%lld ", print_link(octree1->linkT->link2));
									if (octree1->linkT->link2 != NULL) {
										printf("%lld ", print_link(octree1->linkT->link2->link0));
										printf("%lld ", print_link(octree1->linkT->link2->link1));
										printf("%lld ", print_link(octree1->linkT->link2->link2));
										printf("%lld ", print_link(octree1->linkT->link2->link3));
										printf("%lld ", print_link(octree1->linkT->link2->link4));
										printf("%lld ", print_link(octree1->linkT->link2->link5));
										printf("%lld ", print_link(octree1->linkT->link2->link6));
										printf("%lld ", print_link(octree1->linkT->link2->link7));
									}
									printf("%lld ", print_link(octree1->linkT->link3));
									if (octree1->linkT->link3 != NULL) {
										printf("%lld ", print_link(octree1->linkT->link3->link0));
										printf("%lld ", print_link(octree1->linkT->link3->link1));
										printf("%lld ", print_link(octree1->linkT->link3->link2));
										printf("%lld ", print_link(octree1->linkT->link3->link3));
										printf("%lld ", print_link(octree1->linkT->link3->link4));
										printf("%lld ", print_link(octree1->linkT->link3->link5));
										printf("%lld ", print_link(octree1->linkT->link3->link6));
										printf("%lld ", print_link(octree1->linkT->link3->link7));
									}
									printf("%lld ", print_link(octree1->linkT->link4));
									if (octree1->linkT->link4 != NULL) {
										printf("%lld ", print_link(octree1->linkT->link4->link0));
										printf("%lld ", print_link(octree1->linkT->link4->link1));
										printf("%lld ", print_link(octree1->linkT->link4->link2));
										printf("%lld ", print_link(octree1->linkT->link4->link3));
										printf("%lld ", print_link(octree1->linkT->link4->link4));
										printf("%lld ", print_link(octree1->linkT->link4->link5));
										printf("%lld ", print_link(octree1->linkT->link4->link6));
										printf("%lld ", print_link(octree1->linkT->link4->link7));
									}
									printf("%lld ", print_link(octree1->linkT->link5));
									if (octree1->linkT->link5 != NULL) {
										printf("%lld ", print_link(octree1->linkT->link5->link0));
										printf("%lld ", print_link(octree1->linkT->link5->link1));
										printf("%lld ", print_link(octree1->linkT->link5->link2));
										printf("%lld ", print_link(octree1->linkT->link5->link3));
										printf("%lld ", print_link(octree1->linkT->link5->link4));
										printf("%lld ", print_link(octree1->linkT->link5->link5));
										printf("%lld ", print_link(octree1->linkT->link5->link6));
										printf("%lld ", print_link(octree1->linkT->link5->link7));
									}
									printf("%lld ", print_link(octree1->linkT->link6));
									if (octree1->linkT->link6 != NULL) {
										printf("%lld ", print_link(octree1->linkT->link6->link0));
										printf("%lld ", print_link(octree1->linkT->link6->link1));
										printf("%lld ", print_link(octree1->linkT->link6->link2));
										printf("%lld ", print_link(octree1->linkT->link6->link3));
										printf("%lld ", print_link(octree1->linkT->link6->link4));
										printf("%lld ", print_link(octree1->linkT->link6->link5));
										printf("%lld ", print_link(octree1->linkT->link6->link6));
										printf("%lld ", print_link(octree1->linkT->link6->link7));
									}
									printf("%lld ", print_link(octree1->linkT->link7));
									if (oc->linkT->link7 != NULL) {
										printf("%lld ", print_link(octree1->linkT->link7->link0));
										printf("%lld ", print_link(octree1->linkT->link7->link1));
										printf("%lld ", print_link(octree1->linkT->link7->link2));
										printf("%lld ", print_link(octree1->linkT->link7->link3));
										printf("%lld ", print_link(octree1->linkT->link7->link4));
										printf("%lld ", print_link(octree1->linkT->link7->link5));
										printf("%lld ", print_link(octree1->linkT->link7->link6));
										printf("%lld ", print_link(octree1->linkT->link7->link7));
									}
#else
									printf("c0=%d c1=%d c2=%d c3=%d c4=%d c5=%d c6=%d c7=%d\n", c0, c1, c2, c3, c4, c5, c6, c7);
									printf("%d ", print_link(octree1->linkT->link0));
									if (octree1->linkT->link0 != NULL) {
										printf("%d ", print_link(octree1->linkT->link0->link0));
										printf("%d ", print_link(octree1->linkT->link0->link1));
										printf("%d ", print_link(octree1->linkT->link0->link2));
										printf("%d ", print_link(octree1->linkT->link0->link3));
										printf("%d ", print_link(octree1->linkT->link0->link4));
										printf("%d ", print_link(octree1->linkT->link0->link5));
										printf("%d ", print_link(octree1->linkT->link0->link6));
										printf("%d ", print_link(octree1->linkT->link0->link7));
									}
									printf("%d ", print_link(octree1->linkT->link1));
									if (octree1->linkT->link1 != NULL) {
										printf("%d ", print_link(octree1->linkT->link1->link0));
										printf("%d ", print_link(octree1->linkT->link1->link1));
										printf("%d ", print_link(octree1->linkT->link1->link2));
										printf("%d ", print_link(octree1->linkT->link1->link3));
										printf("%d ", print_link(octree1->linkT->link1->link4));
										printf("%d ", print_link(octree1->linkT->link1->link5));
										printf("%d ", print_link(octree1->linkT->link1->link6));
										printf("%d ", print_link(octree1->linkT->link1->link7));
									}
									printf("%d ", print_link(octree1->linkT->link2));
									if (octree1->linkT->link2 != NULL) {
										printf("%d ", print_link(octree1->linkT->link2->link0));
										printf("%d ", print_link(octree1->linkT->link2->link1));
										printf("%d ", print_link(octree1->linkT->link2->link2));
										printf("%d ", print_link(octree1->linkT->link2->link3));
										printf("%d ", print_link(octree1->linkT->link2->link4));
										printf("%d ", print_link(octree1->linkT->link2->link5));
										printf("%d ", print_link(octree1->linkT->link2->link6));
										printf("%d ", print_link(octree1->linkT->link2->link7));
									}
									printf("%d ", print_link(octree1->linkT->link3));
									if (octree1->linkT->link3 != NULL) {
										printf("%d ", print_link(octree1->linkT->link3->link0));
										printf("%d ", print_link(octree1->linkT->link3->link1));
										printf("%d ", print_link(octree1->linkT->link3->link2));
										printf("%d ", print_link(octree1->linkT->link3->link3));
										printf("%d ", print_link(octree1->linkT->link3->link4));
										printf("%d ", print_link(octree1->linkT->link3->link5));
										printf("%d ", print_link(octree1->linkT->link3->link6));
										printf("%d ", print_link(octree1->linkT->link3->link7));
									}
									printf("%d ", print_link(octree1->linkT->link4));
									if (octree1->linkT->link4 != NULL) {
										printf("%d ", print_link(octree1->linkT->link4->link0));
										printf("%d ", print_link(octree1->linkT->link4->link1));
										printf("%d ", print_link(octree1->linkT->link4->link2));
										printf("%d ", print_link(octree1->linkT->link4->link3));
										printf("%d ", print_link(octree1->linkT->link4->link4));
										printf("%d ", print_link(octree1->linkT->link4->link5));
										printf("%d ", print_link(octree1->linkT->link4->link6));
										printf("%d ", print_link(octree1->linkT->link4->link7));
									}
									printf("%d ", print_link(octree1->linkT->link5));
									if (octree1->linkT->link5 != NULL) {
										printf("%d ", print_link(octree1->linkT->link5->link0));
										printf("%d ", print_link(octree1->linkT->link5->link1));
										printf("%d ", print_link(octree1->linkT->link5->link2));
										printf("%d ", print_link(octree1->linkT->link5->link3));
										printf("%d ", print_link(octree1->linkT->link5->link4));
										printf("%d ", print_link(octree1->linkT->link5->link5));
										printf("%d ", print_link(octree1->linkT->link5->link6));
										printf("%d ", print_link(octree1->linkT->link5->link7));
									}
									printf("%d ", print_link(octree1->linkT->link6));
									if (octree1->linkT->link6 != NULL) {
										printf("%d ", print_link(octree1->linkT->link6->link0));
										printf("%d ", print_link(octree1->linkT->link6->link1));
										printf("%d ", print_link(octree1->linkT->link6->link2));
										printf("%d ", print_link(octree1->linkT->link6->link3));
										printf("%d ", print_link(octree1->linkT->link6->link4));
										printf("%d ", print_link(octree1->linkT->link6->link5));
										printf("%d ", print_link(octree1->linkT->link6->link6));
										printf("%d ", print_link(octree1->linkT->link6->link7));
									}
									printf("%d ", print_link(octree1->linkT->link7));
									if (oc->linkT->link7 != NULL) {
										printf("%d ", print_link(octree1->linkT->link7->link0));
										printf("%d ", print_link(octree1->linkT->link7->link1));
										printf("%d ", print_link(octree1->linkT->link7->link2));
										printf("%d ", print_link(octree1->linkT->link7->link3));
										printf("%d ", print_link(octree1->linkT->link7->link4));
										printf("%d ", print_link(octree1->linkT->link7->link5));
										printf("%d ", print_link(octree1->linkT->link7->link6));
										printf("%d ", print_link(octree1->linkT->link7->link7));
									}
#endif
									

									//getchar();
									system("PAUSE");

								}



								//getchar();
							}
							else {
						if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
							// вырождение по Х
							// 0,3,4,7 
							// Эквивалентность : (0,1) (3,2) (4,5) (7,6)
							// Разбита на 8 равных частей:
							// 4,5,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkT = octree1->linkT->link0;
									break;
								case 5: octree1->linkT = octree1->linkT->link0;
									break;
								case 6: octree1->linkT = octree1->linkT->link3;
									break;
								case 7: octree1->linkT = octree1->linkT->link3;
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 4,7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkT = octree1->linkT->link3;
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//4,5
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:octree1->linkT = octree1->linkT->link0;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkT = octree1->linkT->link0;
									break;
								case 1: octree1->linkT = octree1->linkT->link0;
									break;
								case 2:octree1->linkT = octree1->linkT->link3;
									break;
								case 3:octree1->linkT = octree1->linkT->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkT = octree1->linkT->link0;
									break;
								case 1:octree1->linkT = octree1->linkT->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkT = octree1->linkT->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkT = octree1->linkT->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}


						}
						else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
							// вырождение по Y
							// 0,1,4,5 
							// (3->0),(2->1),(7->4), (6->5)
							// Разбита на 8 равных частей:
							// 4,5,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkT = octree1->linkT->link0;
									break;
								case 5: octree1->linkT = octree1->linkT->link1;
									break;
								case 6: octree1->linkT = octree1->linkT->link1;
									break;
								case 7: octree1->linkT = octree1->linkT->link0;
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 4,7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkT = octree1->linkT->link0;
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//4,5
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:octree1->linkT = octree1->linkT->link1;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkT = octree1->linkT->link0;
									break;
								case 1: octree1->linkT = octree1->linkT->link1;
									break;
								case 2:octree1->linkT = octree1->linkT->link1;
									break;
								case 3:octree1->linkT = octree1->linkT->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkT = octree1->linkT->link0;
									break;
								case 1:octree1->linkT = octree1->linkT->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkT = octree1->linkT->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkT = octree1->linkT->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
							// вырождение по Z
							// 0,1,2,3
							// (4->0) (5->1) (6->2) (7->3)
							// Разбита на 8 равных частей:
							// 4,5,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkT = octree1->linkT->link0;
									break;
								case 5: octree1->linkT = octree1->linkT->link1;
									break;
								case 6: octree1->linkT = octree1->linkT->link2;
									break;
								case 7: octree1->linkT = octree1->linkT->link3;
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 4,7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkT = octree1->linkT->link3;
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//4,5
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:octree1->linkT = octree1->linkT->link1;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkT = octree1->linkT->link0;
									break;
								case 1: octree1->linkT = octree1->linkT->link1;
									break;
								case 2:octree1->linkT = octree1->linkT->link2;
									break;
								case 3:octree1->linkT = octree1->linkT->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkT = octree1->linkT->link0;
									break;
								case 1:octree1->linkT = octree1->linkT->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkT = octree1->linkT->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkT = octree1->linkT->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
							// direction Z
							// 0,4
							// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
							// Разбита на 8 равных частей:
							// 4,5,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkT = octree1->linkT->link0;
									break;
								case 5: octree1->linkT = octree1->linkT->link0;
									break;
								case 6: octree1->linkT = octree1->linkT->link0;
									break;
								case 7: octree1->linkT = octree1->linkT->link0;
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 4,7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkT = octree1->linkT->link0;
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//4,5
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:octree1->linkT = octree1->linkT->link0;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkT = octree1->linkT->link0;
									break;
								case 1: octree1->linkT = octree1->linkT->link0;
									break;
								case 2:octree1->linkT = octree1->linkT->link0;
									break;
								case 3:octree1->linkT = octree1->linkT->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkT = octree1->linkT->link0;
									break;
								case 1:octree1->linkT = octree1->linkT->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkT = octree1->linkT->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkT = octree1->linkT->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
							// direction X
							// 0,1
							// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
							// Разбита на 8 равных частей:
							// 4,5,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkT = octree1->linkT->link0;
									break;
								case 5: octree1->linkT = octree1->linkT->link1;
									break;
								case 6: octree1->linkT = octree1->linkT->link1;
									break;
								case 7: octree1->linkT = octree1->linkT->link0;
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 4,7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkT = octree1->linkT->link0;
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//4,5
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:octree1->linkT = octree1->linkT->link1;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkT = octree1->linkT->link0;
									break;
								case 1: octree1->linkT = octree1->linkT->link1;
									break;
								case 2:octree1->linkT = octree1->linkT->link1;
									break;
								case 3:octree1->linkT = octree1->linkT->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkT = octree1->linkT->link0;
									break;
								case 1:octree1->linkT = octree1->linkT->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkT = octree1->linkT->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkT = octree1->linkT->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
							// direction Y
							// 0,3
							// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
							// Разбита на 8 равных частей:
							// 4,5,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkT = octree1->linkT->link0;
									break;
								case 5: octree1->linkT = octree1->linkT->link0;
									break;
								case 6: octree1->linkT = octree1->linkT->link3;
									break;
								case 7: octree1->linkT = octree1->linkT->link3;
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 4,7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkT = octree1->linkT->link3;
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//4,5
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:octree1->linkT = octree1->linkT->link0;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkT = octree1->linkT->link0;
									break;
								case 1: octree1->linkT = octree1->linkT->link0;
									break;
								case 2:octree1->linkT = octree1->linkT->link3;
									break;
								case 3:octree1->linkT = octree1->linkT->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkT = octree1->linkT->link0;
									break;
								case 1:octree1->linkT = octree1->linkT->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkT = octree1->linkT->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkT = octree1->linkT->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if (is_null1(octree1->linkT)) {
							// Разбита на 8 равных частей:
							// 4,5,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkT = octree1->linkT->link0;
									break;
								case 5: octree1->linkT = octree1->linkT->link1;
									break;
								case 6: octree1->linkT = octree1->linkT->link2;
									break;
								case 7: octree1->linkT = octree1->linkT->link3;
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 4,7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkT = octree1->linkT->link3;
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//4,5
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:octree1->linkT = octree1->linkT->link1;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkT = octree1->linkT->link0;
									break;
								case 1: octree1->linkT = octree1->linkT->link1;
									break;
								case 2:octree1->linkT = octree1->linkT->link2;
									break;
								case 3:octree1->linkT = octree1->linkT->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkT = octree1->linkT->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkT = octree1->linkT->link0;
									break;
								case 1:octree1->linkT = octree1->linkT->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkT = octree1->linkT->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkT = octree1->linkT->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

						}
						}
						}
						}
					}
					}

					// А другие случаи исключаются при додроблении.
					// одиночная связь, НЕ 4
					if (octree1->b4B == false) {
					if (octree1->linkB != NULL) {
						if (octree1->linkB->link0!=NULL) {
							if ((octree1->linkB->link1 == NULL) && (octree1->linkB->link2 == NULL) && (octree1->linkB->link3 == NULL) && (octree1->linkB->link4 == NULL) && (octree1->linkB->link5 == NULL) && (octree1->linkB->link6 == NULL) && (octree1->linkB->link7 == NULL)) {
								printf("error : octree1->linkB->link0!=NULL a na samom dele ==NULL\n");
								//getchar();
								system("PAUSE");
								exit(1);
							}

						// octree1 это лист.
						bool bSituationX = false;
						bool bSituationY = false;
						bool bSituationZ = false;

						if (bold_stable_version) {
							if (octree1->linkB->minx + 1 == octree1->linkB->maxx) {
								bSituationX = true;
							}
							if (octree1->linkB->miny + 1 == octree1->linkB->maxy) {
								bSituationY = true;
							}
							if (octree1->linkB->minz + 1 == octree1->linkB->maxz) {
								bSituationZ = true;
							}
							if ((octree1->linkB->link0 != NULL)) {
								if (bSituationX != octree1->linkB->link0->brootSituationX) {
									printf("error ne sovpadenie Situation X.");
								}
								if (bSituationY != octree1->linkB->link0->brootSituationY) {
									printf("error ne sovpadenie Situation Y.");
								}
								if (bSituationZ != octree1->linkB->link0->brootSituationZ) {
									printf("error ne sovpadenie Situation Z.");
								}
							}
						}
						else {
							// 4.01.2018 Попробуем так. Чисто на интуиции пока.
							// Здесь мы сохраняем запрет дробления в заданном координатном направлении.
							bSituationX = octree1->linkB->link0->brootSituationX;
							bSituationY = octree1->linkB->link0->brootSituationY;
							bSituationZ = octree1->linkB->link0->brootSituationZ;
						}


						
						// Чрезвычайно коварный случай. 7сентября 2016.
						bool bsitZ = false;
						if (((!bSituationZ) && (bSituationX) && (bSituationY))) bsitZ = true;


						//if ((!octree1->b_the_geometric_fragmentation) || (octree1->bcrushing_when_balancing)) {
						if ((octree1->ilevel==octree1->linkB->ilevel)||(bsitZ)) {
						    // Не дробленный лист контачит по грани E с дроблённым обектом.
							if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
								// вырождение по Х
								// 0,3,4,7 
								octree1->b4B = true;
								octree1->linkB0 = octree1->linkB->link4;
								octree1->linkB1 = NULL; 
								octree1->linkB2 = NULL; 
								octree1->linkB3 = octree1->linkB->link7;
								octree1->linkB = NULL;
							}
							else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
								// вырождение по Y
								// 0,1,4,5 
								octree1->b4B = true;
								octree1->linkB0 = octree1->linkB->link4;
								octree1->linkB1 = octree1->linkB->link5;
								octree1->linkB2 = NULL; 
								octree1->linkB3 = NULL;
								octree1->linkB = NULL;
							}
							else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
								// вырождение по Z
								// 0,1,2,3
								octree1->b4B = true;
								octree1->linkB0 = octree1->linkB->link0;
								octree1->linkB1 = octree1->linkB->link1;
								octree1->linkB2 = octree1->linkB->link2;
								octree1->linkB3 = octree1->linkB->link3;
								octree1->linkB = NULL;
							}
							else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
								// direction Z
								// 0,4
								octree1->b4B = true;
								octree1->linkB0 = octree1->linkB->link4;
								octree1->linkB1 = NULL; 
								octree1->linkB2 = NULL; 
								octree1->linkB3 = NULL; 
								// Редуцирование четырёх соседов к одному.
								octree1->b4B = false;
								octree1->linkB0 = NULL;
								octree1->linkB = octree1->linkB->link4;
							}
							else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
								// direction X
								// 0,1
								octree1->b4B = true;
								octree1->linkB0 = octree1->linkB->link0;
								octree1->linkB1 = octree1->linkB->link1;
								octree1->linkB2 = NULL; 
								octree1->linkB3 = NULL; 
								octree1->linkB = NULL;
							}
							else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
								// direction Y
								// 0,3
								octree1->b4B = true;
								octree1->linkB0 = octree1->linkB->link0;
								octree1->linkB1 = NULL; 
								octree1->linkB2 = NULL; 
								octree1->linkB3 = octree1->linkB->link3;
								octree1->linkB = NULL;
							}
							else if (is_null1(octree1->linkB)) {
								// Разбита на 8 равных частей:
								// 1,2,5,6
								octree1->b4B = true;
								octree1->linkB0 = octree1->linkB->link4;
								octree1->linkB1 = octree1->linkB->link5;
								octree1->linkB2 = octree1->linkB->link6;
								octree1->linkB3 = octree1->linkB->link7;
								octree1->linkB = NULL;
							}
						}
						else {
							if (octree1->ilevel - octree1->linkB->ilevel != 1) {
								
								if (is_null1_new(octree1->linkB)) {
									if (DEBUG_ALICE_MESH) {
										printf("linkB  is_null1_new. \n");
									}
									if (octree1->ilevel - octree1->linkB->ilevel ==2) {

										if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
											// вырождение по Х
											// 0,3,4,7 
											// Эквивалентность : (0,1) (3,2) (4,5) (7,6)
											// Разбита на 8 равных частей:
											// 0,1,2,3
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1: octree1->linkB = octree1->linkB->link4;
													break;
												case 2: octree1->linkB = octree1->linkB->link7;
													break;
												case 3: octree1->linkB = octree1->linkB->link7;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link7;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:octree1->linkB = octree1->linkB->link4;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1: octree1->linkB = octree1->linkB->link4;
													break;
												case 2:octree1->linkB = octree1->linkB->link7;
													break;
												case 3:octree1->linkB = octree1->linkB->link7;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:octree1->linkB = octree1->linkB->link4;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link7;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}


										}
										else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
											// вырождение по Y
											// 0,1,4,5 
											// (3->0),(2->1),(7->4), (6->5)
											// Разбита на 8 равных частей:
											// 0,1,2,3
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1: octree1->linkB = octree1->linkB->link5;
													break;
												case 2: octree1->linkB = octree1->linkB->link5;
													break;
												case 3: octree1->linkB = octree1->linkB->link4;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link4;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:octree1->linkB = octree1->linkB->link5;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1: octree1->linkB = octree1->linkB->link5;
													break;
												case 2:octree1->linkB = octree1->linkB->link5;
													break;
												case 3:octree1->linkB = octree1->linkB->link4;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:octree1->linkB = octree1->linkB->link5;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link4;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}


										}
										else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
											// вырождение по Z
											// 0,1,2,3
											// (4->0) (5->1) (6->2) (7->3)
											// Разбита на 8 равных частей:
											// 0,1,2,3
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link0;
													break;
												case 1: octree1->linkB = octree1->linkB->link1;
													break;
												case 2: octree1->linkB = octree1->linkB->link2;
													break;
												case 3: octree1->linkB = octree1->linkB->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:octree1->linkB = octree1->linkB->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link0;
													break;
												case 1: octree1->linkB = octree1->linkB->link1;
													break;
												case 2:octree1->linkB = octree1->linkB->link2;
													break;
												case 3:octree1->linkB = octree1->linkB->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:octree1->linkB = octree1->linkB->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
										else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
											// direction Z
											// 0,4
											// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
											// Разбита на 8 равных частей:
											// 0,1,2,3
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1: octree1->linkB = octree1->linkB->link4;
													break;
												case 2: octree1->linkB = octree1->linkB->link4;
													break;
												case 3: octree1->linkB = octree1->linkB->link4;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link4;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:octree1->linkB = octree1->linkB->link4;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1: octree1->linkB = octree1->linkB->link4;
													break;
												case 2:octree1->linkB = octree1->linkB->link4;
													break;
												case 3:octree1->linkB = octree1->linkB->link4;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:octree1->linkB = octree1->linkB->link4;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link4;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
											// direction X
											// 0,1
											// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
											// Разбита на 8 равных частей:
											// 0,1,2,3
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link0;
													break;
												case 1: octree1->linkB = octree1->linkB->link1;
													break;
												case 2: octree1->linkB = octree1->linkB->link1;
													break;
												case 3: octree1->linkB = octree1->linkB->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:octree1->linkB = octree1->linkB->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link0;
													break;
												case 1: octree1->linkB = octree1->linkB->link1;
													break;
												case 2:octree1->linkB = octree1->linkB->link1;
													break;
												case 3:octree1->linkB = octree1->linkB->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:octree1->linkB = octree1->linkB->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
										else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
											// direction Y
											// 0,3
											// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
											// Разбита на 8 равных частей:
											// 0,1,2,3
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link0;
													break;
												case 1: octree1->linkB = octree1->linkB->link0;
													break;
												case 2: octree1->linkB = octree1->linkB->link3;
													break;
												case 3: octree1->linkB = octree1->linkB->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:octree1->linkB = octree1->linkB->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link0;
													break;
												case 1: octree1->linkB = octree1->linkB->link0;
													break;
												case 2:octree1->linkB = octree1->linkB->link3;
													break;
												case 3:octree1->linkB = octree1->linkB->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:octree1->linkB = octree1->linkB->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if (is_null1(octree1->linkB)) {
											// Разбита на 8 равных частей:
											// 0,1,2,3
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1: octree1->linkB = octree1->linkB->link5;
													break;
												case 2: octree1->linkB = octree1->linkB->link6;
													break;
												case 3: octree1->linkB = octree1->linkB->link7;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link7;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:octree1->linkB = octree1->linkB->link5;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1: octree1->linkB = octree1->linkB->link5;
													break;
												case 2:octree1->linkB = octree1->linkB->link6;
													break;
												case 3:octree1->linkB = octree1->linkB->link7;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:octree1->linkB = octree1->linkB->link5;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link7;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}

									}
									else {
										printf("Fatal error!!! B distance meshdu urovnqmi > 2\n");
										//getchar();
										system("PAUSE");
										//exit(1);
									}
								}
								else {
									printf("error : linkB nepravilnje urovni.\n");

									integer c0 = 0;
									integer c1 = 0;
									integer c2 = 0;
									integer c3 = 0;
									integer c4 = 0;
									integer c5 = 0;
									integer c6 = 0;
									integer c7 = 0;
									is_null3(octree1->linkB, BSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
#if doubleintprecision == 1
									printf("c0=%lld c1=%lld c2=%lld c3=%lld c4=%lld c5=%lld c6=%lld c7=%lld\n", c0, c1, c2, c3, c4, c5, c6, c7);
									printf("%lld ", print_link(octree1->linkB->link0));
									if (octree1->linkB->link0 != NULL) {
										printf("%lld ", print_link(octree1->linkB->link0->link0));
										printf("%lld ", print_link(octree1->linkB->link0->link1));
										printf("%lld ", print_link(octree1->linkB->link0->link2));
										printf("%lld ", print_link(octree1->linkB->link0->link3));
										printf("%lld ", print_link(octree1->linkB->link0->link4));
										printf("%lld ", print_link(octree1->linkB->link0->link5));
										printf("%lld ", print_link(octree1->linkB->link0->link6));
										printf("%lld ", print_link(octree1->linkB->link0->link7));
									}
									printf("%lld ", print_link(octree1->linkB->link1));
									if (octree1->linkB->link1 != NULL) {
										printf("%lld ", print_link(octree1->linkB->link1->link0));
										printf("%lld ", print_link(octree1->linkB->link1->link1));
										printf("%lld ", print_link(octree1->linkB->link1->link2));
										printf("%lld ", print_link(octree1->linkB->link1->link3));
										printf("%lld ", print_link(octree1->linkB->link1->link4));
										printf("%lld ", print_link(octree1->linkB->link1->link5));
										printf("%lld ", print_link(octree1->linkB->link1->link6));
										printf("%lld ", print_link(octree1->linkB->link1->link7));
									}
									printf("%lld ", print_link(octree1->linkB->link2));
									if (octree1->linkB->link2 != NULL) {
										printf("%lld ", print_link(octree1->linkB->link2->link0));
										printf("%lld ", print_link(octree1->linkB->link2->link1));
										printf("%lld ", print_link(octree1->linkB->link2->link2));
										printf("%lld ", print_link(octree1->linkB->link2->link3));
										printf("%lld ", print_link(octree1->linkB->link2->link4));
										printf("%lld ", print_link(octree1->linkB->link2->link5));
										printf("%lld ", print_link(octree1->linkB->link2->link6));
										printf("%lld ", print_link(octree1->linkB->link2->link7));
									}
									printf("%lld ", print_link(octree1->linkB->link3));
									if (octree1->linkB->link3 != NULL) {
										printf("%lld ", print_link(octree1->linkB->link3->link0));
										printf("%lld ", print_link(octree1->linkB->link3->link1));
										printf("%lld ", print_link(octree1->linkB->link3->link2));
										printf("%lld ", print_link(octree1->linkB->link3->link3));
										printf("%lld ", print_link(octree1->linkB->link3->link4));
										printf("%lld ", print_link(octree1->linkB->link3->link5));
										printf("%lld ", print_link(octree1->linkB->link3->link6));
										printf("%lld ", print_link(octree1->linkB->link3->link7));
									}
									printf("%lld ", print_link(octree1->linkB->link4));
									if (octree1->linkB->link4 != NULL) {
										printf("%lld ", print_link(octree1->linkB->link4->link0));
										printf("%lld ", print_link(octree1->linkB->link4->link1));
										printf("%lld ", print_link(octree1->linkB->link4->link2));
										printf("%lld ", print_link(octree1->linkB->link4->link3));
										printf("%lld ", print_link(octree1->linkB->link4->link4));
										printf("%lld ", print_link(octree1->linkB->link4->link5));
										printf("%lld ", print_link(octree1->linkB->link4->link6));
										printf("%lld ", print_link(octree1->linkB->link4->link7));
									}
									printf("%lld ", print_link(octree1->linkB->link5));
									if (octree1->linkB->link5 != NULL) {
										printf("%lld ", print_link(octree1->linkB->link5->link0));
										printf("%lld ", print_link(octree1->linkB->link5->link1));
										printf("%lld ", print_link(octree1->linkB->link5->link2));
										printf("%lld ", print_link(octree1->linkB->link5->link3));
										printf("%lld ", print_link(octree1->linkB->link5->link4));
										printf("%lld ", print_link(octree1->linkB->link5->link5));
										printf("%lld ", print_link(octree1->linkB->link5->link6));
										printf("%lld ", print_link(octree1->linkB->link5->link7));
									}
									printf("%lld ", print_link(octree1->linkB->link6));
									if (octree1->linkB->link6 != NULL) {
										printf("%lld ", print_link(octree1->linkB->link6->link0));
										printf("%lld ", print_link(octree1->linkB->link6->link1));
										printf("%lld ", print_link(octree1->linkB->link6->link2));
										printf("%lld ", print_link(octree1->linkB->link6->link3));
										printf("%lld ", print_link(octree1->linkB->link6->link4));
										printf("%lld ", print_link(octree1->linkB->link6->link5));
										printf("%lld ", print_link(octree1->linkB->link6->link6));
										printf("%lld ", print_link(octree1->linkB->link6->link7));
									}
									printf("%lld ", print_link(octree1->linkB->link7));
									if (oc->linkB->link7 != NULL) {
										printf("%lld ", print_link(octree1->linkB->link7->link0));
										printf("%lld ", print_link(octree1->linkB->link7->link1));
										printf("%lld ", print_link(octree1->linkB->link7->link2));
										printf("%lld ", print_link(octree1->linkB->link7->link3));
										printf("%lld ", print_link(octree1->linkB->link7->link4));
										printf("%lld ", print_link(octree1->linkB->link7->link5));
										printf("%lld ", print_link(octree1->linkB->link7->link6));
										printf("%lld ", print_link(octree1->linkB->link7->link7));
									}
#else
									printf("c0=%d c1=%d c2=%d c3=%d c4=%d c5=%d c6=%d c7=%d\n", c0, c1, c2, c3, c4, c5, c6, c7);
									printf("%d ", print_link(octree1->linkB->link0));
									if (octree1->linkB->link0 != NULL) {
										printf("%d ", print_link(octree1->linkB->link0->link0));
										printf("%d ", print_link(octree1->linkB->link0->link1));
										printf("%d ", print_link(octree1->linkB->link0->link2));
										printf("%d ", print_link(octree1->linkB->link0->link3));
										printf("%d ", print_link(octree1->linkB->link0->link4));
										printf("%d ", print_link(octree1->linkB->link0->link5));
										printf("%d ", print_link(octree1->linkB->link0->link6));
										printf("%d ", print_link(octree1->linkB->link0->link7));
									}
									printf("%d ", print_link(octree1->linkB->link1));
									if (octree1->linkB->link1 != NULL) {
										printf("%d ", print_link(octree1->linkB->link1->link0));
										printf("%d ", print_link(octree1->linkB->link1->link1));
										printf("%d ", print_link(octree1->linkB->link1->link2));
										printf("%d ", print_link(octree1->linkB->link1->link3));
										printf("%d ", print_link(octree1->linkB->link1->link4));
										printf("%d ", print_link(octree1->linkB->link1->link5));
										printf("%d ", print_link(octree1->linkB->link1->link6));
										printf("%d ", print_link(octree1->linkB->link1->link7));
									}
									printf("%d ", print_link(octree1->linkB->link2));
									if (octree1->linkB->link2 != NULL) {
										printf("%d ", print_link(octree1->linkB->link2->link0));
										printf("%d ", print_link(octree1->linkB->link2->link1));
										printf("%d ", print_link(octree1->linkB->link2->link2));
										printf("%d ", print_link(octree1->linkB->link2->link3));
										printf("%d ", print_link(octree1->linkB->link2->link4));
										printf("%d ", print_link(octree1->linkB->link2->link5));
										printf("%d ", print_link(octree1->linkB->link2->link6));
										printf("%d ", print_link(octree1->linkB->link2->link7));
									}
									printf("%d ", print_link(octree1->linkB->link3));
									if (octree1->linkB->link3 != NULL) {
										printf("%d ", print_link(octree1->linkB->link3->link0));
										printf("%d ", print_link(octree1->linkB->link3->link1));
										printf("%d ", print_link(octree1->linkB->link3->link2));
										printf("%d ", print_link(octree1->linkB->link3->link3));
										printf("%d ", print_link(octree1->linkB->link3->link4));
										printf("%d ", print_link(octree1->linkB->link3->link5));
										printf("%d ", print_link(octree1->linkB->link3->link6));
										printf("%d ", print_link(octree1->linkB->link3->link7));
									}
									printf("%d ", print_link(octree1->linkB->link4));
									if (octree1->linkB->link4 != NULL) {
										printf("%d ", print_link(octree1->linkB->link4->link0));
										printf("%d ", print_link(octree1->linkB->link4->link1));
										printf("%d ", print_link(octree1->linkB->link4->link2));
										printf("%d ", print_link(octree1->linkB->link4->link3));
										printf("%d ", print_link(octree1->linkB->link4->link4));
										printf("%d ", print_link(octree1->linkB->link4->link5));
										printf("%d ", print_link(octree1->linkB->link4->link6));
										printf("%d ", print_link(octree1->linkB->link4->link7));
									}
									printf("%d ", print_link(octree1->linkB->link5));
									if (octree1->linkB->link5 != NULL) {
										printf("%d ", print_link(octree1->linkB->link5->link0));
										printf("%d ", print_link(octree1->linkB->link5->link1));
										printf("%d ", print_link(octree1->linkB->link5->link2));
										printf("%d ", print_link(octree1->linkB->link5->link3));
										printf("%d ", print_link(octree1->linkB->link5->link4));
										printf("%d ", print_link(octree1->linkB->link5->link5));
										printf("%d ", print_link(octree1->linkB->link5->link6));
										printf("%d ", print_link(octree1->linkB->link5->link7));
									}
									printf("%d ", print_link(octree1->linkB->link6));
									if (octree1->linkB->link6 != NULL) {
										printf("%d ", print_link(octree1->linkB->link6->link0));
										printf("%d ", print_link(octree1->linkB->link6->link1));
										printf("%d ", print_link(octree1->linkB->link6->link2));
										printf("%d ", print_link(octree1->linkB->link6->link3));
										printf("%d ", print_link(octree1->linkB->link6->link4));
										printf("%d ", print_link(octree1->linkB->link6->link5));
										printf("%d ", print_link(octree1->linkB->link6->link6));
										printf("%d ", print_link(octree1->linkB->link6->link7));
									}
									printf("%d ", print_link(octree1->linkB->link7));
									if (oc->linkB->link7 != NULL) {
										printf("%d ", print_link(octree1->linkB->link7->link0));
										printf("%d ", print_link(octree1->linkB->link7->link1));
										printf("%d ", print_link(octree1->linkB->link7->link2));
										printf("%d ", print_link(octree1->linkB->link7->link3));
										printf("%d ", print_link(octree1->linkB->link7->link4));
										printf("%d ", print_link(octree1->linkB->link7->link5));
										printf("%d ", print_link(octree1->linkB->link7->link6));
										printf("%d ", print_link(octree1->linkB->link7->link7));
									}
#endif
									
									//getchar();
									system("PAUSE");
								}

								
							}
							else {
						if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
							// вырождение по Х
							// 0,3,4,7 
							// Эквивалентность : (0,1) (3,2) (4,5) (7,6)
							// Разбита на 8 равных частей:
							// 0,1,2,3
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1: octree1->linkB = octree1->linkB->link4;
									break;
								case 2: octree1->linkB = octree1->linkB->link7;
									break;
								case 3: octree1->linkB = octree1->linkB->link7;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link7;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:octree1->linkB = octree1->linkB->link4;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1: octree1->linkB = octree1->linkB->link4;
									break;
								case 2:octree1->linkB = octree1->linkB->link7;
									break;
								case 3:octree1->linkB = octree1->linkB->link7;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:octree1->linkB = octree1->linkB->link4;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link7;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}


						}
						else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
							// вырождение по Y
							// 0,1,4,5 
							// (3->0),(2->1),(7->4), (6->5)
							// Разбита на 8 равных частей:
							// 0,1,2,3
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1: octree1->linkB = octree1->linkB->link5;
									break;
								case 2: octree1->linkB = octree1->linkB->link5;
									break;
								case 3: octree1->linkB = octree1->linkB->link4;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link4;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:octree1->linkB = octree1->linkB->link5;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1: octree1->linkB = octree1->linkB->link5;
									break;
								case 2:octree1->linkB = octree1->linkB->link5;
									break;
								case 3:octree1->linkB = octree1->linkB->link4;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:octree1->linkB = octree1->linkB->link5;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link4;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}


						}
						else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
							// вырождение по Z
							// 0,1,2,3
							// (4->0) (5->1) (6->2) (7->3)
							// Разбита на 8 равных частей:
							// 0,1,2,3
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link0;
									break;
								case 1: octree1->linkB = octree1->linkB->link1;
									break;
								case 2: octree1->linkB = octree1->linkB->link2;
									break;
								case 3: octree1->linkB = octree1->linkB->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:octree1->linkB = octree1->linkB->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link0;
									break;
								case 1: octree1->linkB = octree1->linkB->link1;
									break;
								case 2:octree1->linkB = octree1->linkB->link2;
									break;
								case 3:octree1->linkB = octree1->linkB->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:octree1->linkB = octree1->linkB->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

						}
						else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
							// direction Z
							// 0,4
							// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
							// Разбита на 8 равных частей:
							// 0,1,2,3
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1: octree1->linkB = octree1->linkB->link4;
									break;
								case 2: octree1->linkB = octree1->linkB->link4;
									break;
								case 3: octree1->linkB = octree1->linkB->link4;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link4;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:octree1->linkB = octree1->linkB->link4;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1: octree1->linkB = octree1->linkB->link4;
									break;
								case 2:octree1->linkB = octree1->linkB->link4;
									break;
								case 3:octree1->linkB = octree1->linkB->link4;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:octree1->linkB = octree1->linkB->link4;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link4;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
							// direction X
							// 0,1
							// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
							// Разбита на 8 равных частей:
							// 0,1,2,3
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link0;
									break;
								case 1: octree1->linkB = octree1->linkB->link1;
									break;
								case 2: octree1->linkB = octree1->linkB->link1;
									break;
								case 3: octree1->linkB = octree1->linkB->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:octree1->linkB = octree1->linkB->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link0;
									break;
								case 1: octree1->linkB = octree1->linkB->link1;
									break;
								case 2:octree1->linkB = octree1->linkB->link1;
									break;
								case 3:octree1->linkB = octree1->linkB->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:octree1->linkB = octree1->linkB->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

						}
						else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
							// direction Y
							// 0,3
							// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
							// Разбита на 8 равных частей:
							// 0,1,2,3
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link0;
									break;
								case 1: octree1->linkB = octree1->linkB->link0;
									break;
								case 2: octree1->linkB = octree1->linkB->link3;
									break;
								case 3: octree1->linkB = octree1->linkB->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:octree1->linkB = octree1->linkB->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link0;
									break;
								case 1: octree1->linkB = octree1->linkB->link0;
									break;
								case 2:octree1->linkB = octree1->linkB->link3;
									break;
								case 3:octree1->linkB = octree1->linkB->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:octree1->linkB = octree1->linkB->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if (is_null1(octree1->linkB)) {
							// Разбита на 8 равных частей:
							// 0,1,2,3
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1: octree1->linkB = octree1->linkB->link5;
									break;
								case 2: octree1->linkB = octree1->linkB->link6;
									break;
								case 3: octree1->linkB = octree1->linkB->link7;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link7;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:octree1->linkB = octree1->linkB->link5;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1: octree1->linkB = octree1->linkB->link5;
									break;
								case 2:octree1->linkB = octree1->linkB->link6;
									break;
								case 3:octree1->linkB = octree1->linkB->link7;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:octree1->linkB = octree1->linkB->link5;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link7;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

						}
						}
						}
						}
					}
					}

					// НАДО ПРЕДУСМОТРЕТЬ ВЫРОЖДЕНИЯ 294 варианта!!!. TODO
					// Для этого нужно хранить вырождения родителя внутри листа (потомка).
					// вырождения сделаны 25 08 2016.

					// закончили работать.
					octree1 = NULL;
				//}
				//else {
					// Дробление  вызывается.
					//my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
					//top_ALICE_STACK--;
				//}

			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//getchar();
	}
} // update_link_neighbor



void balance_octTree2(octTree* &oc, doublereal* xpos, doublereal* ypos, doublereal* zpos, integer &iret, doublereal epsTool) {
	// Здесь необходимо сохранить сбалансированность построенного дерева.
	// Уровень дробления не более 2 (двойки).
	// Доразбивка или Балансировка.
	iret = 0;
	integer ikount_dir_X = 0;
	integer ikount_dir_Y = 0;
	integer ikount_dir_Z = 0;
	integer ikount_sit_X = 0;
	integer ikount_sit_Y = 0;
	integer ikount_sit_Z = 0;
	integer ikount_list = 0;
	bool bcont = true;
	//for (integer i_7 = 0; i_7 < 5000; i_7++) {
	//while (bcont) 
	{
		bcont = false;
		top_ALICE_STACK = 0;
		if (oc->link0 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
			top_ALICE_STACK++;
		}
		if (oc->link1 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
			top_ALICE_STACK++;
		}
		if (oc->link2 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
			top_ALICE_STACK++;
		}
		if (oc->link3 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
			top_ALICE_STACK++;
		}
		if (oc->link4 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
			top_ALICE_STACK++;
		}
		if (oc->link5 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
			top_ALICE_STACK++;
		}
		if (oc->link6 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
			top_ALICE_STACK++;
		}
		if (oc->link7 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
			top_ALICE_STACK++;
		}
		while (top_ALICE_STACK > 0) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
				if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {
					if (my_ALICE_STACK[top_ALICE_STACK - 1].link->b_the_geometric_fragmentation == false) {
						// Во избежании повторного дробления узла за раз.
						my_ALICE_STACK[top_ALICE_STACK - 1].link->b_the_geometric_fragmentation = true;
						ikount_list++;

						octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
						integer minx = my_ALICE_STACK[top_ALICE_STACK - 1].minx;
						integer maxx = my_ALICE_STACK[top_ALICE_STACK - 1].maxx;
						integer miny = my_ALICE_STACK[top_ALICE_STACK - 1].miny;
						integer maxy = my_ALICE_STACK[top_ALICE_STACK - 1].maxy;
						integer minz = my_ALICE_STACK[top_ALICE_STACK - 1].minz;
						integer maxz = my_ALICE_STACK[top_ALICE_STACK - 1].maxz;

						// Вырождение по Z.
						bool bSituationZ = false;
						// Вырождение по X.
						bool bSituationX = false;
						// Вырождение по Y.
						bool bSituationY = false;


						bool bonly_dir_X = false;
						bool bonly_dir_Y = false;
						bool bonly_dir_Z = false;
						
						if (minz + 1 == maxz) {

							// Вырождение по Z.
							bSituationZ = true;
						}
						if (minx + 1 == maxx) {

							// Вырождение по X.
							bSituationX = true;
						}
						if (miny + 1 == maxy) {

							// Вырождение по Y.
							bSituationY = true;
						}
						
						/*
						if (octree1->brootSituationX != bSituationX) {
							printf("error  bSituationX ne sovpalo.\n");
							getchar();
						}
						if (octree1->brootSituationY != bSituationY) {
							printf("error  bSituationY ne sovpalo.\n");
							getchar();
						}
						if (octree1->brootSituationZ != bSituationZ) {
							printf("error  bSituationZ ne sovpalo.\n");
							getchar();
						}
						*/
						//bSituationX = octree1->brootSituationX;
						//bSituationY = octree1->brootSituationY;
						//bSituationZ = octree1->brootSituationZ;

						if (bSituationX && (bSituationY) && (!bSituationZ)) {

							bonly_dir_Z = true;
						}
						if (bSituationX && (bSituationZ) && (!bSituationY)) {

							bonly_dir_Y = true;
						}
						if (bSituationY && (bSituationZ) && (!bSituationX)) {

							bonly_dir_X = true;
						}



						if (bonly_dir_Z) {
							if ((octree1->maxWsosed > 2) || (octree1->maxEsosed > 2) || (octree1->maxSsosed > 2) || (octree1->maxNsosed > 2)) {
								//printf("bonly_dir_Z\n");
								//getchar();
#if doubleintprecision == 1
								printf("%lld octree1->root=%lld Z\n", ikount_dir_Z++, octree1->root);
#else
								printf("%d octree1->root=%d Z\n", ikount_dir_Z++, octree1->root);
#endif
								
								// move STACK
								my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
								top_ALICE_STACK--;
								octree1->dlist = false; // он больше никак не лист (это важно).
								integer i_76 = top_ALICE_STACK;
								integer iret64 = 0;
								droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64, true, false, false, true);
								//i_76 = top_ALICE_STACK - i_76;
								if (iret64 != top_ALICE_STACK - i_76) {
#if doubleintprecision == 1
									printf("error bonly_dir_Z ! invariant deleniq ne proiden %lld %lld \n", iret64, top_ALICE_STACK - i_76);
#else
									printf("error bonly_dir_Z ! invariant deleniq ne proiden %d %d \n", iret64, top_ALICE_STACK - i_76);
#endif
									
									//getchar();
									system("PAUSE");
								}
								iret += top_ALICE_STACK - i_76;
								bcont = true;
								for (integer j_i = top_ALICE_STACK - 1; j_i >= i_76; j_i--) {
									my_ALICE_STACK[j_i].link = NULL;
								}
								top_ALICE_STACK = i_76;
								top_ALICE_STACK++;// компенсация.

							}
							octree1 = NULL;
							my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
							top_ALICE_STACK--;
						}
						else if (bonly_dir_X) {
							if ((octree1->maxBsosed > 2) || (octree1->maxTsosed > 2) || (octree1->maxSsosed > 2) || (octree1->maxNsosed > 2)) {
								//	printf("bonly_dir_X\n");
								//getchar();
								integer i_X = 0;
								integer i_Y = 0;
								integer i_Z = 0;
								if (octree1->brootSituationX) i_X = 1;
								if (octree1->brootSituationY) i_Y = 1;
								if (octree1->brootSituationZ) i_Z = 1;
#if doubleintprecision == 1
								printf("%lld octree1->root=%lld parent=%lld parent>parent=%lld bonly_dir_X  \n", ikount_dir_X++, octree1->root, octree1->parent->root, octree1->parent->parent->root);
								printf("sitx=%lld sity=%lld sitz=%lld S=%lld N=%lld B=%lld T=%lld E=%lld W=%lld linkW=%lld linkE=%lld linkS=%lld linkN=%lld linkB=%lld linkT=%lld\n", i_X, i_Y, i_Z, octree1->maxSsosed, octree1->maxNsosed, octree1->maxBsosed, octree1->maxTsosed, octree1->maxEsosed, octree1->maxWsosed, print_link(octree1->linkW), print_link(octree1->linkE), print_link(octree1->linkS), print_link(octree1->linkN), print_link(octree1->linkB), print_link(octree1->linkT));
#else
								printf("%d octree1->root=%d parent=%d parent>parent=%d bonly_dir_X  \n", ikount_dir_X++, octree1->root, octree1->parent->root, octree1->parent->parent->root);
								printf("sitx=%d sity=%d sitz=%d S=%d N=%d B=%d T=%d E=%d W=%d linkW=%d linkE=%d linkS=%d linkN=%d linkB=%d linkT=%d\n", i_X, i_Y, i_Z, octree1->maxSsosed, octree1->maxNsosed, octree1->maxBsosed, octree1->maxTsosed, octree1->maxEsosed, octree1->maxWsosed, print_link(octree1->linkW), print_link(octree1->linkE), print_link(octree1->linkS), print_link(octree1->linkN), print_link(octree1->linkB), print_link(octree1->linkT));
#endif
								i_X = 0;
								i_Y = 0;
								i_Z = 0;
								if (octree1->parent->brootSituationX) i_X = 1;
								if (octree1->parent->brootSituationY) i_Y = 1;
								if (octree1->parent->brootSituationZ) i_Z = 1;
#if doubleintprecision == 1
								printf("->parent sitx=%lld sity=%lld sitz=%lld  S=%lld N=%lld B=%lld T=%lld E=%lld W=%lld linkW=%lld linkE=%lld linkS=%lld linkN=%lld linkB=%lld linkT=%lld\n", i_X, i_Y, i_Z, octree1->parent->maxSsosed, octree1->parent->maxNsosed, octree1->parent->maxBsosed, octree1->parent->maxTsosed, octree1->parent->maxEsosed, octree1->parent->maxWsosed, print_link(octree1->parent->linkW), print_link(octree1->parent->linkE), print_link(octree1->parent->linkS), print_link(octree1->parent->linkN), print_link(octree1->parent->linkB), print_link(octree1->parent->linkT));
#else
								printf("->parent sitx=%d sity=%d sitz=%d  S=%d N=%d B=%d T=%d E=%d W=%d linkW=%d linkE=%d linkS=%d linkN=%d linkB=%d linkT=%d\n", i_X, i_Y, i_Z, octree1->parent->maxSsosed, octree1->parent->maxNsosed, octree1->parent->maxBsosed, octree1->parent->maxTsosed, octree1->parent->maxEsosed, octree1->parent->maxWsosed, print_link(octree1->parent->linkW), print_link(octree1->parent->linkE), print_link(octree1->parent->linkS), print_link(octree1->parent->linkN), print_link(octree1->parent->linkB), print_link(octree1->parent->linkT));
#endif
								i_X = 0;
								i_Y = 0;
								i_Z = 0;
								if (octree1->parent->parent->brootSituationX) i_X = 1;
								if (octree1->parent->parent->brootSituationY) i_Y = 1;
								if (octree1->parent->parent->brootSituationZ) i_Z = 1;
#if doubleintprecision == 1
								printf("->parent->parent sitx=%lld sity=%lld sitz=%lld  S=%lld N=%lld B=%lld T=%lld E=%lld W=%lld linkW=%lld linkE=%lld linkS=%lld linkN=%lld linkB=%lld linkT=%lld\n", i_X, i_Y, i_Z, octree1->parent->parent->maxSsosed, octree1->parent->parent->maxNsosed, octree1->parent->parent->maxBsosed, octree1->parent->parent->maxTsosed, octree1->parent->parent->maxEsosed, octree1->parent->parent->maxWsosed, print_link(octree1->parent->parent->linkW), print_link(octree1->parent->parent->linkE), print_link(octree1->parent->parent->linkS), print_link(octree1->parent->parent->linkN), print_link(octree1->parent->parent->linkB), print_link(octree1->parent->parent->linkT));
#else
								printf("->parent->parent sitx=%d sity=%d sitz=%d  S=%d N=%d B=%d T=%d E=%d W=%d linkW=%d linkE=%d linkS=%d linkN=%d linkB=%d linkT=%d\n", i_X, i_Y, i_Z, octree1->parent->parent->maxSsosed, octree1->parent->parent->maxNsosed, octree1->parent->parent->maxBsosed, octree1->parent->parent->maxTsosed, octree1->parent->parent->maxEsosed, octree1->parent->parent->maxWsosed, print_link(octree1->parent->parent->linkW), print_link(octree1->parent->parent->linkE), print_link(octree1->parent->parent->linkS), print_link(octree1->parent->parent->linkN), print_link(octree1->parent->parent->linkB), print_link(octree1->parent->parent->linkT));
#endif
								

								if (1) {
								if (octree1->b4B) {
								printf("b4B = true ");
								}
								else {
								printf("b4B=false  ");
								}
								if (octree1->b4T) {
								printf("b4T = true ");
								}
								else {
								printf("b4T=false  ");
								}
								if (octree1->b4E) {
								printf("b4E = true ");
								}
								else {
								printf("b4E=false  ");
								}
								if (octree1->b4W) {
								printf("b4W = true ");
								}
								else {
								printf("b4W = false ");
								}
								if (octree1->b4S) {
								printf("b4S = true ");
								}
								else {
								printf("b4S=false  ");
								}
								if (octree1->b4N) {
								printf("b4N = true ");
								}
								else {
								printf("b4N=false  ");
								}
								printf("\n");
								if (octree1->parent->b4B) {
								printf("b4B = true ");
								}
								else {
								printf("b4B=false  ");
								}
								if (octree1->parent->b4T) {
								printf("b4T = true ");
								}
								else {
								printf("b4T=false  ");
								}
								if (octree1->parent->b4E) {
								printf("b4E = true ");
								}
								else {
								printf("b4E=false  ");
								}
								if (octree1->parent->b4W) {
								printf("b4W = true ");
								}
								else {
								printf("b4W = false ");
								}
								if (octree1->parent->b4S) {
								printf("b4S = true ");
								}
								else {
								printf("b4S=false  ");
								}
								if (octree1->parent->b4N) {
								printf("b4N = true ");
								}
								else {
								printf("b4N=false  ");
								}
								printf("\n");
								if (octree1->parent->parent->b4B) {
								printf("b4B = true ");
								}
								else {
								printf("b4B=false  ");
								}
								if (octree1->parent->parent->b4T) {
								printf("b4T = true ");
								}
								else {
								printf("b4T=false  ");
								}
								if (octree1->parent->parent->b4E) {
								printf("b4E = true ");
								}
								else {
								printf("b4E=false  ");
								}
								if (octree1->parent->parent->b4W) {
								printf("b4W = true ");
								}
								else {
								printf("b4W = false ");
								}
								if (octree1->parent->parent->b4S) {
								printf("b4S = true ");
								}
								else {
								printf("b4S=false  ");
								}
								if (octree1->parent->parent->b4N) {
								printf("b4N = true ");
								}
								else {
								printf("b4N=false  ");
								}
								printf("\n");

								log_cs(octree1);

								}
								// move STACK
								my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
								top_ALICE_STACK--;
								octree1->dlist = false; // он больше никак не лист (это важно).
								integer i_76 = top_ALICE_STACK;
								integer iret64 = 0;
								droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64, true, true, false, false);
								//i_76 = top_ALICE_STACK - i_76;
								if (iret64 != top_ALICE_STACK - i_76) {
#if doubleintprecision == 1
									printf("error bonly_dir_X ! invariant deleniq ne proiden %lld %lld \n", iret64, top_ALICE_STACK - i_76);
#else
									printf("error bonly_dir_X ! invariant deleniq ne proiden %d %d \n", iret64, top_ALICE_STACK - i_76);
#endif
									
									//getchar();
									system("PAUSE");
								}
								iret += top_ALICE_STACK - i_76;
								bcont = true;
								for (integer j_i = top_ALICE_STACK - 1; j_i >= i_76; j_i--) {
									my_ALICE_STACK[j_i].link = NULL;
								}
								top_ALICE_STACK = i_76;
								top_ALICE_STACK++;// компенсация.

							}
							octree1 = NULL;
							my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
							top_ALICE_STACK--;
						}
						else if (bonly_dir_Y) {
							if ((octree1->maxWsosed > 2) || (octree1->maxEsosed > 2) || (octree1->maxBsosed > 2) || (octree1->maxTsosed > 2)) {
								//printf("bonly_dir_Y\n");
								//getchar();
#if doubleintprecision == 1
								printf("%lld octree1->root=%lld Y\n", ikount_dir_Y++, octree1->root);
#else
								printf("%d octree1->root=%d Y\n", ikount_dir_Y++, octree1->root);
#endif
								
								// move STACK
								my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
								top_ALICE_STACK--;
								octree1->dlist = false; // он больше никак не лист (это важно).
								integer i_76 = top_ALICE_STACK;
								integer iret64 = 0;
								droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64, true, false, true, false);
								//i_76 = top_ALICE_STACK - i_76;
								if (iret64 != top_ALICE_STACK - i_76) {
#if doubleintprecision == 1
									printf("error bonly_dir_Y ! invariant deleniq ne proiden %lld %lld \n", iret64, top_ALICE_STACK - i_76);
#else
									printf("error bonly_dir_Y ! invariant deleniq ne proiden %d %d \n", iret64, top_ALICE_STACK - i_76);
#endif
									
									//getchar();
									system("PAUSE");
								}
								iret += top_ALICE_STACK - i_76;
								bcont = true;
								for (integer j_i = top_ALICE_STACK - 1; j_i >= i_76; j_i--) {
									my_ALICE_STACK[j_i].link = NULL;
								}
								top_ALICE_STACK = i_76;
								top_ALICE_STACK++;// компенсация.

							}
							octree1 = NULL;
							my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
							top_ALICE_STACK--;
						}
						else if (bSituationZ && (!bSituationX) && (!bSituationY)) {
							if ((octree1->maxWsosed > 2) || (octree1->maxEsosed > 2) || (octree1->maxSsosed > 2) || (octree1->maxNsosed > 2) || (octree1->maxBsosed > 4) || (octree1->maxTsosed > 4)) {
								//printf("bSituationZ\n");
								//getchar();
#if doubleintprecision == 1
								printf("%lld octree1->root=%lld Situation Z\n", ikount_sit_Z++, octree1->root);
#else
								printf("%d octree1->root=%d Situation Z\n", ikount_sit_Z++, octree1->root);
#endif
								
								// move STACK
								my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
								top_ALICE_STACK--;
								octree1->dlist = false; // он больше никак не лист (это важно).
								integer i_76 = top_ALICE_STACK;
								integer iret64 = 0;
								droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64, true, true, true, false);
								//i_76 = top_ALICE_STACK - i_76;
								if (iret64 != top_ALICE_STACK - i_76) {
#if doubleintprecision == 1
									printf("error bSituationZ ! invariant deleniq ne proiden %lld %lld \n", iret64, top_ALICE_STACK - i_76);
#else
									printf("error bSituationZ ! invariant deleniq ne proiden %d %d \n", iret64, top_ALICE_STACK - i_76);
#endif
									
									//getchar();
									system("PAUSE");
								}

								/*if (iret64 == 0) {
								octree1->dlist = true;
								my_ALICE_STACK[top_ALICE_STACK].link = octree1;
								my_ALICE_STACK[top_ALICE_STACK].minx = minx;
								my_ALICE_STACK[top_ALICE_STACK ].maxx=maxx;
								my_ALICE_STACK[top_ALICE_STACK ].miny=miny;
								my_ALICE_STACK[top_ALICE_STACK ].maxy=maxy;
								my_ALICE_STACK[top_ALICE_STACK ].minz=minz;
								my_ALICE_STACK[top_ALICE_STACK ].maxz=maxz;
								top_ALICE_STACK++;
								}
								else {
								*/
								iret += top_ALICE_STACK - i_76;
								//}

								bcont = true;
								for (integer j_i = top_ALICE_STACK - 1; j_i >= i_76; j_i--) {
									my_ALICE_STACK[j_i].link = NULL;
								}
								top_ALICE_STACK = i_76;
								top_ALICE_STACK++;// компенсация.

							}
							octree1 = NULL;
							my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
							top_ALICE_STACK--;
						}
						else if (bSituationY && (!bSituationX) && (!bSituationZ)) {
							if ((octree1->maxWsosed > 2) || (octree1->maxEsosed > 2) || (octree1->maxBsosed > 2) || (octree1->maxTsosed > 2) || (octree1->maxNsosed > 4) || (octree1->maxSsosed > 4)) {
#if doubleintprecision == 1
								//	printf("bSituationY: W =%lld E=%lld B=%lld T=%lld\n", octree1->maxWsosed, octree1->maxEsosed, octree1->maxBsosed, octree1->maxTsosed);
#else
								//	printf("bSituationY: W =%d E=%d B=%d T=%d\n", octree1->maxWsosed, octree1->maxEsosed, octree1->maxBsosed, octree1->maxTsosed);
#endif
								//getchar();
								// move STACK
#if doubleintprecision == 1
								printf("%lld octree1->root=%lld SituationY W=%lld E=%lld B=%lld T=%lld N=%lld S=%lld octree1->parent->root=%lld %lld\n", ikount_sit_Y++, octree1->root, octree1->maxWsosed, octree1->maxEsosed, octree1->maxBsosed, octree1->maxTsosed, octree1->maxNsosed, octree1->maxSsosed, octree1->parent->root, octree1->parent->parent->root);
#else
								printf("%d octree1->root=%d SituationY W=%d E=%d B=%d T=%d N=%d S=%d octree1->parent->root=%d %d\n", ikount_sit_Y++, octree1->root, octree1->maxWsosed, octree1->maxEsosed, octree1->maxBsosed, octree1->maxTsosed, octree1->maxNsosed, octree1->maxSsosed, octree1->parent->root, octree1->parent->parent->root);
#endif
								my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
								top_ALICE_STACK--;
								octree1->dlist = false; // он больше никак не лист (это важно).
								integer i_76 = top_ALICE_STACK;
								integer iret64 = 0;
								droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64, true, true, false, true);
								//i_76 = top_ALICE_STACK - i_76;
								if (iret64 != top_ALICE_STACK - i_76) {
#if doubleintprecision == 1
									printf("error bSituationY ! invariant deleniq ne proiden %lld %lld \n", iret64, top_ALICE_STACK - i_76);
#else
									printf("error bSituationY ! invariant deleniq ne proiden %d %d \n", iret64, top_ALICE_STACK - i_76);
#endif
									
									//getchar();
									system("PAUSE");
								}

								/*if (iret64 == 0) {
								octree1->dlist = true;
								my_ALICE_STACK[top_ALICE_STACK].link = octree1;
								my_ALICE_STACK[top_ALICE_STACK].minx = minx;
								my_ALICE_STACK[top_ALICE_STACK].maxx = maxx;
								my_ALICE_STACK[top_ALICE_STACK].miny = miny;
								my_ALICE_STACK[top_ALICE_STACK].maxy = maxy;
								my_ALICE_STACK[top_ALICE_STACK].minz = minz;
								my_ALICE_STACK[top_ALICE_STACK].maxz = maxz;
								top_ALICE_STACK++;
								}
								else {
								*/
								iret += top_ALICE_STACK - i_76;
								//}

								bcont = true;
								for (integer j_i = top_ALICE_STACK - 1; j_i >= i_76; j_i--) {
									my_ALICE_STACK[j_i].link = NULL;
								}
								top_ALICE_STACK = i_76;
								top_ALICE_STACK++;// компенсация.

							}
							octree1 = NULL;
							my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
							top_ALICE_STACK--;
						}
						else if (bSituationX && (!bSituationZ) && (!bSituationY)) {
							if ((octree1->maxSsosed > 2) || (octree1->maxNsosed > 2) || (octree1->maxBsosed > 2) || (octree1->maxTsosed > 2) || (octree1->maxWsosed > 4) || (octree1->maxEsosed > 4)) {
								//printf("bSituationX\n");
								//getchar();
								// move STACK
#if doubleintprecision == 1
								printf("%lld octree1->root=%lld Situation X\n", ikount_sit_X++, octree1->root);
#else
								printf("%d octree1->root=%d Situation X\n", ikount_sit_X++, octree1->root);
#endif
								
								my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
								top_ALICE_STACK--;
								octree1->dlist = false; // он больше никак не лист (это важно).
								integer i_76 = top_ALICE_STACK;
								integer iret64 = 0;
								droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64, true, false, true, true);
								//i_76 = top_ALICE_STACK - i_76;
								if (iret64 != top_ALICE_STACK - i_76) {
#if doubleintprecision == 1
									printf("error bSituationX ! invariant deleniq ne proiden %lld %lld \n", iret64, top_ALICE_STACK - i_76);
#else
									printf("error bSituationX ! invariant deleniq ne proiden %d %d \n", iret64, top_ALICE_STACK - i_76);
#endif
									
									//getchar();
									system("PAUSE");
								}
								/*if (iret64 == 0) {
								octree1->dlist = true;
								my_ALICE_STACK[top_ALICE_STACK].link = octree1;
								my_ALICE_STACK[top_ALICE_STACK].minx = minx;
								my_ALICE_STACK[top_ALICE_STACK].maxx = maxx;
								my_ALICE_STACK[top_ALICE_STACK].miny = miny;
								my_ALICE_STACK[top_ALICE_STACK].maxy = maxy;
								my_ALICE_STACK[top_ALICE_STACK].minz = minz;
								my_ALICE_STACK[top_ALICE_STACK].maxz = maxz;
								top_ALICE_STACK++;
								}
								else {*/
								iret += top_ALICE_STACK - i_76;
								//}

								bcont = true;
								for (integer j_i = top_ALICE_STACK - 1; j_i >= i_76; j_i--) {
									my_ALICE_STACK[j_i].link = NULL;
								}
								top_ALICE_STACK = i_76;
								top_ALICE_STACK++;// компенсация.

							}
							octree1 = NULL;
							my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
							top_ALICE_STACK--;
						}
						else if ((octree1->maxBsosed > 4) || (octree1->maxTsosed > 4) || (octree1->maxWsosed > 4) || (octree1->maxEsosed > 4) || (octree1->maxSsosed > 4) || (octree1->maxNsosed > 4)) {

							// разбиение на 8.

							if ((minx + 1 == maxx) && (miny + 1 == maxy) && (minz + 1 == maxz)) {
								printf("fatal error : atomarnaq\n");
#if doubleintprecision == 1
								printf("root=%lld\n", octree1->root);
								printf("W=%lld E=%lld S=%lld N=%lld B=%lld T=%lld\n", octree1->maxWsosed, octree1->maxEsosed, octree1->maxSsosed, octree1->maxNsosed, octree1->maxBsosed, octree1->maxTsosed);
#else
								printf("root=%d\n", octree1->root);
								printf("W=%d E=%d S=%d N=%d B=%d T=%d\n", octree1->maxWsosed, octree1->maxEsosed, octree1->maxSsosed, octree1->maxNsosed, octree1->maxBsosed, octree1->maxTsosed);
#endif
								integer i_X = 0;
								integer i_Y = 0;
								integer i_Z = 0;
								if (octree1->brootSituationX) {
									i_X = 1;
								}
								else {
									i_X = 0;
								}
								if (octree1->brootSituationY) {
									i_Y = 1;
								}
								else {
									i_Y = 0;
								}
								if (octree1->brootSituationZ) {
									i_Z = 1;
								}
								else {
									i_Z = 0;
								}
#if doubleintprecision == 1
								printf("bSituationX=%lld bSituationY=%lld bSituationZ=%lld\n", i_X, i_Y, i_Z);
#else
								printf("bSituationX=%d bSituationY=%d bSituationZ=%d\n", i_X, i_Y, i_Z);
#endif
								
								if (octree1->parent != NULL) {
#if doubleintprecision == 1
									printf("parent->root=%lld\n", octree1->parent->root);
									printf("W=%lld E=%lld S=%lld N=%lld B=%lld T=%lld\n", octree1->parent->maxWsosed, octree1->parent->maxEsosed, octree1->parent->maxSsosed, octree1->parent->maxNsosed, octree1->parent->maxBsosed, octree1->parent->maxTsosed);
#else
									printf("parent->root=%d\n", octree1->parent->root);
									printf("W=%d E=%d S=%d N=%d B=%d T=%d\n", octree1->parent->maxWsosed, octree1->parent->maxEsosed, octree1->parent->maxSsosed, octree1->parent->maxNsosed, octree1->parent->maxBsosed, octree1->parent->maxTsosed);
#endif
									if (octree1->parent->brootSituationX) {
										i_X = 1;
									}
									else {
										i_X = 0;
									}
									if (octree1->parent->brootSituationY) {
										i_Y = 1;
									}
									else {
										i_Y = 0;
									}
									if (octree1->parent->brootSituationZ) {
										i_Z = 1;
									}
									else {
										i_Z = 0;
									}
#if doubleintprecision == 1
									printf("bSituationX=%lld bSituationY=%lld bSituationZ=%lld\n", i_X, i_Y, i_Z);
#else
									printf("bSituationX=%d bSituationY=%d bSituationZ=%d\n", i_X, i_Y, i_Z);
#endif
									
									if (octree1->parent->parent != NULL) {
#if doubleintprecision == 1
										printf("parent->parent->root=%lld\n", octree1->parent->parent->root);
										printf("W=%lld E=%lld S=%lld N=%lld B=%lld T=%lld\n", octree1->parent->parent->maxWsosed, octree1->parent->parent->maxEsosed, octree1->parent->parent->maxSsosed, octree1->parent->parent->maxNsosed, octree1->parent->parent->maxBsosed, octree1->parent->parent->maxTsosed);
#else
										printf("parent->parent->root=%d\n", octree1->parent->parent->root);
										printf("W=%d E=%d S=%d N=%d B=%d T=%d\n", octree1->parent->parent->maxWsosed, octree1->parent->parent->maxEsosed, octree1->parent->parent->maxSsosed, octree1->parent->parent->maxNsosed, octree1->parent->parent->maxBsosed, octree1->parent->parent->maxTsosed);
#endif
										if (octree1->parent->parent->brootSituationX) {
											i_X = 1;
										}
										else {
											i_X = 0;
										}
										if (octree1->parent->parent->brootSituationY) {
											i_Y = 1;
										}
										else {
											i_Y = 0;
										}
										if (octree1->parent->parent->brootSituationZ) {
											i_Z = 1;
										}
										else {
											i_Z = 0;
										}
#if doubleintprecision == 1
										printf("bSituationX=%lld bSituationY=%lld bSituationZ=%lld\n", i_X, i_Y, i_Z);
#else
										printf("bSituationX=%d bSituationY=%d bSituationZ=%d\n", i_X, i_Y, i_Z);
#endif
										
										if (octree1->parent->parent->parent != NULL) {
#if doubleintprecision == 1
											printf("parent->parent->parent->root=%lld\n", octree1->parent->parent->parent->root);
											printf("W=%lld E=%lld S=%lld N=%lld B=%lld T=%lld\n", octree1->parent->parent->parent->maxWsosed, octree1->parent->parent->parent->maxEsosed, octree1->parent->parent->parent->maxSsosed, octree1->parent->parent->parent->maxNsosed, octree1->parent->parent->parent->maxBsosed, octree1->parent->parent->parent->maxTsosed);
#else
											printf("parent->parent->parent->root=%d\n", octree1->parent->parent->parent->root);
											printf("W=%d E=%d S=%d N=%d B=%d T=%d\n", octree1->parent->parent->parent->maxWsosed, octree1->parent->parent->parent->maxEsosed, octree1->parent->parent->parent->maxSsosed, octree1->parent->parent->parent->maxNsosed, octree1->parent->parent->parent->maxBsosed, octree1->parent->parent->parent->maxTsosed);
#endif
											if (octree1->parent->parent->parent->brootSituationX) {
												i_X = 1;
											}
											else {
												i_X = 0;
											}
											if (octree1->parent->parent->parent->brootSituationY) {
												i_Y = 1;
											}
											else {
												i_Y = 0;
											}
											if (octree1->parent->parent->parent->brootSituationZ) {
												i_Z = 1;
											}
											else {
												i_Z = 0;
											}
#if doubleintprecision == 1
											printf("bSituationX=%lld bSituationY=%lld bSituationZ=%lld\n", i_X, i_Y, i_Z);
#else
											printf("bSituationX=%d bSituationY=%d bSituationZ=%d\n", i_X, i_Y, i_Z);
#endif
											
										}
									}
								}
								//getchar();
								system("PAUSE");
								// Это атомарная ячейка и она не может быть раздроблена.
								// Количество соседей атомарной ячейки по определению 1. 
								// Или даже ноль если соответсвующая связь NULL.
								if (octree1->linkB == NULL) {
									octree1->maxBsosed = 0;
								}
								else {
									octree1->maxBsosed = 1;
								}
								if (octree1->linkT == NULL) {
									octree1->maxTsosed = 0;
								}
								else {
									octree1->maxTsosed = 1;
								}

								if (octree1->linkS == NULL) {
									octree1->maxSsosed = 0;
								}
								else {
									octree1->maxSsosed = 1;
								}
								if (octree1->linkN == NULL) {
									octree1->maxNsosed = 0;
								}
								else {
									octree1->maxNsosed = 1;
								}
								if (octree1->linkW == NULL) {
									octree1->maxWsosed = 0;
								}
								else {
									octree1->maxWsosed = 1;
								}
								if (octree1->linkE == NULL) {
									octree1->maxEsosed = 0;
								}
								else {
									octree1->maxEsosed = 1;
								}

								printf("atomarnaq\n");
								//getchar();
								// Дробление не вызывается.
								my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;

							}
							else {
								// move STACK
								my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
								top_ALICE_STACK--;
								octree1->dlist = false; // он больше никак не лист (это важно).
								integer i_76 = top_ALICE_STACK;
								integer iret64 = 0;
								printf("balance octrree 2 droblenie_internal incomming\n");
								getchar();
								droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64, true, true, true, true);
								//i_76 = top_ALICE_STACK - i_76;
								if (iret64 != top_ALICE_STACK - i_76) {
#if doubleintprecision == 1
									printf("error ! invariant deleniq ne proiden %lld %lld \n", iret64, top_ALICE_STACK - i_76);
#else
									printf("error ! invariant deleniq ne proiden %d %d \n", iret64, top_ALICE_STACK - i_76);
#endif
									
									//getchar();
									system("PAUSE");
								}
								iret += top_ALICE_STACK - i_76;
#if doubleintprecision == 1
								//printf("i_76=%lld\n", top_ALICE_STACK - i_76);
#else
								//printf("i_76=%d\n", top_ALICE_STACK - i_76);
#endif
								
								//bool b54 = true;
								//for (integer i_74 = i_76; i_74 < top_ALICE_STACK; i_74++) {
								//if (my_ALICE_STACK[i_74].link->dlist == true) {
								//	printf("true\n");
								//}
								//else {
								//printf("false\n");
								//	}
								//}
								//getchar();
								bcont = true;
								for (integer j_i = top_ALICE_STACK - 1; j_i >= i_76; j_i--) {
									my_ALICE_STACK[j_i].link = NULL;
								}
								top_ALICE_STACK = i_76;
								//top_ALICE_STACK -= i_76;
								top_ALICE_STACK++;// компенсация.
							}
							octree1 = NULL;
							my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
							top_ALICE_STACK--;
							octree1 = NULL;
						}
					}
					else {
						//обычный лист который ненадо дробить.
						my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
						top_ALICE_STACK--;
					}
					

				}
				else {
					// продолжаем добираться до листьев.
					STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
					STACK_ALICE* buf = &buf1;
					top_ALICE_STACK--;
					if (buf->link->link0 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link1 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link2 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link3 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link4 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link5 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link6 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link7 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
						top_ALICE_STACK++;
					}
				}
			}
		}
#if doubleintprecision == 1
		printf("all number of lists=%lld\t", ikount_list);
#else
		printf("all number of lists=%d\t", ikount_list);
#endif
		
		if (DEBUG_ALICE_MESH) {
			//getchar();
			system("PAUSE");
		}

	}
} // balance_octTree2

void droblenie_disbalance(octTree* &oc, doublereal* xpos, doublereal* ypos, doublereal* zpos, integer &iret) {
	// Здесь необходимо сохранить сбалансированность построенного дерева.
	// Уровень дробления не более 2 (двойки).
	// Доразбивка или Балансировка.
	iret = 0;
	
	integer ikount_list = 0;
	bool bcont = true;
	//for (integer i_7 = 0; i_7 < 5000; i_7++) {
	//while (bcont) 
	{
		bcont = false;
		top_ALICE_STACK = 0;
		if (oc->link0 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
			top_ALICE_STACK++;
		}
		if (oc->link1 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
			top_ALICE_STACK++;
		}
		if (oc->link2 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
			top_ALICE_STACK++;
		}
		if (oc->link3 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
			top_ALICE_STACK++;
		}
		if (oc->link4 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
			top_ALICE_STACK++;
		}
		if (oc->link5 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
			top_ALICE_STACK++;
		}
		if (oc->link6 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
			top_ALICE_STACK++;
		}
		if (oc->link7 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
			top_ALICE_STACK++;
		}
		while (top_ALICE_STACK > 0) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
				if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {
					//if (my_ALICE_STACK[top_ALICE_STACK - 1].link->b_the_geometric_fragmentation == false) {
						// Во избежании повторного дробления узла за раз.
						//my_ALICE_STACK[top_ALICE_STACK - 1].link->b_the_geometric_fragmentation = true;
						ikount_list++;

						octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
						integer minx = my_ALICE_STACK[top_ALICE_STACK - 1].minx;
						integer maxx = my_ALICE_STACK[top_ALICE_STACK - 1].maxx;
						integer miny = my_ALICE_STACK[top_ALICE_STACK - 1].miny;
						integer maxy = my_ALICE_STACK[top_ALICE_STACK - 1].maxy;
						integer minz = my_ALICE_STACK[top_ALICE_STACK - 1].minz;
						integer maxz = my_ALICE_STACK[top_ALICE_STACK - 1].maxz;

						if (octree1->disbalance_now) {
							my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
							top_ALICE_STACK--;
							octree1->dlist = false; // он больше никак не лист (это важно).
							integer i_76 = top_ALICE_STACK;
							integer iret64 = 0;

							octree1->brootSituationX = octree1->brootSituationX_virtual;
							octree1->brootSituationY = octree1->brootSituationY_virtual;
							octree1->brootSituationZ = octree1->brootSituationZ_virtual;
							//droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64, true, true, true, true);
							droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64, true, octree1->brootSituationX_virtual, octree1->brootSituationY_virtual, octree1->brootSituationZ_virtual);
							//droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64, true, octree1->brootSituationX, octree1->brootSituationY, octree1->brootSituationZ);

							//i_76 = top_ALICE_STACK - i_76;
							if (iret64 != top_ALICE_STACK - i_76) {
#if doubleintprecision == 1
								printf("error bonly_dir_Z ! invariant deleniq ne proiden %lld %lld \n", iret64, top_ALICE_STACK - i_76);
#else
								printf("error bonly_dir_Z ! invariant deleniq ne proiden %d %d \n", iret64, top_ALICE_STACK - i_76);
#endif
								
								//getchar();
								system("PAUSE");
							}
							iret += top_ALICE_STACK - i_76;
							bcont = true;
							for (integer j_i = top_ALICE_STACK - 1; j_i >= i_76; j_i--) {
								my_ALICE_STACK[j_i].link = NULL;
							}
							top_ALICE_STACK = i_76;
							top_ALICE_STACK++;// компенсация.
						}
						octree1 = NULL;
						my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
						top_ALICE_STACK--;


					//}

				}
				else {
					// продолжаем добираться до листьев.
					STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
					STACK_ALICE* buf = &buf1;
					top_ALICE_STACK--;
					if (buf->link->link0 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link1 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link2 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link3 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link4 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link5 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link6 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link7 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
						top_ALICE_STACK++;
					}
				}
			}
		}
#if doubleintprecision == 1
		printf("droblenie disbalance : all number of lists=%lld\t", ikount_list);
#else
		printf("droblenie disbalance : all number of lists=%d\t", ikount_list);
#endif
		
		if (DEBUG_ALICE_MESH) {
			//getchar();
			system("PAUSE");
		}

	}
} // droblenie_disbalance

// Устаревная неиспользуемая версия кода.
// см. balance_octTree2.
void balance_octTree3(octTree* &oc, doublereal* xpos, doublereal* ypos, doublereal* zpos, integer &iret, doublereal epsTool) {
	// Здесь необходимо сохранить сбалансированность построенного дерева.
	// Уровень дробления не более 2 (двойки).
	// Доразбивка или Балансировка.
	iret = 0;
	bool bcont = true;
	//for (integer i_7 = 0; i_7 < 5000; i_7++) {
	while (bcont) {
		bcont = false;
		top_ALICE_STACK = 0;
		if (oc->link0 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
			top_ALICE_STACK++;
		}
		if (oc->link1 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
			top_ALICE_STACK++;
		}
		if (oc->link2 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
			top_ALICE_STACK++;
		}
		if (oc->link3 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
			top_ALICE_STACK++;
		}
		if (oc->link4 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
			top_ALICE_STACK++;
		}
		if (oc->link5 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
			top_ALICE_STACK++;
		}
		if (oc->link6 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
			top_ALICE_STACK++;
		}
		if (oc->link7 != NULL) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
			top_ALICE_STACK++;
		}
		while (top_ALICE_STACK > 0) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
				if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {

					octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
					integer minx = my_ALICE_STACK[top_ALICE_STACK - 1].minx;
					integer maxx = my_ALICE_STACK[top_ALICE_STACK - 1].maxx;
					integer miny = my_ALICE_STACK[top_ALICE_STACK - 1].miny;
					integer maxy = my_ALICE_STACK[top_ALICE_STACK - 1].maxy;
					integer minz = my_ALICE_STACK[top_ALICE_STACK - 1].minz;
					integer maxz = my_ALICE_STACK[top_ALICE_STACK - 1].maxz;

					// Вырождение по Z.
					bool bSituationZ = false;
					// Вырождение по X.
					bool bSituationX = false;
					// Вырождение по Y.
					bool bSituationY = false;


					bool bonly_dir_X = false;
					bool bonly_dir_Y = false;
					bool bonly_dir_Z = false;
					if (minz + 1 == maxz) {

						// Вырождение по Z.
						bSituationZ = true;
					}
					if (minx + 1 == maxx) {

						// Вырождение по X.
						bSituationX = true;
					}
					if (miny + 1 == maxy) {

						// Вырождение по Y.
						bSituationY = true;
					}

					if (bSituationX && (bSituationY) && (!bSituationZ)) {

						bonly_dir_Z = true;
					}
					if (bSituationX && (bSituationZ) && (!bSituationY)) {

						bonly_dir_Y = true;
					}
					if (bSituationY && (bSituationZ) && (!bSituationX)) {

						bonly_dir_X = true;
					}

					if ((octree1->maxBsosed > 4) || (octree1->maxTsosed > 4) || (octree1->maxWsosed > 4) || (octree1->maxEsosed > 4) || (octree1->maxSsosed > 4) || (octree1->maxNsosed > 4)) {

						// разбиение на 8.

						if ((minx + 1 == maxx) && (miny + 1 == maxy) && (minz + 1 == maxz)) {
							printf("fatal error : atomarnaq\n");
							//getchar();
							// Это атомарная ячейка и она не может быть раздроблена.
							// Количество соседей атомарной ячейки по определению 1. 
							// Или даже ноль если соответсвующая связь NULL.
							if (octree1->linkB == NULL) {
								octree1->maxBsosed = 0;
							}
							else {
								octree1->maxBsosed = 1;
							}
							if (octree1->linkT == NULL) {
								octree1->maxTsosed = 0;
							}
							else {
								octree1->maxTsosed = 1;
							}

							if (octree1->linkS == NULL) {
								octree1->maxSsosed = 0;
							}
							else {
								octree1->maxSsosed = 1;
							}
							if (octree1->linkN == NULL) {
								octree1->maxNsosed = 0;
							}
							else {
								octree1->maxNsosed = 1;
							}
							if (octree1->linkW == NULL) {
								octree1->maxWsosed = 0;
							}
							else {
								octree1->maxWsosed = 1;
							}
							if (octree1->linkE == NULL) {
								octree1->maxEsosed = 0;
							}
							else {
								octree1->maxEsosed = 1;
							}

							//printf("atomarnaq\n");
							//getchar();
							// Дробление не вызывается.
							my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;

						}
						else {
							// move STACK
							my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
							top_ALICE_STACK--;
							octree1->dlist = false; // он больше никак не лист (это важно).
							integer i_76 = top_ALICE_STACK;
							integer iret64 = 0;
							droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64,true, true, true, true);
							//i_76 = top_ALICE_STACK - i_76;
							if (iret64 != top_ALICE_STACK - i_76) {
#if doubleintprecision == 1
								printf("error ! invariant deleniq ne proiden %lld %lld \n", iret64, top_ALICE_STACK - i_76);
#else
								printf("error ! invariant deleniq ne proiden %d %d \n", iret64, top_ALICE_STACK - i_76);
#endif
								
								//getchar();
								system("PAUSE");
							}
							iret += top_ALICE_STACK - i_76;
#if doubleintprecision == 1
							//printf("i_76=%lld\n", top_ALICE_STACK - i_76);
#else
							//printf("i_76=%d\n", top_ALICE_STACK - i_76);
#endif
							
							//bool b54 = true;
							//for (integer i_74 = i_76; i_74 < top_ALICE_STACK; i_74++) {
							//if (my_ALICE_STACK[i_74].link->dlist == true) {
							//	printf("true\n");
							//}
							//else {
							//printf("false\n");
							//	}
							//}
							//getchar();
							bcont = true;
							//top_ALICE_STACK -= i_76;
							top_ALICE_STACK++;// компенсация.
						}
						octree1 = NULL;
						my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
						top_ALICE_STACK--;
					}
					else {
						//обычный лист который ненадо дробить.
						octree1 = NULL;
						my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
						top_ALICE_STACK--;
					}

				}
				else {
					// продолжаем добираться до листьев.
					STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
					STACK_ALICE* buf = &buf1;
					top_ALICE_STACK--;
					if (buf->link->link0 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link1 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link2 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link3 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link4 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link5 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link6 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link7 != NULL) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
						top_ALICE_STACK++;
					}
				}
			}
		}
		
		//getchar();
	}
} // balance_octTree3



void droblenie_list_octTree2(octTree* &oc, doublereal* xpos, doublereal* ypos, doublereal* zpos, integer &iret,
	integer inx, integer iny, integer inz, BLOCK* &b, integer lb, integer lw, WALL* &w, SOURCE* &s, integer &ls,
	doublereal epsToolx, doublereal epsTooly, doublereal epsToolz ) {

	// Здесь необходимо сохранить сбалансированность построенного дерева.
	// Уровень дробления не более 2 (двойки).
	// Доразбивка или Балансировка.
	iret = 0;
	bool bcont = true;
	//for (integer i_7 = 0; i_7 < 5000; i_7++) {
	//while (bcont) {
	//bcont = false;
	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {



				octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;

				// разбиение на 8.
				integer minx = my_ALICE_STACK[top_ALICE_STACK - 1].minx;
				integer maxx = my_ALICE_STACK[top_ALICE_STACK - 1].maxx;
				integer miny = my_ALICE_STACK[top_ALICE_STACK - 1].miny;
				integer maxy = my_ALICE_STACK[top_ALICE_STACK - 1].maxy;
				integer minz = my_ALICE_STACK[top_ALICE_STACK - 1].minz;
				integer maxz = my_ALICE_STACK[top_ALICE_STACK - 1].maxz;

				// Дробление  вызывается.
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				top_ALICE_STACK--;

				bool tr1 = octree1->b4N;
				integer i_76 = top_ALICE_STACK;
				iret += droblenie(xpos, ypos, zpos,
					inx, iny, inz, octree1,
					minx, maxx, miny, maxy, minz, maxz, b, lb, lw, w, s, ls, epsToolx, epsTooly, epsToolz);
				if (tr1) {
					if (DEBUG_ALICE_MESH) {
						printf("b4N situation found\n");
					}
					/*
					if (octree1->b4N) {
						printf("true true\n"); // Все впорядке проверка пройдена.
					}
					else {
						printf("true stalo false\n ");
					}
					getchar();
					*/
				}
				if (DEBUG_ALICE_MESH) {
#if doubleintprecision == 1
					printf("incoming iret=%lld\n", iret);
#else
					printf("incoming iret=%d\n", iret);
#endif
					
					//	getchar();
				}
				for (integer i_27 = i_76; i_27 < top_ALICE_STACK; i_27++) {
					my_ALICE_STACK[i_27].link = NULL;
				}
				//top_ALICE_STACK -= top_ALICE_STACK - i_76;
				top_ALICE_STACK = i_76;

				//i_76 = top_ALICE_STACK - i_76;
#if doubleintprecision == 1
				//printf("i_76=%lld\n", top_ALICE_STACK - i_76);
#else
				//printf("i_76=%d\n", top_ALICE_STACK - i_76);
#endif
				
				//bool b54 = true;
				//for (integer i_74 = i_76; i_74 < top_ALICE_STACK; i_74++) {
				//if (my_ALICE_STACK[i_74].link->dlist == true) {
				//printf("true\n");
				//}
				//else {
				//printf("false\n");
				//}
				//}
				//getchar();
				//bcont = true;
				//top_ALICE_STACK -= i_76;
				//top_ALICE_STACK++;// компенсация.

				//top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//getchar();
	}
} // droblenie_list_octTree2



// визуализация.
// визуализация в tecplot 360 с учётом hollow блоков в программной модели.
void expt(octTree* &oc, integer inx, integer iny, integer inz, integer maxelm, doublereal* &xpos, doublereal* &ypos, doublereal* &zpos) {

	// Вычисление допуска.
	doublereal epsTolx = 1.0e40;
	doublereal epsToly = 1.0e40;
	doublereal epsTolz = 1.0e40;
	for (integer i = 0; i < inx; i++) {
		if (fabs(xpos[i + 1] - xpos[i]) < epsTolx) {
			epsTolx = 0.5*fabs(xpos[i + 1] - xpos[i]);
		}
	}
	for (integer i = 0; i < iny; i++) {
		if (fabs(ypos[i + 1] - ypos[i]) < epsToly) {
			epsToly = 0.5*fabs(ypos[i + 1] - ypos[i]);
		}
	}
	for (integer i = 0; i < inz; i++) {
		if (fabs(zpos[i + 1] - zpos[i]) < epsTolz) {
			epsTolz = 0.5*fabs(zpos[i + 1] - zpos[i]);
		}
	}



	// сформировать pa.
	// заодно посчитать количество узловых точек.
	// сформировать nvtx которые ссылаются на pa.
	// визуализировать сетку.
	// Память под pa_alice выделяется после вычисления точного необходимого её объема, т.к.
	// на больших объектах мы можем не вылететь по недостатку памяти.
	integer marker_pa = 0;
	
	
	HASH_POLE* hash_table_export = new HASH_POLE[(inx + 1)*(iny + 1)*(inz + 1)];
	for (integer i_1 = 0; i_1 < (inx + 1)*(iny + 1)*(inz + 1); i_1++) {
		hash_table_export[i_1].flag = false;
		hash_table_export[i_1].inum = -1;
	}
	
	// модификация 25 марта 2017. Сначала просто посчитаем сколько же надо памяти в действительности.

	integer marker_pa_shadow = 0;
	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}



	while (top_ALICE_STACK > 0) {

		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {

				octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;

				// это лист update pa.
				integer i0, i1, i2, i3, i4, i5, i6, i7;


				bool bfound = false;
				integer key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p0, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;

				if (!bfound) {
					i0 = marker_pa_shadow;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa_shadow++;
				}
				else {
					i0 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p1, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i1 = marker_pa_shadow;
					
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa_shadow++;
				}
				else {
					i1 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p2, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i2 = marker_pa_shadow;
					
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa_shadow++;
				}
				else {
					i2 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p3, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i3 = marker_pa_shadow;
					
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa_shadow++;
				}
				else {
					i3 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p4, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i4 = marker_pa_shadow;
					
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa_shadow++;
				}
				else {
					i4 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p5, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i5 = marker_pa_shadow;
					
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa_shadow++;
				}
				else {
					i5 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p6, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i6 = marker_pa_shadow;
					
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa_shadow++;
				}
				else {
					i6 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p7, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i7 = marker_pa_shadow;
					
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa_shadow++;
				}
				else {
					i7 = hash_table_export[key_now].inum;
				}

				

				octree1 = NULL;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				top_ALICE_STACK--;

			}
			else {
				// продолжаем добираться до листьев.

				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}

			}
		}

	}
	delete[] hash_table_export;

	// конец модификации 25 марта 2017.


	// сформировать pa.
	// заодно посчитать количество узловых точек.
	// сформировать nvtx которые ссылаются на pa.
	// визуализировать сетку.
	TOCHKA* pa_alice = NULL;
	pa_alice = new TOCHKA[marker_pa_shadow+2]; // 2 - запас.
	if (pa_alice == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for pa_alice in adaptive_local_refinement_mesh generator...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}

	// И тут же сразу формируем nvtx:
	integer** nvtx = NULL;
	nvtx = new integer*[8];
	if (nvtx == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for nvtx in adaptive_local_refinement_mesh generator...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	for (integer k_1 = 0; k_1 < 8; k_1++) {
		nvtx[k_1] = NULL;
		//nvtx[k_1] = new integer[maxelm + 1];
		// Это существенно экономит память т.к. число призм не может быть больше чем число вершин призм.
		nvtx[k_1] = new integer[marker_pa_shadow + 2];
		if (nvtx[k_1] == NULL) {
			// недостаточно памяти на данном оборудовании.
#if doubleintprecision == 1
			printf("Problem : not enough memory on your equipment for nvtx[%lld] in adaptive_local_refinement_mesh generator...\n", k_1);
#else
			printf("Problem : not enough memory on your equipment for nvtx[%d] in adaptive_local_refinement_mesh generator...\n", k_1);
#endif
			
			printf("Please any key to exit...\n");
			exit(1);
		}
	}
	integer imarker_nvtx = 1;

	hash_table_export = new HASH_POLE[(inx + 1)*(iny + 1)*(inz + 1)];
	for (integer i_1 = 0; i_1 < (inx + 1)*(iny + 1)*(inz + 1); i_1++) {
		hash_table_export[i_1].flag = false;
		hash_table_export[i_1].inum = -1;
	}


	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}

	
	
	while (top_ALICE_STACK > 0) {

		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {

				octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;

				// это лист update pa.
				integer i0, i1, i2, i3, i4, i5, i6, i7;
				

				bool bfound = false;
				integer key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p0, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;

				if (!bfound) {
					i0 = marker_pa;
					pa_alice[marker_pa] = octree1->p0;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i0 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p1, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i1 = marker_pa;
					pa_alice[marker_pa] = octree1->p1;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i1 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p2, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i2 = marker_pa;
					pa_alice[marker_pa] = octree1->p2;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i2 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p3, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i3 = marker_pa;
					pa_alice[marker_pa] = octree1->p3;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i3 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p4, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i4 = marker_pa;
					pa_alice[marker_pa] = octree1->p4;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i4 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p5, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i5 = marker_pa;
					pa_alice[marker_pa] = octree1->p5;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i5 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p6, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i6 = marker_pa;
					pa_alice[marker_pa] = octree1->p6;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i6 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p7, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i7 = marker_pa;
					pa_alice[marker_pa] = octree1->p7;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i7 = hash_table_export[key_now].inum;
				}

				nvtx[0][imarker_nvtx] = i0 + 1;
				nvtx[1][imarker_nvtx] = i1 + 1;
				nvtx[2][imarker_nvtx] = i2 + 1;
				nvtx[3][imarker_nvtx] = i3 + 1;
				nvtx[4][imarker_nvtx] = i4 + 1;
				nvtx[5][imarker_nvtx] = i5 + 1;
				nvtx[6][imarker_nvtx] = i6 + 1;
				nvtx[7][imarker_nvtx] = i7 + 1;
				imarker_nvtx++;

				octree1 = NULL;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				top_ALICE_STACK--;

			}
			else {
				// продолжаем добираться до листьев.

				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}

			}
		}

	}
	delete[] hash_table_export;

	// nvtx && pa сформированы, можно экспортировать в tecplot360
	FILE *fp_4 = NULL;
	errno_t err_4;
	err_4 = fopen_s(&fp_4, "ALICEFLOW0_24ALICEMESH.PLT", "w");

	if ((err_4) != 0) {
		printf("Create File temp Error\n");
		//getchar();
		system("pause");

	}
	else {
		if (fp_4 != NULL) {

			fprintf(fp_4, "TITLE = \"ALICEFLOW0_24\"\n");
			fprintf(fp_4, "VARIABLES = x, y, z\n");
#if doubleintprecision == 1
			fprintf(fp_4, "ZONE T=\"Rampant\", N=%lld, E=%lld, ET=BRICK, F=FEBLOCK\n\n", marker_pa, imarker_nvtx - 1);
#else
			fprintf(fp_4, "ZONE T=\"Rampant\", N=%d, E=%d, ET=BRICK, F=FEBLOCK\n\n", marker_pa, imarker_nvtx - 1);
#endif
			
			// запись x
			for (integer i = 0; i < marker_pa; i++) {
				fprintf(fp_4, "%+.16f ", pa_alice[i].x);
				if (i % 10 == 0) fprintf(fp_4, "\n");
			}
			fprintf(fp_4, "\n");
			// запись y
			for (integer i = 0; i < marker_pa; i++) {
				fprintf(fp_4, "%+.16f ", pa_alice[i].y);
				if (i % 10 == 0) fprintf(fp_4, "\n");
			}
			fprintf(fp_4, "\n");
			// запись z
			for (integer i = 0; i < marker_pa; i++) {
				fprintf(fp_4, "%+.16f ", pa_alice[i].z);
				if (i % 10 == 0) fprintf(fp_4, "\n");
			}
			fprintf(fp_4, "\n");
			for (integer i = 1; i <= imarker_nvtx - 1; i++) {
#if doubleintprecision == 1
				fprintf(fp_4, "%lld %lld %lld %lld %lld %lld %lld %lld \n", nvtx[0][i], nvtx[1][i], nvtx[2][i], nvtx[3][i], nvtx[4][i], nvtx[5][i], nvtx[6][i], nvtx[7][i]);
#else
				fprintf(fp_4, "%d %d %d %d %d %d %d %d \n", nvtx[0][i], nvtx[1][i], nvtx[2][i], nvtx[3][i], nvtx[4][i], nvtx[5][i], nvtx[6][i], nvtx[7][i]);
#endif
			}
			fclose(fp_4);
			//WinExec("C:\\Program Files\\Tecplot\\Tecplot 360 EX 2014 R1\\bin\\tec360.exe ALICEFLOW0_24ALICEMESH.PLT", SW_NORMAL);
		}
	}

	delete[] pa_alice;
	for (integer i_1 = 0; i_1 <= 7; i_1++) {
		delete[] nvtx[i_1];
	}
	delete[] nvtx;
} // expt




void shutdown_visit(octTree* &oc) {
	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {
				// Гасим информацию о посещениях.
				my_ALICE_STACK[top_ALICE_STACK - 1].link->b_the_geometric_fragmentation = false;
				my_ALICE_STACK[top_ALICE_STACK - 1].link->bcrushing_when_balancing = false;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//getchar();
	}
} // shutdown_visit

// Выключает дисбаланс (сброс).
void shutdown_disbalance(octTree* &oc) {
	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {
				// Гасим информацию о посещениях.
				my_ALICE_STACK[top_ALICE_STACK - 1].link->disbalance_now = false;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//getchar();
	}
} // shutdown_disbalance

// Для полного контроля линковки.
void log_message(octTree* &oc) {
	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {
				// Гасим информацию о посещениях.
				octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
#if doubleintprecision == 1
				if (octree1->parent != NULL) {
					printf("parent root csW csE csS csN csB csT linkW linkE linkS linkN linkB linkT\n");
					printf("%lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld\n", octree1->parent->root, octree1->root, octree1->maxWsosed, octree1->maxEsosed, octree1->maxSsosed, octree1->maxNsosed, octree1->maxBsosed, octree1->maxTsosed, print_link(octree1->linkW), print_link(octree1->linkE), print_link(octree1->linkS), print_link(octree1->linkN), print_link(octree1->linkB), print_link(octree1->linkT));
				}
				else {
					printf("root csW csE csS csN csB csT linkW linkE linkS linkN linkB linkT\n");
					printf("%lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld\n", octree1->root, octree1->maxWsosed, octree1->maxEsosed, octree1->maxSsosed, octree1->maxNsosed, octree1->maxBsosed, octree1->maxTsosed, print_link(octree1->linkW), print_link(octree1->linkE), print_link(octree1->linkS), print_link(octree1->linkN), print_link(octree1->linkB), print_link(octree1->linkT));
				}
#else
				if (octree1->parent != NULL) {
					printf("parent root csW csE csS csN csB csT linkW linkE linkS linkN linkB linkT\n");
					printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d\n", octree1->parent->root, octree1->root, octree1->maxWsosed, octree1->maxEsosed, octree1->maxSsosed, octree1->maxNsosed, octree1->maxBsosed, octree1->maxTsosed, print_link(octree1->linkW), print_link(octree1->linkE), print_link(octree1->linkS), print_link(octree1->linkN), print_link(octree1->linkB), print_link(octree1->linkT));
				}
				else {
					printf("root csW csE csS csN csB csT linkW linkE linkS linkN linkB linkT\n");
					printf("%d %d %d %d %d %d %d %d %d %d %d %d %d\n", octree1->root, octree1->maxWsosed, octree1->maxEsosed, octree1->maxSsosed, octree1->maxNsosed, octree1->maxBsosed, octree1->maxTsosed, print_link(octree1->linkW), print_link(octree1->linkE), print_link(octree1->linkS), print_link(octree1->linkN), print_link(octree1->linkB), print_link(octree1->linkT));
				}
#endif
				
				//getchar();
				system("PAUSE");
				octree1 = NULL;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//getchar();
	}
} // log_message

  // Для полного контроля линковки.
void if_disbalnce_marker(octTree* &oc)
{
	printf("if disbalance control.\n");
	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {
				octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
				if (!octree1->b4N) {
					if (octree1->linkN != NULL) {
						if (abs(octree1->ilevel - octree1->linkN->ilevel) > 1) {
							printf("disbalance N is found...\n");
							//getchar();
							system("PAUSE");
						}
					}
				}
				if (!octree1->b4S) {
					if (octree1->linkS != NULL) {
						if (abs(octree1->ilevel - octree1->linkS->ilevel) > 1) {
							printf("disbalance S is found...\n");
							//getchar();
							system("PAUSE");
						}
					}
				}
				if (!octree1->b4E) {
					if (octree1->linkE != NULL) {
						if (abs(octree1->ilevel - octree1->linkE->ilevel) > 1) {
							printf("disbalance E is found...\n");
							//getchar();
							system("PAUSE");
						}
					}
				}
				if (!octree1->b4W) {
					if (octree1->linkW != NULL) {
						if (abs(octree1->ilevel - octree1->linkW->ilevel) > 1) {
							printf("disbalance W is found...\n");
							//getchar();
							system("PAUSE");
						}
					}
				}
				if (!octree1->b4T) {
					if (octree1->linkT != NULL) {
						if (abs(octree1->ilevel - octree1->linkT->ilevel) > 1) {
							printf("disbalance T is found...\n");
							//getchar();
							system("PAUSE");
						}
					}
				}
				if (!octree1->b4B) {
					if (octree1->linkB != NULL) {
						if (abs(octree1->ilevel - octree1->linkB->ilevel) > 1) {
							printf("disbalance B is found...\n");
							//getchar();
							system("PAUSE");
						}
					}
				}
				octree1 = NULL;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//getchar();
	}

}

// Для полного контроля линковки.
integer if_disbalnce(octTree* &oc, integer inx, integer iny, integer inz, integer maxelm, doublereal* &xpos, doublereal* &ypos, doublereal* &zpos,
	doublereal* &xposadd, doublereal* &yposadd, doublereal* &zposadd,
	integer &inxadd, integer &inyadd, integer &inzadd) {

	printf("if disbalance control.\n");
	integer iOk = 0;
	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {
				octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
				if (!octree1->b4N) {
					if (octree1->linkN != NULL) {
						if (abs(octree1->ilevel - octree1->linkN->ilevel) > 1) {
							iOk++;
							if (octree1->ilevel < octree1->linkN->ilevel) {
								// дробим octree1
								// Можно оставить только одно добавление.
								//addboundary(xposadd, inxadd, 0.5*(xpos[octree1->minx] + xpos[octree1->maxx]));
								addboundary(yposadd, inyadd, 0.5*(ypos[octree1->miny] + ypos[octree1->maxy]));
								//addboundary(zposadd, inzadd, 0.5*(zpos[octree1->minz] + zpos[octree1->maxz]));
								printf("%d %d %d %d %d %d\n", octree1->minx, octree1->maxx, octree1->miny, octree1->maxy, octree1->minz, octree1->maxz);
							}
							else {
								// дробим octree1->linkN
								// Можно оставить только одно добавление.
								//addboundary(xposadd, inxadd, 0.5*(xpos[octree1->linkN->minx] + xpos[octree1->linkN->maxx]));
								addboundary(yposadd, inyadd, 0.5*(ypos[octree1->linkN->miny] + ypos[octree1->linkN->maxy]));
								//addboundary(zposadd, inzadd, 0.5*(zpos[octree1->linkN->minz] + zpos[octree1->linkN->maxz]));
								printf("%d %d %d %d %d %d\n", octree1->linkN->minx, octree1->linkN->maxx, octree1->linkN->miny, octree1->linkN->maxy, octree1->linkN->minz, octree1->linkN->maxz);
							}
							printf("disbalance N is found...\n");
							//getchar();
							//system("PAUSE");
						}
					}
				}
				if (!octree1->b4S) {
					if (octree1->linkS != NULL) {
						if (abs(octree1->ilevel - octree1->linkS->ilevel) > 1) {
							iOk++;
							if (octree1->ilevel < octree1->linkS->ilevel) {
								// дробим octree1
								// Можно оставить только одно добавление.
								//addboundary(xposadd, inxadd, 0.5*(xpos[octree1->minx] + xpos[octree1->maxx]));
								addboundary(yposadd, inyadd, 0.5*(ypos[octree1->miny] + ypos[octree1->maxy]));
								//addboundary(zposadd, inzadd, 0.5*(zpos[octree1->minz] + zpos[octree1->maxz]));
								printf("%d %d %d %d %d %d\n", octree1->minx, octree1->maxx, octree1->miny, octree1->maxy, octree1->minz, octree1->maxz);
							}
							else {
								// дробим octree1->linkN
								// Можно оставить только одно добавление.
								//addboundary(xposadd, inxadd, 0.5*(xpos[octree1->linkS->minx] + xpos[octree1->linkS->maxx]));
								addboundary(yposadd, inyadd, 0.5*(ypos[octree1->linkS->miny] + ypos[octree1->linkS->maxy]));
								//addboundary(zposadd, inzadd, 0.5*(zpos[octree1->linkS->minz] + zpos[octree1->linkS->maxz]));
								printf("%d %d %d %d %d %d\n", octree1->linkS->minx, octree1->linkS->maxx, octree1->linkS->miny, octree1->linkS->maxy, octree1->linkS->minz, octree1->linkS->maxz);
							}
							printf("disbalance S is found...\n");
							//getchar();
							//system("PAUSE");
						}
					}
				}
				if (!octree1->b4E) {
					if (octree1->linkE != NULL) {
						if (abs(octree1->ilevel - octree1->linkE->ilevel) > 1) {
							iOk++;
							if (octree1->ilevel < octree1->linkE->ilevel) {
								// дробим octree1
								// Можно оставить только одно добавление.
								addboundary(xposadd, inxadd, 0.5*(xpos[octree1->minx] + xpos[octree1->maxx]));
								//addboundary(yposadd, inyadd, 0.5*(ypos[octree1->miny] + ypos[octree1->maxy]));
								//addboundary(zposadd, inzadd, 0.5*(zpos[octree1->minz] + zpos[octree1->maxz]));
								printf("%d %d %d %d %d %d\n", octree1->minx, octree1->maxx, octree1->miny, octree1->maxy, octree1->minz, octree1->maxz);
							}
							else {
								// дробим octree1->linkN
								// Можно оставить только одно добавление.
								addboundary(xposadd, inxadd, 0.5*(xpos[octree1->linkE->minx] + xpos[octree1->linkE->maxx]));
								//addboundary(yposadd, inyadd, 0.5*(ypos[octree1->linkE->miny] + ypos[octree1->linkE->maxy]));
								//addboundary(zposadd, inzadd, 0.5*(zpos[octree1->linkE->minz] + zpos[octree1->linkE->maxz]));
								printf("%d %d %d %d %d %d\n", octree1->linkE->minx, octree1->linkE->maxx, octree1->linkE->miny, octree1->linkE->maxy, octree1->linkE->minz, octree1->linkE->maxz);
							}
							printf("disbalance E is found...\n");
							//getchar();
							//system("PAUSE");
						}
					}
				}
				if (!octree1->b4W) {
					if (octree1->linkW != NULL) {
						if (abs(octree1->ilevel - octree1->linkW->ilevel) > 1) {
							iOk++;
							if (octree1->ilevel < octree1->linkW->ilevel) {
								// дробим octree1
								// Можно оставить только одно добавление.
								addboundary(xposadd, inxadd, 0.5*(xpos[octree1->minx] + xpos[octree1->maxx]));
								//addboundary(yposadd, inyadd, 0.5*(ypos[octree1->miny] + ypos[octree1->maxy]));
								//addboundary(zposadd, inzadd, 0.5*(zpos[octree1->minz] + zpos[octree1->maxz]));
								printf("%d %d %d %d %d %d\n", octree1->minx, octree1->maxx, octree1->miny, octree1->maxy, octree1->minz, octree1->maxz);
							}
							else {
								// дробим octree1->linkN
								// Можно оставить только одно добавление.
								addboundary(xposadd, inxadd, 0.5*(xpos[octree1->linkW->minx] + xpos[octree1->linkW->maxx]));
								//addboundary(yposadd, inyadd, 0.5*(ypos[octree1->linkW->miny] + ypos[octree1->linkW->maxy]));
								//addboundary(zposadd, inzadd, 0.5*(zpos[octree1->linkW->minz] + zpos[octree1->linkW->maxz]));
								printf("%d %d %d %d %d %d\n", octree1->linkW->minx, octree1->linkW->maxx, octree1->linkW->miny, octree1->linkW->maxy, octree1->linkW->minz, octree1->linkW->maxz);
							}
							printf("disbalance W is found...\n");
							//getchar();
							//system("PAUSE");
						}
					}
				}
				if (!octree1->b4T) {
					if (octree1->linkT != NULL) {
						if (abs(octree1->ilevel - octree1->linkT->ilevel) > 1) {
							iOk++;
							if (octree1->ilevel < octree1->linkT->ilevel) {
								// дробим octree1
								// Можно оставить только одно добавление.
								//addboundary(xposadd, inxadd, 0.5*(xpos[octree1->minx] + xpos[octree1->maxx]));
								//addboundary(yposadd, inyadd, 0.5*(ypos[octree1->miny] + ypos[octree1->maxy]));
								addboundary(zposadd, inzadd, 0.5*(zpos[octree1->minz] + zpos[octree1->maxz]));
								printf("%d %d %d %d %d %d\n", octree1->minx, octree1->maxx, octree1->miny, octree1->maxy, octree1->minz, octree1->maxz);
							}
							else {
								// дробим octree1->linkN
								// Можно оставить только одно добавление.
								//addboundary(xposadd, inxadd, 0.5*(xpos[octree1->linkT->minx] + xpos[octree1->linkT->maxx]));
								//addboundary(yposadd, inyadd, 0.5*(ypos[octree1->linkT->miny] + ypos[octree1->linkT->maxy]));
								addboundary(zposadd, inzadd, 0.5*(zpos[octree1->linkT->minz] + zpos[octree1->linkT->maxz]));
								printf("%d %d %d %d %d %d\n", octree1->linkT->minx, octree1->linkT->maxx, octree1->linkT->miny, octree1->linkT->maxy, octree1->linkT->minz, octree1->linkT->maxz);
							}
							printf("disbalance T is found...\n");
							//getchar();
							//system("PAUSE");
						}
					}
				}
				if (!octree1->b4B) {
					if (octree1->linkB != NULL) {
						if (abs(octree1->ilevel - octree1->linkB->ilevel) > 1) {
							iOk++;
							if (octree1->ilevel < octree1->linkB->ilevel) {
								// дробим octree1
								// Можно оставить только одно добавление.
								//addboundary(xposadd, inxadd, 0.5*(xpos[octree1->minx] + xpos[octree1->maxx]));
								//addboundary(yposadd, inyadd, 0.5*(ypos[octree1->miny] + ypos[octree1->maxy]));
								addboundary(zposadd, inzadd, 0.5*(zpos[octree1->minz] + zpos[octree1->maxz]));
								printf("%d %d %d %d %d %d\n", octree1->minx, octree1->maxx, octree1->miny, octree1->maxy, octree1->minz, octree1->maxz);
							}
							else {
								// дробим octree1->linkN
								// Можно оставить только одно добавление.
								//addboundary(xposadd, inxadd, 0.5*(xpos[octree1->linkB->minx] + xpos[octree1->linkB->maxx]));
								//addboundary(yposadd, inyadd, 0.5*(ypos[octree1->linkB->miny] + ypos[octree1->linkB->maxy]));
								addboundary(zposadd, inzadd, 0.5*(zpos[octree1->linkB->minz] + zpos[octree1->linkB->maxz]));
								printf("%d %d %d %d %d %d\n", octree1->linkB->minx, octree1->linkB->maxx, octree1->linkB->miny, octree1->linkB->maxy, octree1->linkB->minz, octree1->linkB->maxz);
							}
							printf("disbalance B is found...\n");
							//getchar();
							//system("PAUSE");
						}
					}
				}
				octree1 = NULL;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//getchar();
	}

	return iOk;
} // if_disbalance.




// Для полного контроля линковки.
void marker_disbalnce_year2016(octTree* &oc) {
	printf("marker disbalance control.\n");
	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {
				octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
				if (!octree1->b4N) {
					if (octree1->linkN != NULL) {
						if (abs(octree1->ilevel - octree1->linkN->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance N is found...\n");
							}
							if (octree1->ilevel > octree1->linkN->ilevel) {
								octree1->linkN->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//getchar();
						}
					}
				}
				if (!octree1->b4S) {
					if (octree1->linkS != NULL) {
						if (abs(octree1->ilevel - octree1->linkS->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance S is found...\n");
							}
							if (octree1->ilevel > octree1->linkS->ilevel) {
								octree1->linkS->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//getchar();
						}
					}
				}
				if (!octree1->b4E) {
					if (octree1->linkE != NULL) {
						if (abs(octree1->ilevel - octree1->linkE->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance E is found...\n");
							}
							if (octree1->ilevel > octree1->linkE->ilevel) {
								octree1->linkE->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//getchar();
						}
					}
				}
				if (!octree1->b4W) {
					if (octree1->linkW != NULL) {
						if (abs(octree1->ilevel - octree1->linkW->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance W is found...\n");
							}
							if (octree1->ilevel > octree1->linkW->ilevel) {
								octree1->linkW->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//getchar();
						}
					}
				}
				if (!octree1->b4T) {
					if (octree1->linkT != NULL) {
						if (abs(octree1->ilevel - octree1->linkT->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance T is found...\n");
							}
							if (octree1->ilevel > octree1->linkT->ilevel) {
								octree1->linkT->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//getchar();
						}
					}
				}
				if (!octree1->b4B) {
					if (octree1->linkB != NULL) {
						if (abs(octree1->ilevel - octree1->linkB->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance B is found...\n");
							}
							if (octree1->ilevel > octree1->linkB->ilevel) {
								octree1->linkB->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//getchar();
						}
					}
				}
				octree1 = NULL;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//getchar();
	}
} // marker_disbalance_year2016.

  // Для полного контроля линковки.
void marker_disbalnce_year2017_2(octTree* &oc, doublereal* &xpos, doublereal* &ypos, doublereal* &zpos) {
	const doublereal critical_volume_ratio = 36.0;

	printf("marker disbalance control.\n");
	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {
				octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
				if (!octree1->b4N) {
					if (octree1->linkN != NULL) {
						if (abs(octree1->ilevel - octree1->linkN->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance N is found...\n");
							}
							if (octree1->ilevel > octree1->linkN->ilevel) {
								octree1->linkN->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//getchar();
						}
						else if (abs(octree1->ilevel - octree1->linkN->ilevel) == 1) {
							integer iml = octree1->ilevel;
							bool biml = true;
							doublereal viml = fabs(xpos[octree1->maxx]-xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
							if (octree1->linkN->ilevel > iml) {
								iml = octree1->linkN->ilevel;
								biml = false;
								viml = fabs(xpos[octree1->linkN->maxx] - xpos[octree1->linkN->minx])*fabs(ypos[octree1->linkN->maxy] - ypos[octree1->linkN->miny])*fabs(zpos[octree1->linkN->maxz] - zpos[octree1->linkN->minz]);
							}
							octTree* oc2 = octree1->linkN;
							if (!oc2->b4N) {
								if (oc2->linkN != NULL) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkN->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkN->maxx] - xpos[oc2->linkN->minx])*fabs(ypos[oc2->linkN->maxy] - ypos[oc2->linkN->miny])*fabs(zpos[oc2->linkN->maxz] - zpos[oc2->linkN->minz]);

										if (iml > oc2->linkN->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkN->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != NULL) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkS->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkS->maxx] - xpos[oc2->linkS->minx])*fabs(ypos[oc2->linkS->maxy] - ypos[oc2->linkS->miny])*fabs(zpos[oc2->linkS->maxz] - zpos[oc2->linkS->minz]);

										if (iml > oc2->linkS->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkS->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != NULL) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkE->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkE->maxx] - xpos[oc2->linkE->minx])*fabs(ypos[oc2->linkE->maxy] - ypos[oc2->linkE->miny])*fabs(zpos[oc2->linkE->maxz] - zpos[oc2->linkE->minz]);

										if (iml > oc2->linkE->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkE->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != NULL) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkW->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkW->maxx] - xpos[oc2->linkW->minx])*fabs(ypos[oc2->linkW->maxy] - ypos[oc2->linkW->miny])*fabs(zpos[oc2->linkW->maxz] - zpos[oc2->linkW->minz]);

										if (iml > oc2->linkW->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkW->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != NULL) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkT->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkT->maxx] - xpos[oc2->linkT->minx])*fabs(ypos[oc2->linkT->maxy] - ypos[oc2->linkT->miny])*fabs(zpos[oc2->linkT->maxz] - zpos[oc2->linkT->minz]);

										if (iml > oc2->linkT->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkT->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != NULL) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkB->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkB->maxx] - xpos[oc2->linkB->minx])*fabs(ypos[oc2->linkB->maxy] - ypos[oc2->linkB->miny])*fabs(zpos[oc2->linkB->maxz] - zpos[oc2->linkB->minz]);

										if (iml > oc2->linkB->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkB->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							oc2 = NULL;
						}
					}
				}
				if (!octree1->b4S) {
					if (octree1->linkS != NULL) {
						if (abs(octree1->ilevel - octree1->linkS->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance S is found...\n");
							}
							if (octree1->ilevel > octree1->linkS->ilevel) {
								octree1->linkS->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//getchar();
						}
						else if (abs(octree1->ilevel - octree1->linkS->ilevel) == 1) {
							integer iml = octree1->ilevel;
							doublereal viml = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
							bool biml = true;
							if (octree1->linkS->ilevel > iml) {
								iml = octree1->linkS->ilevel;
								viml = fabs(xpos[octree1->linkS->maxx] - xpos[octree1->linkS->minx])*fabs(ypos[octree1->linkS->maxy] - ypos[octree1->linkS->miny])*fabs(zpos[octree1->linkS->maxz] - zpos[octree1->linkS->minz]);
								biml = false;
							}
							octTree* oc2 = octree1->linkS;
							if (!oc2->b4N) {
								if (oc2->linkN != NULL) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkN->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkN->maxx] - xpos[oc2->linkN->minx])*fabs(ypos[oc2->linkN->maxy] - ypos[oc2->linkN->miny])*fabs(zpos[oc2->linkN->maxz] - zpos[oc2->linkN->minz]);

										if (iml > oc2->linkN->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkN->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != NULL) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkS->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkS->maxx] - xpos[oc2->linkS->minx])*fabs(ypos[oc2->linkS->maxy] - ypos[oc2->linkS->miny])*fabs(zpos[oc2->linkS->maxz] - zpos[oc2->linkS->minz]);

										if (iml > oc2->linkS->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkS->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != NULL) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkE->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkE->maxx] - xpos[oc2->linkE->minx])*fabs(ypos[oc2->linkE->maxy] - ypos[oc2->linkE->miny])*fabs(zpos[oc2->linkE->maxz] - zpos[oc2->linkE->minz]);

										if (iml > oc2->linkE->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkE->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != NULL) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkW->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkW->maxx] - xpos[oc2->linkW->minx])*fabs(ypos[oc2->linkW->maxy] - ypos[oc2->linkW->miny])*fabs(zpos[oc2->linkW->maxz] - zpos[oc2->linkW->minz]);

										if (iml > oc2->linkW->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkW->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != NULL) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkT->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkT->maxx] - xpos[oc2->linkT->minx])*fabs(ypos[oc2->linkT->maxy] - ypos[oc2->linkT->miny])*fabs(zpos[oc2->linkT->maxz] - zpos[oc2->linkT->minz]);

										if (iml > oc2->linkT->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkT->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != NULL) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkB->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkB->maxx] - xpos[oc2->linkB->minx])*fabs(ypos[oc2->linkB->maxy] - ypos[oc2->linkB->miny])*fabs(zpos[oc2->linkB->maxz] - zpos[oc2->linkB->minz]);

										if (iml > oc2->linkB->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkB->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							oc2 = NULL;
						}
					}
				}
				if (!octree1->b4E) {
					if (octree1->linkE != NULL) {
						if (abs(octree1->ilevel - octree1->linkE->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance E is found...\n");
							}
							if (octree1->ilevel > octree1->linkE->ilevel) {
								octree1->linkE->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//getchar();
						}
						else if (abs(octree1->ilevel - octree1->linkE->ilevel) == 1) {
							integer iml = octree1->ilevel;
							doublereal viml = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
							bool biml = true;
							if (octree1->linkE->ilevel > iml) {
								iml = octree1->linkE->ilevel;
								viml = fabs(xpos[octree1->linkE->maxx] - xpos[octree1->linkE->minx])*fabs(ypos[octree1->linkE->maxy] - ypos[octree1->linkE->miny])*fabs(zpos[octree1->linkE->maxz] - zpos[octree1->linkE->minz]);
								biml = false;
							}
							octTree* oc2 = octree1->linkE;
							if (!oc2->b4N) {
								if (oc2->linkN != NULL) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkN->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkN->maxx] - xpos[oc2->linkN->minx])*fabs(ypos[oc2->linkN->maxy] - ypos[oc2->linkN->miny])*fabs(zpos[oc2->linkN->maxz] - zpos[oc2->linkN->minz]);

										if (iml > oc2->linkN->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkN->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != NULL) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkS->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkS->maxx] - xpos[oc2->linkS->minx])*fabs(ypos[oc2->linkS->maxy] - ypos[oc2->linkS->miny])*fabs(zpos[oc2->linkS->maxz] - zpos[oc2->linkS->minz]);

										if (iml > oc2->linkS->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkS->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != NULL) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkE->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkE->maxx] - xpos[oc2->linkE->minx])*fabs(ypos[oc2->linkE->maxy] - ypos[oc2->linkE->miny])*fabs(zpos[oc2->linkE->maxz] - zpos[oc2->linkE->minz]);

										if (iml > oc2->linkE->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkE->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != NULL) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkW->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkW->maxx] - xpos[oc2->linkW->minx])*fabs(ypos[oc2->linkW->maxy] - ypos[oc2->linkW->miny])*fabs(zpos[oc2->linkW->maxz] - zpos[oc2->linkW->minz]);

										if (iml > oc2->linkW->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkW->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != NULL) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkT->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkT->maxx] - xpos[oc2->linkT->minx])*fabs(ypos[oc2->linkT->maxy] - ypos[oc2->linkT->miny])*fabs(zpos[oc2->linkT->maxz] - zpos[oc2->linkT->minz]);

										if (iml > oc2->linkT->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkT->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != NULL) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkB->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkB->maxx] - xpos[oc2->linkB->minx])*fabs(ypos[oc2->linkB->maxy] - ypos[oc2->linkB->miny])*fabs(zpos[oc2->linkB->maxz] - zpos[oc2->linkB->minz]);

										if (iml > oc2->linkB->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkB->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							oc2 = NULL;
						}
					}
				}
				if (!octree1->b4W) {
					if (octree1->linkW != NULL) {
						if (abs(octree1->ilevel - octree1->linkW->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance W is found...\n");
							}
							if (octree1->ilevel > octree1->linkW->ilevel) {
								octree1->linkW->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//getchar();
						}
						else if (abs(octree1->ilevel - octree1->linkW->ilevel) == 1) {
							integer iml = octree1->ilevel;
							doublereal viml = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
							bool biml = true;
							if (octree1->linkW->ilevel > iml) {
								iml = octree1->linkW->ilevel;
								viml = fabs(xpos[octree1->linkW->maxx] - xpos[octree1->linkW->minx])*fabs(ypos[octree1->linkW->maxy] - ypos[octree1->linkW->miny])*fabs(zpos[octree1->linkW->maxz] - zpos[octree1->linkW->minz]);
								biml = false;
							}
							octTree* oc2 = octree1->linkW;
							if (!oc2->b4N) {
								if (oc2->linkN != NULL) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkN->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkN->maxx] - xpos[oc2->linkN->minx])*fabs(ypos[oc2->linkN->maxy] - ypos[oc2->linkN->miny])*fabs(zpos[oc2->linkN->maxz] - zpos[oc2->linkN->minz]);

										if (iml > oc2->linkN->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkN->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != NULL) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkS->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkS->maxx] - xpos[oc2->linkS->minx])*fabs(ypos[oc2->linkS->maxy] - ypos[oc2->linkS->miny])*fabs(zpos[oc2->linkS->maxz] - zpos[oc2->linkS->minz]);

										if (iml > oc2->linkS->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkS->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != NULL) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkE->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkE->maxx] - xpos[oc2->linkE->minx])*fabs(ypos[oc2->linkE->maxy] - ypos[oc2->linkE->miny])*fabs(zpos[oc2->linkE->maxz] - zpos[oc2->linkE->minz]);

										if (iml > oc2->linkE->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkE->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != NULL) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkW->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkW->maxx] - xpos[oc2->linkW->minx])*fabs(ypos[oc2->linkW->maxy] - ypos[oc2->linkW->miny])*fabs(zpos[oc2->linkW->maxz] - zpos[oc2->linkW->minz]);

										if (iml > oc2->linkW->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkW->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != NULL) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkT->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkT->maxx] - xpos[oc2->linkT->minx])*fabs(ypos[oc2->linkT->maxy] - ypos[oc2->linkT->miny])*fabs(zpos[oc2->linkT->maxz] - zpos[oc2->linkT->minz]);

										if (iml > oc2->linkT->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkT->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != NULL) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkB->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkB->maxx] - xpos[oc2->linkB->minx])*fabs(ypos[oc2->linkB->maxy] - ypos[oc2->linkB->miny])*fabs(zpos[oc2->linkB->maxz] - zpos[oc2->linkB->minz]);

										if (iml > oc2->linkB->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkB->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							oc2 = NULL;
						}
					}
				}
				if (!octree1->b4T) {
					if (octree1->linkT != NULL) {
						if (abs(octree1->ilevel - octree1->linkT->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance T is found...\n");
							}
							if (octree1->ilevel > octree1->linkT->ilevel) {
								octree1->linkT->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//getchar();
						}
						else if (abs(octree1->ilevel - octree1->linkT->ilevel) == 1) {
							integer iml = octree1->ilevel;
							doublereal viml = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
							bool biml = true;
							if (octree1->linkT->ilevel > iml) {
								iml = octree1->linkT->ilevel;
								viml = fabs(xpos[octree1->linkT->maxx] - xpos[octree1->linkT->minx])*fabs(ypos[octree1->linkT->maxy] - ypos[octree1->linkT->miny])*fabs(zpos[octree1->linkT->maxz] - zpos[octree1->linkT->minz]);
								biml = false;
							}
							octTree* oc2 = octree1->linkT;
							if (!oc2->b4N) {
								if (oc2->linkN != NULL) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkN->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkN->maxx] - xpos[oc2->linkN->minx])*fabs(ypos[oc2->linkN->maxy] - ypos[oc2->linkN->miny])*fabs(zpos[oc2->linkN->maxz] - zpos[oc2->linkN->minz]);

										if (iml > oc2->linkN->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkN->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != NULL) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkS->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkS->maxx] - xpos[oc2->linkS->minx])*fabs(ypos[oc2->linkS->maxy] - ypos[oc2->linkS->miny])*fabs(zpos[oc2->linkS->maxz] - zpos[oc2->linkS->minz]);

										if (iml > oc2->linkS->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkS->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != NULL) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkE->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkE->maxx] - xpos[oc2->linkE->minx])*fabs(ypos[oc2->linkE->maxy] - ypos[oc2->linkE->miny])*fabs(zpos[oc2->linkE->maxz] - zpos[oc2->linkE->minz]);

										if (iml > oc2->linkE->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkE->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != NULL) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkW->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkW->maxx] - xpos[oc2->linkW->minx])*fabs(ypos[oc2->linkW->maxy] - ypos[oc2->linkW->miny])*fabs(zpos[oc2->linkW->maxz] - zpos[oc2->linkW->minz]);

										if (iml > oc2->linkW->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkW->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != NULL) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkT->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkT->maxx] - xpos[oc2->linkT->minx])*fabs(ypos[oc2->linkT->maxy] - ypos[oc2->linkT->miny])*fabs(zpos[oc2->linkT->maxz] - zpos[oc2->linkT->minz]);

										if (iml > oc2->linkT->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkT->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != NULL) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkB->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkB->maxx] - xpos[oc2->linkB->minx])*fabs(ypos[oc2->linkB->maxy] - ypos[oc2->linkB->miny])*fabs(zpos[oc2->linkB->maxz] - zpos[oc2->linkB->minz]);

										if (iml > oc2->linkB->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkB->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							oc2 = NULL;
						}
					}
				}
				if (!octree1->b4B) {
					if (octree1->linkB != NULL) {
						if (abs(octree1->ilevel - octree1->linkB->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance B is found...\n");
							}
							if (octree1->ilevel > octree1->linkB->ilevel) {
								octree1->linkB->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//getchar();
						}
						else if (abs(octree1->ilevel - octree1->linkB->ilevel) == 1) {
							integer iml = octree1->ilevel;
							doublereal viml = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
							bool biml = true;
							if (octree1->linkB->ilevel > iml) {
								iml = octree1->linkB->ilevel;
								viml = fabs(xpos[octree1->linkB->maxx] - xpos[octree1->linkB->minx])*fabs(ypos[octree1->linkB->maxy] - ypos[octree1->linkB->miny])*fabs(zpos[octree1->linkB->maxz] - zpos[octree1->linkB->minz]);
								biml = false;
							}
							octTree* oc2 = octree1->linkB;
							if (!oc2->b4N) {
								if (oc2->linkN != NULL) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkN->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkN->maxx] - xpos[oc2->linkN->minx])*fabs(ypos[oc2->linkN->maxy] - ypos[oc2->linkN->miny])*fabs(zpos[oc2->linkN->maxz] - zpos[oc2->linkN->minz]);

										if (iml > oc2->linkN->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkN->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != NULL) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkS->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkS->maxx] - xpos[oc2->linkS->minx])*fabs(ypos[oc2->linkS->maxy] - ypos[oc2->linkS->miny])*fabs(zpos[oc2->linkS->maxz] - zpos[oc2->linkS->minz]);

										if (iml > oc2->linkS->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkS->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != NULL) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkE->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkE->maxx] - xpos[oc2->linkE->minx])*fabs(ypos[oc2->linkE->maxy] - ypos[oc2->linkE->miny])*fabs(zpos[oc2->linkE->maxz] - zpos[oc2->linkE->minz]);

										if (iml > oc2->linkE->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkE->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != NULL) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkW->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkW->maxx] - xpos[oc2->linkW->minx])*fabs(ypos[oc2->linkW->maxy] - ypos[oc2->linkW->miny])*fabs(zpos[oc2->linkW->maxz] - zpos[oc2->linkW->minz]);

										if (iml > oc2->linkW->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkW->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != NULL) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkT->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkT->maxx] - xpos[oc2->linkT->minx])*fabs(ypos[oc2->linkT->maxy] - ypos[oc2->linkT->miny])*fabs(zpos[oc2->linkT->maxz] - zpos[oc2->linkT->minz]);

										if (iml > oc2->linkT->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkT->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != NULL) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
									else if (abs(iml - oc2->linkB->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkB->maxx] - xpos[oc2->linkB->minx])*fabs(ypos[oc2->linkB->maxy] - ypos[oc2->linkB->miny])*fabs(zpos[oc2->linkB->maxz] - zpos[oc2->linkB->minz]);

										if (iml > oc2->linkB->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkB->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												if (biml) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							oc2 = NULL;
						}
					}
				}
				octree1 = NULL;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//getchar();
	}
} // marker_disbalance_year2017_2.

  // Для полного контроля линковки.
void marker_disbalnce_year2017(octTree* &oc) {
	printf("marker disbalance control.\n");
	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {
				octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
				if (!octree1->b4N) {
					if (octree1->linkN != NULL) {
						if (abs(octree1->ilevel - octree1->linkN->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance N is found...\n");
							}
							if (octree1->ilevel > octree1->linkN->ilevel) {
								octree1->linkN->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//getchar();
						}
						else if (abs(octree1->ilevel - octree1->linkN->ilevel) == 1) {
							integer iml = octree1->ilevel;
							bool biml = true;
							if (octree1->linkN->ilevel > iml) {
								iml = octree1->linkN->ilevel;
								biml = false;
							}
							octTree* oc2 = octree1->linkN;
							if (!oc2->b4N) {
								if (oc2->linkN != NULL) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != NULL) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != NULL) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != NULL) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != NULL) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != NULL) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							oc2 = NULL;
						}
					}
				}
				if (!octree1->b4S) {
					if (octree1->linkS != NULL) {
						if (abs(octree1->ilevel - octree1->linkS->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance S is found...\n");
							}
							if (octree1->ilevel > octree1->linkS->ilevel) {
								octree1->linkS->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//getchar();
						}
						else if (abs(octree1->ilevel - octree1->linkS->ilevel) == 1) {
							integer iml = octree1->ilevel;
							bool biml = true;
							if (octree1->linkS->ilevel > iml) {
								iml = octree1->linkS->ilevel;
								biml = false;
							}
							octTree* oc2 = octree1->linkS;
							if (!oc2->b4N) {
								if (oc2->linkN != NULL) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != NULL) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != NULL) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != NULL) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != NULL) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != NULL) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							oc2 = NULL;
						}
					}
				}
				if (!octree1->b4E) {
					if (octree1->linkE != NULL) {
						if (abs(octree1->ilevel - octree1->linkE->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance E is found...\n");
							}
							if (octree1->ilevel > octree1->linkE->ilevel) {
								octree1->linkE->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//getchar();
						}
						else if (abs(octree1->ilevel - octree1->linkE->ilevel) == 1) {
							integer iml = octree1->ilevel;
							bool biml = true;
							if (octree1->linkE->ilevel > iml) {
								iml = octree1->linkE->ilevel;
								biml = false;
							}
							octTree* oc2 = octree1->linkE;
							if (!oc2->b4N) {
								if (oc2->linkN != NULL) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != NULL) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != NULL) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != NULL) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != NULL) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != NULL) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							oc2 = NULL;
						}
					}
				}
				if (!octree1->b4W) {
					if (octree1->linkW != NULL) {
						if (abs(octree1->ilevel - octree1->linkW->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance W is found...\n");
							}
							if (octree1->ilevel > octree1->linkW->ilevel) {
								octree1->linkW->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//getchar();
						}
						else if (abs(octree1->ilevel - octree1->linkW->ilevel) == 1) {
							integer iml = octree1->ilevel;
							bool biml = true;
							if (octree1->linkW->ilevel > iml) {
								iml = octree1->linkW->ilevel;
								biml = false;
							}
							octTree* oc2 = octree1->linkW;
							if (!oc2->b4N) {
								if (oc2->linkN != NULL) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != NULL) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != NULL) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != NULL) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != NULL) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != NULL) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							oc2 = NULL;
						}
					}
				}
				if (!octree1->b4T) {
					if (octree1->linkT != NULL) {
						if (abs(octree1->ilevel - octree1->linkT->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance T is found...\n");
							}
							if (octree1->ilevel > octree1->linkT->ilevel) {
								octree1->linkT->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//getchar();
						}
						else if (abs(octree1->ilevel - octree1->linkT->ilevel) == 1) {
							integer iml = octree1->ilevel;
							bool biml = true;
							if (octree1->linkT->ilevel > iml) {
								iml = octree1->linkT->ilevel;
								biml = false;
							}
							octTree* oc2 = octree1->linkT;
							if (!oc2->b4N) {
								if (oc2->linkN != NULL) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != NULL) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != NULL) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != NULL) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != NULL) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != NULL) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							oc2 = NULL;
						}
					}
				}
				if (!octree1->b4B) {
					if (octree1->linkB != NULL) {
						if (abs(octree1->ilevel - octree1->linkB->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance B is found...\n");
							}
							if (octree1->ilevel > octree1->linkB->ilevel) {
								octree1->linkB->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//getchar();
						}
						else if (abs(octree1->ilevel - octree1->linkB->ilevel) == 1) {
							integer iml = octree1->ilevel;
							bool biml = true;
							if (octree1->linkB->ilevel > iml) {
								iml = octree1->linkB->ilevel;
								biml = false;
							}
							octTree* oc2 = octree1->linkB;
							if (!oc2->b4N) {
								if (oc2->linkN != NULL) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != NULL) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != NULL) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != NULL) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != NULL) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != NULL) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//getchar();
									}
								}
							}
							oc2 = NULL;
						}
					}
				}
				octree1 = NULL;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//getchar();
	}
} // marker_disbalance_year2017.




  // Для полного контроля линковки.
  // Если соседние ячейки имеют разницу уровней больше единицы,
  // то происходит дробление наибольшей по размеру ячейки.
void marker_disbalnce(octTree* &oc, doublereal* &xpos, doublereal* &ypos, doublereal* &zpos) {
	// Первоначальная базовая версия.
	// написана в 2016 году.
	if (0) {
		marker_disbalnce_year2016(oc);
	}
	else {
		// Качество сетки, получаемое алгоритмом 2016 года не является удовлетворительным
		// по ряду причин. В частности он допускает ячейки соседствующие по вершине, разность уровней у которых равна 2.
		// Эту ситуацию исправляет версия той-же функции, но 2017 года. Теперь нет ячеек соседствующих по вершине разница уровней у
		// которых достигает 2.
		//marker_disbalnce_year2017(oc); //17 augut 2017.
		marker_disbalnce_year2017_2(oc,xpos, ypos,zpos); //17 augut 2017.
	}
}

// Для полного контроля линковки.
void is_b4N_found(octTree* &oc) {
	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {
				// Гасим информацию о посещениях.
				octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
				if (octree1->b4N) {
					printf("b4N is found now in list");
					if (octree1->brootSituationY) {
						printf(" sitY=1");
					}
					else {
						printf(" sitY=0");
					}
					if (octree1->brootSituationX) {
						printf(" sitX=1");
					}
					else {
						printf(" sitX=0");
					}
					if (octree1->brootSituationZ) {
						printf(" sitZ=1");
					}
					else {
						printf(" sitZ=0");
					}
#if doubleintprecision == 1
					printf(" oc->root=%lld", octree1->root);
#else
					printf(" oc->root=%d", octree1->root);
#endif
					
					//getchar();
					system("PAUSE");
				}
				octree1 = NULL;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//getchar();
	}
} // is_b4N_found

// Освобождение оперативной памяти из под octree.
void free_octree(octTree* &oc) {
	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if ((my_ALICE_STACK[top_ALICE_STACK - 1].link->link0==NULL)&&
				(my_ALICE_STACK[top_ALICE_STACK - 1].link->link1 == NULL)&&
				(my_ALICE_STACK[top_ALICE_STACK - 1].link->link2 == NULL)&&
				(my_ALICE_STACK[top_ALICE_STACK - 1].link->link3 == NULL)&&
				(my_ALICE_STACK[top_ALICE_STACK - 1].link->link4 == NULL)&&
				(my_ALICE_STACK[top_ALICE_STACK - 1].link->link5 == NULL)&&
				(my_ALICE_STACK[top_ALICE_STACK - 1].link->link6 == NULL)&&
				(my_ALICE_STACK[top_ALICE_STACK - 1].link->link7 == NULL))
			{
				// Гасим информацию о посещениях.
				octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
				switch (octree1->parent->root) {
				case 0: octree1->parent->link0 = NULL; break;
				case 1: octree1->parent->link1 = NULL; break;
				case 2: octree1->parent->link2 = NULL; break;
				case 3: octree1->parent->link3 = NULL; break;
				case 4: octree1->parent->link4 = NULL; break;
				case 5: octree1->parent->link5 = NULL; break;
				case 6: octree1->parent->link6 = NULL; break;
				case 7: octree1->parent->link7 = NULL; break;
				}
				//6.01.2018
				// Ликвидируем все ссылки из всех соседних листов на конкретный данный лист.
				for (integer i_90 = top_ALICE_STACK - 2; i_90 >= 0; i_90--) {
					if (my_ALICE_STACK[i_90].link != NULL) {
						if ((my_ALICE_STACK[i_90].link->link0 == NULL) &&
							(my_ALICE_STACK[i_90].link->link1 == NULL) &&
							(my_ALICE_STACK[i_90].link->link2 == NULL) &&
							(my_ALICE_STACK[i_90].link->link3 == NULL) &&
							(my_ALICE_STACK[i_90].link->link4 == NULL) &&
							(my_ALICE_STACK[i_90].link->link5 == NULL) &&
							(my_ALICE_STACK[i_90].link->link6 == NULL) &&
							(my_ALICE_STACK[i_90].link->link7 == NULL))
						{
							if (my_ALICE_STACK[i_90].link->linkW != NULL) {
								if (my_ALICE_STACK[i_90].link->linkW == octree1) {
									my_ALICE_STACK[i_90].link->linkW = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkE != NULL) {
								if (my_ALICE_STACK[i_90].link->linkE == octree1) {
									my_ALICE_STACK[i_90].link->linkE = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkS != NULL) {
								if (my_ALICE_STACK[i_90].link->linkS == octree1) {
									my_ALICE_STACK[i_90].link->linkS = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkN != NULL) {
								if (my_ALICE_STACK[i_90].link->linkN == octree1) {
									my_ALICE_STACK[i_90].link->linkN = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkB != NULL) {
								if (my_ALICE_STACK[i_90].link->linkB == octree1) {
									my_ALICE_STACK[i_90].link->linkB = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkT != NULL) {
								if (my_ALICE_STACK[i_90].link->linkT == octree1) {
									my_ALICE_STACK[i_90].link->linkT = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkW0 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkW0 == octree1) {
									my_ALICE_STACK[i_90].link->linkW0 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkW3 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkW3 == octree1) {
									my_ALICE_STACK[i_90].link->linkW3 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkW4 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkW4 == octree1) {
									my_ALICE_STACK[i_90].link->linkW4 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkW7 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkW7 == octree1) {
									my_ALICE_STACK[i_90].link->linkW7 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkE1 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkE1 == octree1) {
									my_ALICE_STACK[i_90].link->linkE1 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkE2 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkE2 == octree1) {
									my_ALICE_STACK[i_90].link->linkE2 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkE5 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkE5 == octree1) {
									my_ALICE_STACK[i_90].link->linkE5 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkE6 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkE6 == octree1) {
									my_ALICE_STACK[i_90].link->linkE6 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkS0 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkS0 == octree1) {
									my_ALICE_STACK[i_90].link->linkS0 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkS1 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkS1 == octree1) {
									my_ALICE_STACK[i_90].link->linkS1 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkS4 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkS4 == octree1) {
									my_ALICE_STACK[i_90].link->linkS4 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkS5 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkS5 == octree1) {
									my_ALICE_STACK[i_90].link->linkS5 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkN2 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkN2 == octree1) {
									my_ALICE_STACK[i_90].link->linkN2 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkN3 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkN3 == octree1) {
									my_ALICE_STACK[i_90].link->linkN3 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkN6 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkN6 == octree1) {
									my_ALICE_STACK[i_90].link->linkN6 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkN7 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkN7 == octree1) {
									my_ALICE_STACK[i_90].link->linkN7 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkB0 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkB0 == octree1) {
									my_ALICE_STACK[i_90].link->linkB0 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkB1 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkB1 == octree1) {
									my_ALICE_STACK[i_90].link->linkB1 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkB2 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkB2 == octree1) {
									my_ALICE_STACK[i_90].link->linkB2 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkB3 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkB3 == octree1) {
									my_ALICE_STACK[i_90].link->linkB3 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkT4 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkT4 == octree1) {
									my_ALICE_STACK[i_90].link->linkT4 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkT5 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkT5 == octree1) {
									my_ALICE_STACK[i_90].link->linkT5 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkT6 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkT6 == octree1) {
									my_ALICE_STACK[i_90].link->linkT6 = NULL;
								}
							}
							if (my_ALICE_STACK[i_90].link->linkT7 != NULL) {
								if (my_ALICE_STACK[i_90].link->linkT7 == octree1) {
									my_ALICE_STACK[i_90].link->linkT7 = NULL;
								}
							}
						}
					}
				}

				octree1->parent = NULL;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				octree1->linkW = NULL;
				octree1->linkE = NULL;
				octree1->linkS = NULL;
				octree1->linkN = NULL;
				octree1->linkB = NULL;
				octree1->linkT = NULL;
				octree1->linkW0 = NULL;
				octree1->linkW3 = NULL;
				octree1->linkW4 = NULL;
				octree1->linkW7 = NULL;
				octree1->linkE1 = NULL;
				octree1->linkE2 = NULL;
				octree1->linkE5 = NULL;
				octree1->linkE6 = NULL;
				octree1->linkS0 = NULL;
				octree1->linkS1 = NULL;
				octree1->linkS4 = NULL;
				octree1->linkS5 = NULL;
				octree1->linkN2 = NULL;
				octree1->linkN3 = NULL;
				octree1->linkN6 = NULL;
				octree1->linkN7 = NULL;
				octree1->linkB0 = NULL;
				octree1->linkB1 = NULL;
				octree1->linkB2 = NULL;
				octree1->linkB3 = NULL;
				octree1->linkT4 = NULL;
				octree1->linkT5 = NULL;
				octree1->linkT6 = NULL;
				octree1->linkT7 = NULL;
				delete octree1;
				octree1 = NULL;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//getchar();
	}
} // free_octree


// Реализация данной функции см. Constr Struct.
  // проверяет принадлежит ли контрольный объём
  // тепловой модели.
  // Возвращает параметр ib равный номеру блока
  // которому принадлежит контрольный объём.
bool in_model_temp(TOCHKA p, integer &ib, BLOCK* b, integer lb);

// глобальный счётчик числа попыток
integer iOk28_number_popjtka = 0;

// Процесс построение Адаптивной Локально Измельчённой расчётной Сетки.
// АЛИС - экономит ресурсы ЭВМ и позволяет рассчитывать большие задачи на слабом оборудовании.
bool alice_mesh(doublereal* xpos, doublereal* ypos, doublereal* zpos,
	integer inx, integer iny, integer inz, BLOCK* &b, integer lb, integer lw, WALL* &w, SOURCE* &s, integer &ls, integer maxelm,
	doublereal* &xposadd, doublereal* &yposadd, doublereal* &zposadd,
	integer &inxadd, integer &inyadd, integer &inzadd) {

	iOk28_number_popjtka++;

#if doubleintprecision == 1
	/*
	// индексация начинается с нуля и заканчивается значением inx
	for (integer i = 0; i <= inx; i++) {
	printf("xpos[%lld]=%e\n",i,xpos[i]);
	}
	// индексация начинается с нуля и заканчивается значением inx
	for (integer i = 0; i <= iny; i++) {
	printf("ypos[%lld]=%e\n", i, ypos[i]);
	}
	// индексация начинается с нуля и заканчивается значением inx
	for (integer i = 0; i <= inz; i++) {
	printf("zpos[%lld]=%e\n", i, zpos[i]);
	}
	getchar();
	*/
#else
	/*
	// индексация начинается с нуля и заканчивается значением inx
	for (integer i = 0; i <= inx; i++) {
	printf("xpos[%d]=%e\n",i,xpos[i]);
	}
	// индексация начинается с нуля и заканчивается значением inx
	for (integer i = 0; i <= iny; i++) {
	printf("ypos[%d]=%e\n", i, ypos[i]);
	}
	// индексация начинается с нуля и заканчивается значением inx
	for (integer i = 0; i <= inz; i++) {
	printf("zpos[%d]=%e\n", i, zpos[i]);
	}
	getchar();
	*/
#endif
	
	// Вычисление допуска.
	doublereal epsToolx = 1.0e40;
	doublereal epsTooly = 1.0e40;
	doublereal epsToolz = 1.0e40;
	for (integer i = 0; i < inx; i++) {
		if (fabs(xpos[i + 1] - xpos[i]) < epsToolx) {
			epsToolx = 0.5*fabs(xpos[i + 1] - xpos[i]);
		}
	}
	for (integer i = 0; i < iny; i++) {
		if (fabs(ypos[i + 1] - ypos[i]) < epsTooly) {
			epsTooly = 0.5*fabs(ypos[i + 1] - ypos[i]);
		}
	}
	for (integer i = 0; i < inz; i++) {
		if (fabs(zpos[i + 1] - zpos[i]) < epsToolz) {
			epsToolz = 0.5*fabs(zpos[i + 1] - zpos[i]);
		}
	}
	
	//epsToolx *= 5.0;
	//epsTooly *= 5.0;
	//epsToolz *= 5.0;
	epsToolx = -1.0e40;
	epsTooly = -1.0e40;
	epsToolz = -1.0e40;
	for (integer i = 0; i < inx; i++) {
		if (fabs(xpos[i + 1] - xpos[i]) > epsToolx) {
			epsToolx = 0.5*fabs(xpos[i + 1] - xpos[i]);
		}
	}
	for (integer i = 0; i < iny; i++) {
		if (fabs(ypos[i + 1] - ypos[i]) > epsTooly) {
			epsTooly = 0.5*fabs(ypos[i + 1] - ypos[i]);
		}
	}
	for (integer i = 0; i < inz; i++) {
		if (fabs(zpos[i + 1] - zpos[i]) > epsToolz) {
			epsToolz = 0.5*fabs(zpos[i + 1] - zpos[i]);
		}
	}
	
	hash_for_droblenie_xyz = new integer**[inx];
	for (integer i_54 = 0; i_54 < inx; i_54++) {
		hash_for_droblenie_xyz[i_54] = new integer*[iny];
	}
	for (integer i_54 = 0; i_54 < inx; i_54++) {
		for (integer i_55 = 0; i_55 < iny; i_55++) {
			hash_for_droblenie_xyz[i_54][i_55] = new integer[inz];
		}
	}
	for (integer i_54 = 0; i_54 < inx; i_54++) {
		for (integer i_55 = 0; i_55 < iny; i_55++) {
			for (integer i_56 = 0; i_56 < inz; i_56++) {
				hash_for_droblenie_xyz[i_54][i_55][i_56] = -1;
			}
		}
	}

	if (1) {
		// 1 января 2018. 
		// Способ заимствован из файла constr_struct.cpp из файла 
		// enumerate_volume_improved_obobshenie.
		// Более сложный и быстродействующий вариант.

		printf("enumerate_volume_improved_obobshenie start.\n");
		Block_indexes* block_indexes = new Block_indexes[lb];
		if (block_indexes == NULL) {
			printf("error in allocation memory for block_indexes in enumerate_volume_improved.\n");
			system("pause");
			exit(1);
		}

		integer i, j, k, i_1 = 0;

		// Погрешность бывает абсолютная и относительная.
		// Вещественные числа в ЭВМ представляются с конечной точностью.
		// Лучше использовать относительную погрешность в 0.15%.
		const doublereal otnositelnaq_tolerance_eps = 0.0015; // 0.15%

		for (i = 0; i < lb; i++) {
			//if (b[i].g.itypegeom == 0) {

			// polygon (b[i].g.itypegeom == 2)
			// Значения прямоугольной призмы xS, xE, yS, yE, zS, zE - хранят окаймляющую
			// полигон прямоугольную призму, что позволит проверять принадлежность точки полигону
			// только для ячеек сетки находящихся внутри данной прямоугольной призмы, что сильно 
			// ускоряет обработку.
			if ((b[i].g.itypegeom == 0) || (b[i].g.itypegeom == 2)) {

				doublereal x4 = b[i].g.xS;
				for (j = 0; j <= inx; j++) {
					if (fabs(x4) > 0.0) {
						// Относительная погрешность менее 0.15%.
						if (fabs(100 * (xpos[j] - x4) / fabs(x4)) < otnositelnaq_tolerance_eps) {
							block_indexes[i_1].iL = j;
							break;
						}
					}
					else {
						// Абсолютная погрешность.
						if (fabs(xpos[j] - x4) < 1.0e-40) {
							block_indexes[i_1].iL = j;
							break;
						}
					}
				}
				x4 = b[i].g.xE;
				for (j = 0; j <= inx; j++) {
					if (fabs(x4) > 0.0) {
						// Относительная погрешность менее 0.15%.
						if (fabs(100 * (xpos[j] - x4) / fabs(x4)) < otnositelnaq_tolerance_eps) {
							block_indexes[i_1].iR = j;
							break;
						}
					}
					else {
						// Абсолютная погрешность.
						if (fabs(xpos[j] - x4) < 1.0e-40) {
							block_indexes[i_1].iR = j;
							break;
						}
					}
				}
				x4 = b[i].g.yS;
				for (j = 0; j <= iny; j++) {
					if (fabs(x4) > 0.0) {
						// Относительная погрешность менее 0.15%.
						if (fabs(100 * (ypos[j] - x4) / fabs(x4)) < otnositelnaq_tolerance_eps) {
							block_indexes[i_1].jL = j;
							break;
						}
					}
					else {
						// Абсолютная погрешность.
						if (fabs(ypos[j] - x4) < 1.0e-40) {
							block_indexes[i_1].jL = j;
							break;
						}
					}
				}
				x4 = b[i].g.yE;
				for (j = 0; j <= iny; j++) {

					if (fabs(x4) > 0.0) {
						// Относительная погрешность менее 0.15%.
						if (fabs(100 * (ypos[j] - x4) / fabs(x4)) < otnositelnaq_tolerance_eps) {
							block_indexes[i_1].jR = j;
							break;
						}
					}
					else {
						// Абсолютная погрешность.
						if (fabs(ypos[j] - x4) < 1.0e-40) {
							block_indexes[i_1].jR = j;
							break;
						}
					}
				}
				x4 = b[i].g.zS;
				for (j = 0; j <= inz; j++) {
					if (fabs(x4) > 0.0) {
						// Относительная погрешность менее 0.15%.
						if (fabs(100 * (zpos[j] - x4) / fabs(x4)) < otnositelnaq_tolerance_eps) {
							block_indexes[i_1].kL = j;
							break;
						}
					}
					else {
						// Абсолютная погрешность.
						if (fabs(zpos[j] - x4) < 1.0e-40) {
							block_indexes[i_1].kL = j;
							break;
						}
					}
				}
				x4 = b[i].g.zE;
				for (j = 0; j <= inz; j++) {
					if (fabs(x4) > 0.0) {
						// Относительная погрешность менее 0.15%.
						if (fabs(100 * (zpos[j] - x4) / fabs(x4)) < otnositelnaq_tolerance_eps) {
							block_indexes[i_1].kR = j;
							break;
						}
					}
					else {
						// Абсолютная погрешность.
						if (fabs(zpos[j] - x4) < 1.0e-40) {
							block_indexes[i_1].kR = j;
							break;
						}
					}
				}

				i_1++;
			}

		}

		// Количество проходов существенно сократилось и в итоге это приводит к существенному
		// увеличению быстродействия.
		integer m7 = 0, m8;

		for (m8 = 0; m8 < lb; m8++) {
			if (b[m8].g.itypegeom == 0) {
#pragma omp parallel for
				for (integer i1 = block_indexes[m7].iL; i1 < block_indexes[m7].iR; i1++) for (integer j1 = block_indexes[m7].jL; j1 < block_indexes[m7].jR; j1++) for (integer k1 = block_indexes[m7].kL; k1 < block_indexes[m7].kR; k1++) {
					hash_for_droblenie_xyz[i1][j1][k1] = m8;
				}
				m7++;
			}
			else if (b[m8].g.itypegeom == 1) {

				// TODO как был сформирован призматический объект для цилиндра ? 
				// Надо также сократить число проверяемых точек.
				// Cylinder
				for (integer i1 = 0; i1 < inx; i1++) for (integer j1 = 0; j1 < iny; j1++) for (integer k1 = 0; k1 < inz; k1++) {
					TOCHKA p;
					p.x = 0.5*(xpos[i1] + xpos[i1 + 1]);
					p.y = 0.5*(ypos[j1] + ypos[j1 + 1]);
					p.z = 0.5*(zpos[k1] + zpos[k1 + 1]);

					switch (b[m8].g.iPlane) {
					case XY:
						if (fabs(b[m8].g.R_in_cyl) < 1.0e-40) {
							if ((p.z > b[m8].g.zC) && (p.z < b[m8].g.zC + b[m8].g.Hcyl)) {
								if (sqrt((b[m8].g.xC - p.x)*(b[m8].g.xC - p.x) + (b[m8].g.yC - p.y)*(b[m8].g.yC - p.y)) < b[i1].g.R_out_cyl) {
									
									hash_for_droblenie_xyz[i1][j1][k1] = m8;
								}
							}
						}
						else {
							if ((p.z > b[m8].g.zC) && (p.z < b[m8].g.zC + b[m8].g.Hcyl)) {
								if (sqrt((b[m8].g.xC - p.x)*(b[m8].g.xC - p.x) + (b[m8].g.yC - p.y)*(b[m8].g.yC - p.y)) < b[m8].g.R_out_cyl) {
									if (sqrt((b[m8].g.xC - p.x)*(b[m8].g.xC - p.x) + (b[m8].g.yC - p.y)*(b[m8].g.yC - p.y)) > b[m8].g.R_in_cyl) {
										
										hash_for_droblenie_xyz[i1][j1][k1] = m8;
									}
								}
							}
						}
						break;
					case XZ:
						if (fabs(b[m8].g.R_in_cyl) < 1.0e-40) {
							if ((p.y > b[m8].g.yC) && (p.y < b[m8].g.yC + b[m8].g.Hcyl)) {
								if (sqrt((b[m8].g.xC - p.x)*(b[m8].g.xC - p.x) + (b[m8].g.zC - p.z)*(b[m8].g.zC - p.z)) < b[m8].g.R_out_cyl) {
																		
									hash_for_droblenie_xyz[i1][j1][k1] = m8;									
								}
							}
						}
						else {
							if ((p.y > b[m8].g.yC) && (p.y < b[m8].g.yC + b[m8].g.Hcyl)) {
								if (sqrt((b[m8].g.xC - p.x)*(b[m8].g.xC - p.x) + (b[m8].g.zC - p.z)*(b[m8].g.zC - p.z)) < b[m8].g.R_out_cyl) {
									if (sqrt((b[m8].g.xC - p.x)*(b[m8].g.xC - p.x) + (b[m8].g.zC - p.z)*(b[m8].g.zC - p.z)) > b[m8].g.R_in_cyl) {
										
										hash_for_droblenie_xyz[i1][j1][k1] = m8;
									}
								}
							}
						}
						break;
					case YZ:
						if (fabs(b[m8].g.R_in_cyl) < 1.0e-40) {
							if ((p.x > b[m8].g.xC) && (p.x < b[m8].g.xC + b[m8].g.Hcyl)) {
								if (sqrt((b[m8].g.yC - p.y)*(b[m8].g.yC - p.y) + (b[m8].g.zC - p.z)*(b[m8].g.zC - p.z)) < b[m8].g.R_out_cyl) {
									
									hash_for_droblenie_xyz[i1][j1][k1] = m8;
								}
							}
						}
						else {
							if ((p.x > b[m8].g.xC) && (p.x < b[m8].g.xC + b[m8].g.Hcyl)) {
								if (sqrt((b[m8].g.yC - p.y)*(b[m8].g.yC - p.y) + (b[m8].g.zC - p.z)*(b[m8].g.zC - p.z)) < b[m8].g.R_out_cyl) {
									if (sqrt((b[m8].g.yC - p.y)*(b[m8].g.yC - p.y) + (b[m8].g.zC - p.z)*(b[m8].g.zC - p.z)) > b[m8].g.R_in_cyl) {
										
										hash_for_droblenie_xyz[i1][j1][k1] = m8;
									}
								}
							}
						}
						break;
					}
				}
			}
			else if (b[m8].g.itypegeom == 2) {

				// polygon
				// Мы сокращаем число проверяемых точек 
				// рассматривая только точки внутри окаймляющей прямоугольной призмы.

#pragma omp parallel for
				for (integer i1 = block_indexes[m7].iL; i1 < block_indexes[m7].iR; i1++) for (integer j1 = block_indexes[m7].jL; j1 < block_indexes[m7].jR; j1++) for (integer k1 = block_indexes[m7].kL; k1 < block_indexes[m7].kR; k1++) {

					//for (integer i1 = 0; i1 < inx; i1++) for (integer j1 = 0; j1 < iny; j1++) for (integer k1 = 0; k1 < inz; k1++) {
					TOCHKA p;
					p.x = 0.5*(xpos[i1] + xpos[i1 + 1]);
					p.y = 0.5*(ypos[j1] + ypos[j1 + 1]);
					p.z = 0.5*(zpos[k1] + zpos[k1 + 1]);

					integer k74 = -1;
					if (in_polygon(p, b[m8].g.nsizei, b[m8].g.xi, b[m8].g.yi, b[m8].g.zi, b[m8].g.hi, b[m8].g.iPlane_obj2, k74, m8)) {
						//printf("i1=%d j1=%d k1=%d inx*iny*inz=%d\n",i1,j1,k1, inx*iny*inz);
						//printf("iL=%d iR=%d jL=%d jR=%d kL=%d kR=%d\n", block_indexes[m7].iL, block_indexes[m7].iR, block_indexes[m7].jL, block_indexes[m7].jR, block_indexes[m7].kL, block_indexes[m7].kR);

						hash_for_droblenie_xyz[i1][j1][k1] = m8;
					}

				}
				m7++;
			}
		}

		delete[] block_indexes;

		printf("enumerate_volume_improved end.\n");

	}
	else {
		// Медленная версия, очевидное простое и медленное решение.
		for (integer i_54 = 0; i_54 < inx; i_54++) {
			for (integer i_55 = 0; i_55 < iny; i_55++) {
				for (integer i_56 = 0; i_56 < inz; i_56++) {
					TOCHKA p;
					p.x = 0.5*(xpos[i_54] + xpos[i_54 + 1]);
					p.y = 0.5*(ypos[i_55] + ypos[i_55 + 1]);
					p.z = 0.5*(zpos[i_56] + zpos[i_56 + 1]);
					integer ib = -1;
					in_model_temp(p, ib, b, lb);
					hash_for_droblenie_xyz[i_54][i_55][i_56] = ib;
				}
			}
		}
	}


	oc_global = new octTree;
	oc_global->inum_TD = 0; // Не принадлежит расчётной области.
	oc_global->inum_FD = 0;// Не принадлежит расчётной области.
	if (oc_global == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for oc in adaptive_local_refinement_mesh generator...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	oc_global->parent = NULL;
	oc_global->ilevel = 0; // истинный root
	oc_global->root = -1000; // истинный root
	oc_global->b_the_geometric_fragmentation = false;
	oc_global->bcrushing_when_balancing = false;
	oc_global->brootSituationX = false;
	oc_global->brootSituationY = false;
	oc_global->brootSituationZ = false;
	oc_global->brootSituationX_virtual = false;
	oc_global->brootSituationY_virtual = false;
	oc_global->brootSituationZ_virtual = false;
	// вообще нет соседей.
	oc_global->maxWsosed = 0;
	oc_global->maxEsosed = 0;
	oc_global->maxSsosed = 0;
	oc_global->maxNsosed = 0;
	oc_global->maxBsosed = 0;
	oc_global->maxTsosed = 0;
	// пока соседей просто нету.
	oc_global->linkW = NULL;
	oc_global->linkE = NULL;
	oc_global->linkS = NULL;
	oc_global->linkN = NULL;
	oc_global->linkB = NULL;
	oc_global->linkT = NULL;
	oc_global->b4W = false;
	oc_global->b4E = false;
	oc_global->b4S = false;
	oc_global->b4N = false;
	oc_global->b4B = false;
	oc_global->b4T = false;
	oc_global->linkW0 = NULL;
	oc_global->linkW3 = NULL;
	oc_global->linkW4 = NULL;
	oc_global->linkW7 = NULL;
	oc_global->linkE1 = NULL;
	oc_global->linkE2 = NULL;
	oc_global->linkE5 = NULL;
	oc_global->linkE6 = NULL;
	oc_global->linkS0 = NULL;
	oc_global->linkS1 = NULL;
	oc_global->linkS4 = NULL;
	oc_global->linkS5 = NULL;
	oc_global->linkN2 = NULL;
	oc_global->linkN3 = NULL;
	oc_global->linkN6 = NULL;
	oc_global->linkN7 = NULL;
	oc_global->linkB0 = NULL;
	oc_global->linkB1 = NULL;
	oc_global->linkB2 = NULL;
	oc_global->linkB3 = NULL;
	oc_global->linkT4 = NULL;
	oc_global->linkT5 = NULL;
	oc_global->linkT6 = NULL;
	oc_global->linkT7 = NULL;
	// лист ли это.
	oc_global->dlist = true;
	oc_global->link0 = NULL;
	oc_global->link1 = NULL;
	oc_global->link2 = NULL;
	oc_global->link3 = NULL;
	oc_global->link4 = NULL;
	oc_global->link5 = NULL;
	oc_global->link6 = NULL;
	oc_global->link7 = NULL;
	my_ALICE_STACK = NULL;
	my_ALICE_STACK = new STACK_ALICE[maxelm];
	if (my_ALICE_STACK == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for my_ALICE_STACK in adaptive_local_refinement_mesh generator...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	top_ALICE_STACK = 0;
	// универсальное построение квадродерева.
	integer minx = 0;
	integer maxx = inx;
	integer miny = 0;
	integer maxy = iny;
	integer minz = 0;
	integer maxz = inz;
	oc_global->maxx = maxx;
	oc_global->minx = minx;
	oc_global->maxy = maxy;
	oc_global->miny = miny;
	oc_global->maxz = maxz;
	oc_global->minz = minz;
	// 1. Дробление по геометрическому признаку.
	droblenie(xpos, ypos, zpos,
		inx, iny, inz, oc_global,
		minx, maxx, miny, maxy, minz, maxz, b, lb, lw, w, s, ls, epsToolx, epsTooly, epsToolz);

	for (integer i_34 = top_ALICE_STACK - 1; i_34 >= 0; i_34--) {
		my_ALICE_STACK[i_34].link = NULL;
	}
	top_ALICE_STACK = 0;
	// 2. (первый проход) обновление подсчёта количества соседей.
	update_max_count_sosed(oc_global);
	top_ALICE_STACK = 0;
	// 3. Один проход дробления для блансировки (ликвидация большого числа соседей).
	// 4. (завершающий проход) обновление подсчёта количества соседей.
	// 5. Восстановление линковки.
	update_link_neighbor(oc_global);
	// 6. Гасим информацию о посещениях.
	shutdown_visit(oc_global);
	//log_message(oc_global);
	// подготовка стека не разрушает дерево.
	for (integer i_34 = top_ALICE_STACK - 1; i_34 >= 0; i_34--) {
		my_ALICE_STACK[i_34].link = NULL;
	}
	top_ALICE_STACK = 0;
	expt(oc_global, inx, iny, inz, maxelm, xpos, ypos, zpos);
	printf("export ready\n");
	if (DEBUG_ALICE_MESH) {
		//getchar();
		system("PAUSE");
	}

	printf("The begining construct...\n");
	if (DEBUG_ALICE_MESH) {
		//getchar();
		system("PAUSE");
	}
	doublereal progress_bar = 0.0;
	integer iret34 = 0;
	bool bcont34 = true;
	integer iprohod = 0;
	integer iret_one_scan = 0;
	while (bcont34) {

		
		printf("update max count sosed is start...\n");
		update_max_count_sosed(oc_global);
		printf("update max count sosed is finished.\n");

		bcont34 = false;
		iret_one_scan = 0;
		if (top_ALICE_STACK > maxelm - 3) {
			printf("perepolnenie steka\n");
			//getchar();
			system("PAUSE");
			exit(1);
		}
		iprohod++;
		
		printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b");
#if doubleintprecision == 1
		printf("progress bar %2.3f procent. nodes=%lld iprohod=%lld\n", (100.0*progress_bar) / (inx*iny*inz), (inx + 1)*(iny + 1)*(inz + 1), iprohod);
#else
		printf("progress bar %2.3f procent. nodes=%d iprohod=%d\n", (100.0*progress_bar) / (inx*iny*inz), (inx + 1)*(iny + 1)*(inz + 1), iprohod);
#endif
		// 1. Дробление листьев по геометрическому признаку.
		printf("droblenie list po geometricheskomu prisnaku. begin.\n");
		droblenie_list_octTree2(oc_global, xpos, ypos, zpos, iret34, inx, iny, inz, b, lb, lw, w, s, ls, epsToolx,epsTooly,epsToolz);
		printf("droblenie list po geometricheskomu prisnaku. end.\n");
		//getchar();
		iret_one_scan += iret34;
		

		shutdown_visit(oc_global);
		top_ALICE_STACK = 0;
		// 5. Восстановление линковки.
		printf("linkovka geom.\n");
		//getchar();
		update_link_neighbor(oc_global);
		top_ALICE_STACK = 0;

		shutdown_disbalance(oc_global);
		marker_disbalnce(oc_global, xpos, ypos, zpos);
		integer iret_95 = 0;
		droblenie_disbalance(oc_global, xpos, ypos, zpos, iret_95);
		
		iret_one_scan += iret_95;
		//if_disbalnce_marker(oc_global);
		shutdown_disbalance(oc_global);
		top_ALICE_STACK = 0;
#if doubleintprecision == 1
		printf("WARNING scan number=%lld\n", iprohod);
#else
		printf("WARNING scan number=%d\n", iprohod);
#endif
		
		//getchar();
		top_ALICE_STACK = 0;
		if (!B_QUICK_MESHING) {
			printf("export tecplot geometry droblenie.\n");
			expt(oc_global, inx, iny, inz, maxelm, xpos, ypos, zpos);
		}
		printf("post geometry droblenie sosed count is construct.\n");
		if (DEBUG_ALICE_MESH) {
			//getchar();
			system("PAUSE");
		}
		// 2. (первый проход) обновление подсчёта количества соседей.
		//printf("est li b4N pered sosedv count?\n");
		//getchar();
		//is_b4N_found(oc_global); // находит , но почемуто печатает ситуацию dir Х далее.
		integer iret_97 = 1;
		integer iscan_balance = 0;
		shutdown_visit(oc_global);
		/*
		while (iret_97 > 0) {
			iret_97 = 0;
			//printf("est li b4N pered sosed count is finished.\n");
			top_ALICE_STACK = 0;
			printf("update max count start\n");
			update_max_count_sosed(oc_global);
			top_ALICE_STACK = 0;
			//printf("export tecplot geometry droblenie.");
			//expt(oc_global, inx, iny, inz, maxelm, xpos,ypos,zpos);
			//printf("post geometry droblenie sosed count is construct.\n");
			//getchar();
			//printf("geomtric crushing is succsefull\n");
			//getchar();
			top_ALICE_STACK = 0;
			//printf("b4N start\n");
			//is_b4N_found(oc_global); // находит , но почемуто печатает ситуацию dir Х далее.
			//top_ALICE_STACK = 0;
			// 3. Один проход дробления для блансировки (ликвидация большого числа соседей).
			// Возможно это надо корректировать сразу на лету в момент генерации дробления.
			printf("balance Tree 2 start\n");
			balance_octTree2(oc_global, xpos, ypos, zpos, iret_97, epsTol);
			iret34 += iret_97;
			printf("expt start\n");
			expt(oc_global, inx, iny, inz, maxelm, xpos,ypos,zpos);
			#if doubleintprecision == 1
				printf("iscan_balance=%lld", iscan_balance);
				iscan_balance++;
				printf("export tecplot post balance tree. balance number is=%lld ",iscan_balance-1);
			#else
				printf("iscan_balance=%d", iscan_balance);
				iscan_balance++;
				printf("export tecplot post balance tree. balance number is=%d ",iscan_balance-1);
			#endif
			
			getchar();
		}
		printf("zaversheno balansing. balance crushing is succsefull\n");
		//getchar();
		iret_one_scan += iret34;
		top_ALICE_STACK = 0;
		// 4. (завершающий проход) обновление подсчёта количества соседей.
		update_max_count_sosed(oc);
		top_ALICE_STACK = 0;
		integer iret35 = 0;
		// А может он должен работать вообще на копии дерева oc!!!.
		// Это только проверочный код который должен возвращать iret 35=0.
		//balance_octTree2(oc_global, xpos, ypos, zpos, iret35, epsTol);
		if (iret35 != 0) {
			printf("error !: problem max count sosed vse eshe ochenj veliko. second prohod.\n");
			getchar();
			exit(1);
		}
		*/
		shutdown_visit(oc_global);
		top_ALICE_STACK = 0;
		update_max_count_sosed(oc_global);
		top_ALICE_STACK = 0;
		// 5. Восстановление линковки.
		printf("dodroblenie linking.\n");
		if (DEBUG_ALICE_MESH) {
			//getchar();
			system("PAUSE");
		}
		update_link_neighbor(oc_global);
		top_ALICE_STACK = 0;
		// 5.5 Если с дроблением были проблемы (повторно).
		shutdown_disbalance(oc_global);
		marker_disbalnce(oc_global, xpos, ypos, zpos);
		iret_95 = 0;
		droblenie_disbalance(oc_global, xpos, ypos, zpos, iret_95);
		iret_one_scan += iret_95;
		//if_disbalnce_marker(oc_global);
		shutdown_disbalance(oc_global);
		integer iret_95_memo = iret_95;
		if (iret_95 > 0) {
			
			top_ALICE_STACK = 0;
			// 5. Восстановление линковки.
			printf("ATTANTION !!! dodroblenie 2 linking.  popjtka=%d\n", iOk28_number_popjtka);
			//getchar();
			if (DEBUG_ALICE_MESH) {
				//getchar();
				system("PAUSE");
			}
			update_link_neighbor(oc_global);
			top_ALICE_STACK = 0;
			// 5.5 Если с дроблением были проблемы (повторно).
			shutdown_disbalance(oc_global);
			marker_disbalnce(oc_global, xpos, ypos, zpos);
			iret_95 = 0;
			droblenie_disbalance(oc_global, xpos, ypos, zpos, iret_95);
			iret_one_scan += iret_95;
			//if_disbalnce_marker(oc_global);
			shutdown_disbalance(oc_global);
			integer iret_95_memo1 = iret_95;
			if (iret_95 > 0) {
				
				top_ALICE_STACK = 0;
				// 5. Восстановление линковки.
				printf("ATTANTION !!! dodroblenie 3 linking. popjtka=%d\n", iOk28_number_popjtka);
				//getchar();
				if (DEBUG_ALICE_MESH) {
					//getchar();
					system("PAUSE");
				}
				update_link_neighbor(oc_global);
				top_ALICE_STACK = 0;
				// 5.5 Если с дроблением были проблемы (повторно).
				shutdown_disbalance(oc_global);
				marker_disbalnce(oc_global, xpos, ypos, zpos);
				iret_95 = 0;
				droblenie_disbalance(oc_global, xpos, ypos, zpos, iret_95);
				iret_one_scan += iret_95;
				//if_disbalnce_marker(oc_global);
				shutdown_disbalance(oc_global);
				integer iret_95_memo2 = iret_95;
				if (iret_95 > 0) {
					
					top_ALICE_STACK = 0;
					// 5. Восстановление линковки.
					printf("ATTANTION !!! dodroblenie 4 linking. popjtka=%d\n", iOk28_number_popjtka);
					//getchar();
					if (DEBUG_ALICE_MESH) {
						//getchar();
						system("PAUSE");
					}
					update_link_neighbor(oc_global);
					top_ALICE_STACK = 0;
					// 5.5 Если с дроблением были проблемы (повторно).
					shutdown_disbalance(oc_global);
					marker_disbalnce(oc_global, xpos, ypos, zpos);
					iret_95 = 0;
					droblenie_disbalance(oc_global, xpos, ypos, zpos, iret_95);
					iret_one_scan += iret_95;
					//if_disbalnce_marker(oc_global);
					shutdown_disbalance(oc_global);
					integer iret_95_memo3 = iret_95;
					if (iret_95 > 0) {
						
						top_ALICE_STACK = 0;
						// 5. Восстановление линковки.
						printf("ATTANTION !!! dodroblenie 5 linking. popjtka=%d\n", iOk28_number_popjtka);
						//getchar();
						if (DEBUG_ALICE_MESH) {
							//getchar();
							system("PAUSE");
						}
						update_link_neighbor(oc_global);
						top_ALICE_STACK = 0;
						// 5.5 Если с дроблением были проблемы (повторно).
						shutdown_disbalance(oc_global);
						marker_disbalnce(oc_global, xpos, ypos, zpos);
						iret_95 = 0;
						droblenie_disbalance(oc_global, xpos, ypos, zpos, iret_95);
						iret_one_scan += iret_95;
						//if_disbalnce_marker(oc_global);
						shutdown_disbalance(oc_global);

						integer iret_95_memo4 = iret_95;
						if (iret_95 > 0) {

							top_ALICE_STACK = 0;
							// 5. Восстановление линковки.
							printf("ATTANTION !!! dodroblenie 6 linking. popjtka=%d\n", iOk28_number_popjtka);
							//getchar();
							if (DEBUG_ALICE_MESH) {
								//getchar();
								system("PAUSE");
							}
							update_link_neighbor(oc_global);
							top_ALICE_STACK = 0;
							// 5.5 Если с дроблением были проблемы (повторно).
							shutdown_disbalance(oc_global);
							marker_disbalnce(oc_global, xpos, ypos, zpos);
							iret_95 = 0;
							droblenie_disbalance(oc_global, xpos, ypos, zpos, iret_95);
							iret_one_scan += iret_95;
							//if_disbalnce_marker(oc_global);
							shutdown_disbalance(oc_global);

							integer iret_95_memo5 = iret_95;
							if (iret_95 > 0) {

								top_ALICE_STACK = 0;
								// 5. Восстановление линковки.
								printf("ATTANTION !!! dodroblenie 7 linking. popjtka=%d\n", iOk28_number_popjtka);
								//getchar();
								if (DEBUG_ALICE_MESH) {
									//getchar();
									system("PAUSE");
								}
								update_link_neighbor(oc_global);
								top_ALICE_STACK = 0;
								// 5.5 Если с дроблением были проблемы (повторно).
								shutdown_disbalance(oc_global);
								marker_disbalnce(oc_global, xpos, ypos, zpos);
								iret_95 = 0;
								droblenie_disbalance(oc_global, xpos, ypos, zpos, iret_95);
								iret_one_scan += iret_95;
								//if_disbalnce_marker(oc_global);
								shutdown_disbalance(oc_global);

								integer id_sc = 1;
								while ((iret_95 > 0)&&(id_sc<1000)) {
									top_ALICE_STACK = 0;
									// 5. Восстановление линковки.
#if doubleintprecision == 1
									printf("ATTANTION !!! dodroblenie %lld linking. popjtka=%lld\n", 7 + id_sc, iOk28_number_popjtka);
#else
									printf("ATTANTION !!! dodroblenie %d linking. popjtka=%d\n", 7 + id_sc, iOk28_number_popjtka);
#endif
									
									//getchar();
									if (DEBUG_ALICE_MESH) {
										//getchar();
										system("PAUSE");
									}
									update_link_neighbor(oc_global);
									top_ALICE_STACK = 0;
									// 5.5 Если с дроблением были проблемы (повторно).
									shutdown_disbalance(oc_global);
									marker_disbalnce(oc_global, xpos, ypos, zpos);
									iret_95 = 0;
									droblenie_disbalance(oc_global, xpos, ypos, zpos, iret_95);
									iret_one_scan += iret_95;
									//if_disbalnce_marker(oc_global);
									shutdown_disbalance(oc_global);
									id_sc++; // увеличиваем номер прогона для вывода на консоль
								}

								if (iret_95 > 0) {
#if doubleintprecision == 1
									printf("POLNOE FATAL ERROR : 1007-time balancing NE DALO RESULTATOV iret_95 lists=%lld %lld %lld %lld %lld %lld %lld \n", iret_95, iret_95_memo5, iret_95_memo4, iret_95_memo3, iret_95_memo2, iret_95_memo1, iret_95_memo);
#else
									printf("POLNOE FATAL ERROR : 1007-time balancing NE DALO RESULTATOV iret_95 lists=%d %d %d %d %d %d %d \n", iret_95, iret_95_memo5, iret_95_memo4, iret_95_memo3, iret_95_memo2, iret_95_memo1, iret_95_memo);
#endif
									// Эта ситуация исправляется если включить еще одну дополнительную балансировку. Можно попробовать так.
									//getchar();
									//getchar();
									system("PAUSE");
									system("PAUSE");
								}
							}
						}
					}
				}

			}
			
		}
		

		// 6. Гасим информацию о посещениях.
		shutdown_visit(oc_global);
		top_ALICE_STACK = 0;
		if (iret_one_scan>0) bcont34 = true;
		progress_bar += iret_one_scan;
		if (!B_QUICK_MESHING) {
			expt(oc_global, inx, iny, inz, maxelm, xpos, ypos, zpos);
		}
		printf("linking is finished.\n");

#if doubleintprecision == 1
		printf("export ready one prohod succsefull iret=%lld.\n", iret_one_scan);
		printf("progress bar %2.3f procent. maxnod=%lld iprohod=%lld.\n", (100.0*progress_bar) / (inx*iny*inz), (inx + 1)*(iny + 1)*(inz + 1), iprohod);
#else
		printf("export ready one prohod succsefull iret=%d.\n", iret_one_scan);
		printf("progress bar %2.3f procent. maxnod=%d iprohod=%d.\n", (100.0*progress_bar) / (inx*iny*inz), (inx + 1)*(iny + 1)*(inz + 1), iprohod);
#endif

		if (DEBUG_ALICE_MESH) {
			//getchar();
			system("PAUSE");
		}
		// Важнейший контроль дисбаланса, никаких дисбалансов быть не должно.
		integer iOk28 = 0;
		iOk28 = if_disbalnce(oc_global,inx,iny,inz,maxelm,xpos,ypos,zpos, xposadd, yposadd, zposadd, inxadd, inyadd, inzadd);
		if ((itype_ALICE_Mesh == 1)&&(iOk28>0)) {
			// Только в том случае если мы строим многопроходовую АЛИС сетку высочайшего качества.
			// Это долгий вычислительный процесс.
#if doubleintprecision == 1
			printf("Global restart needed!!! count=%lld\n", iOk28);
#else
			printf("Global restart needed!!! count=%d\n", iOk28);
#endif

			// Не забываем освобождать оперативную память.
			// Освобождение оперативной памяти из под хеш таблицы.
			for (integer i_54 = 0; i_54 < inx; i_54++) {
				for (integer i_55 = 0; i_55 < iny; i_55++) {
					delete[] hash_for_droblenie_xyz[i_54][i_55];
					hash_for_droblenie_xyz[i_54][i_55] = NULL;
				}
			}

			for (integer i_54 = 0; i_54 < inx; i_54++) {
				delete[] hash_for_droblenie_xyz[i_54];
				hash_for_droblenie_xyz[i_54] = NULL;
			}

			delete[] hash_for_droblenie_xyz;
			hash_for_droblenie_xyz = NULL;


			//system("PAUSE");
			// Нужно добавить сеточных линий.
			return false;
		}
		//log_message(oc);
	}
	printf("update max count sosed is start...\n");
	update_max_count_sosed(oc_global);
	printf("update max count sosed is finished.\n");
	printf("FINISHING export tecplot 360 start now.\n");
	expt(oc_global, inx, iny, inz, maxelm, xpos, ypos, zpos);
	printf("END export tecplot 360.\n");
	printf("\n");

	top_ALICE_STACK = 0;
	// Если нужно контролироваать АЛИС сетку то надо включить паузу.
	//system("PAUSE");
	// Он нам еще очень понадобится поэтому ни в коем случае не удаляем.
	//delete[] my_ALICE_STACK;


	// Освобождение оперативной памяти из под хеш таблицы.
	for (integer i_54 = 0; i_54 < inx; i_54++) {
		for (integer i_55 = 0; i_55 < iny; i_55++) {
			delete[] hash_for_droblenie_xyz[i_54][i_55];
			hash_for_droblenie_xyz[i_54][i_55] = NULL;
		}
	}
	
	for (integer i_54 = 0; i_54 < inx; i_54++) {
		delete[] hash_for_droblenie_xyz[i_54];
		hash_for_droblenie_xyz[i_54] = NULL;
	}

	delete[] hash_for_droblenie_xyz;
	hash_for_droblenie_xyz = NULL;

	return true;

}

#endif
